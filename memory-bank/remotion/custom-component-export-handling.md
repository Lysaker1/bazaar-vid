# Custom Component Export Handling

## Problem Description

We identified an issue with custom components not loading properly in the video timeline. When trying to add custom components from the panel to the video, errors would appear in the console:

```
[useRemoteComponent] Component loaded but __REMOTION_COMPONENT not found: 11905696-f0ac-4f00-969f-77e36c57d348
[CustomScene] Metadata fetch timeout for component 7bff90dd-a813-455e-9622-c2d7eb7fa36f after 5 seconds
```

The root cause was that the JavaScript files stored in R2 were using named exports (e.g., `export { Y as BluePlanetCirclingScene }`) instead of assigning the component to `window.__REMOTION_COMPONENT`. The `useRemoteComponent` hook expects the component to be available as `window.__REMOTION_COMPONENT` after the script loads.

## Solution Implementation

We implemented a two-part solution:

### 1. Fix the Component Building Process

Modified the `buildCustomComponent.ts` worker to properly handle different export patterns:

- Added detection for multiple export types (default exports, named exports, function declarations)
- Added explicit handling for `export { X as Y }` pattern to assign the component to `window.__REMOTION_COMPONENT`
- Added fallback mechanism to find components in the global scope if not explicitly assigned
- Made sure to include `Easing` in the list of Remotion imports

### 2. Fix the Component Loading in API Route

Modified the `/api/components/[componentId]/route.ts` endpoint to:

- Check the loaded JavaScript content for different export patterns
- Inject additional code to properly expose named exports on the window object
- Handle various export formats with a reliable fallback mechanism
- Use strict cache control to ensure fresh content is always loaded

## Example Component Export Patterns

### Named Export Pattern

When a component uses named exports like:

```javascript
export { Y as BluePlanetCirclingScene };
```

We now inject code that captures these exports and assigns them to `window.__REMOTION_COMPONENT`:

```javascript
;(function() {
  // Find the exported component and assign it to window.__REMOTION_COMPONENT
  const moduleExports = {};
  const oldExport = window.export;
  window.export = function(obj) { 
    Object.assign(moduleExports, obj);
  };
  try {
    // For any named exports like BluePlanetCirclingScene
    if (moduleExports) {
      // Get the first exported component
      const componentName = Object.keys(moduleExports)[0];
      if (componentName && moduleExports[componentName]) {
        window.__REMOTION_COMPONENT = moduleExports[componentName];
        console.log('Registered component from named export:', componentName);
      }
    }
  } catch(e) {
    console.error('Error setting __REMOTION_COMPONENT:', e);
  } finally {
    if (oldExport) window.export = oldExport;
  }
})();
```

### Global Component Detection Fallback

If no specific export pattern is matched, we search for the component in the global scope:

```javascript
;(function() {
  // Try to find the component in the global scope
  try {
    // Check common component names in the window object
    const componentNames = ['Component', 'CustomComponent', 'MainComponent', 'RemotionComponent', 'Scene'];
    for (const name of componentNames) {
      if (typeof window[name] === 'function') {
        window.__REMOTION_COMPONENT = window[name];
        console.log('Registered component from global:', name);
        break;
      }
    }
    
    // If we didn't find a component, log an error
    if (!window.__REMOTION_COMPONENT) {
      console.error('Could not find component to register as __REMOTION_COMPONENT');
    }
  } catch(e) {
    console.error('Error setting __REMOTION_COMPONENT:', e);
  }
})();
```

## Benefits

This approach provides several advantages:

1. **Compatibility**: Works with multiple export patterns generated by different tools and models
2. **Robustness**: Includes multiple fallbacks to find the component even if not explicitly exported
3. **Debugging**: Includes verbose logging to track how components are registered
4. **Performance**: Avoids unnecessary rebuilds while ensuring fresh content

## Future Improvements

For future iterations, consider:

1. Standardizing the export format in the component generation process
2. Adding more robust validation of components before storing in R2
3. Implementing a component testing step before making components available
4. Creating a more structured approach to component metadata 