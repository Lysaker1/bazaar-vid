
## Remotion Component Generation Pipeline

### 1. `chatOrchestration.service.ts` (`generateRemotionComponent` Tool)
- **Calls** `animationDesigner.service.ts` to get an **AnimationDesignBrief (ADB)**.
- **Calls** `componentGenerator.service.ts` (`generateComponent` function) with this ADB.

---

### 2. `componentGenerator.service.ts` (`generateComponent` function)
- **Constructs** a very detailed prompt for the LLM based on the ADB.
- **Creates** a `customComponentJobs` record in the DB with:
  - status: `"pending"`
  - the detailed prompt in `metadata`
- **Asynchronously calls** `processComponentJob(jobId)` (from `generateComponentCode.ts`).
- **Returns immediately** to the chat, saying the component is being generated.

---

### 3. `generateComponentCode.ts` (`processComponentJob` function)
- **Retrieves** the job (including the detailed prompt from `metadata`).
- **Calls** `generateComponentCode(jobId, prompt)`.

---

### 4. `generateComponentCode.ts` (`generateComponentCode` function)
- **First LLM call for code generation** happens here.
- **Uses** a system prompt and the detailed user prompt (constructed in `componentGenerator.service.ts`) to ask OpenAI (model `o4-mini`) to generate TSX code using a function call `generate_remotion_component`.
- The LLM is expected to return:
  - `componentName`
  - `componentCode` (the TSX string)
  - `componentDescription`
  - `dependencies`
- The `componentCode` (TSX string) is processed:
  - Markdown fences removed
  - `"use client";` added
  - Basic export fix
- This raw TSX string is then **saved back** to the `customComponentJobs` record in the DB (in the `tsxCode` field), and the status is updated to `"building"`.

---

### 5. `buildCustomComponent.ts` (`processPendingJobs` and `processJob` / `buildCustomComponent` functions)
- This worker periodically looks for jobs with status `"pending"` or is called directly with a `jobId`.
  - (It seems `processPendingJobs` looks for `"pending"`, but `generateComponentCode.ts` sets status to `"building"`. `buildCustomComponent` then sets it to `"building"` again. This might be a slight state discrepancy, or `processPendingJobs` is a poller for things that didn't immediately get picked up.)

#### **Key step for "build process fails":**
- **Retrieves** the `tsxCode` (the string generated by the LLM in the previous step) from the database.
- **Performs sanitization**:
  - `sanitizeTsx`
  - `removeDuplicateDefaultExports`
- **`wrapTsxWithGlobals`:**
  - Strips all import statements
  - Tries to make React and Remotion APIs available via `window.React` and `window.Remotion.*`
  - (This implies the component will be run in an environment where these are globally available.)

#### **Compilation:**
- **Attempts** to use `esbuild` to compile the `wrappedTsx` string into a single JavaScript bundle (format: `'iife'` or `esm`).
  - This step transpiles TSX to JS, resolves JSX, and bundles.
- If `esbuild` fails or is unavailable, it uses a `compileWithFallback` which is a very rudimentary string-replacement "compiler" (this will likely break for any non-trivial component).
- The resulting JavaScript bundle (from `esbuild` or fallback) is **uploaded to R2**.
- The job status is updated to `"success"` with the R2 URL or `"error"`.

---

## Root Cause Analysis - Revisited

### 1. ADB Validation Failures (Still High Priority)

- As discussed before, the schema mismatch between `toolParametersJsonSchema` in `animationDesigner.service.ts` and your Zod `animationDesignBriefSchema` is still highly likely to cause ADB validation failures.
- This means the brief passed to `componentGenerator.service.ts` is often a less detailed fallback, potentially impacting the quality of the prompt sent to the LLM for TSX code generation in `generateComponentCode.ts`.

---

### 2. Component Generation Failures (Now points to esbuild or the LLM-generated TSX)

- Your sprint report:  
  _"Most custom component jobs are showing 'error' status." and "The system successfully generates TSX code but the build process fails."_
- **"Successfully generates TSX code"** refers to the output of `generateComponentCode.fn.ts`'s LLM call, which is stored in `job.tsxCode`.
- **"Build process fails"** refers to the esbuild step (or fallback) in `buildCustomComponent.ts`.

#### Possible reasons for esbuild failure:

- **Syntactically Incorrect TSX from LLM:**  
  The LLM, despite the detailed prompt, might still generate TSX that is not valid (e.g., mismatched tags, incorrect hook usage outside components, invalid TypeScript syntax).
- **Type Errors:**  
  Even if syntactically okay, esbuild (which processes TypeScript) might fail on type errors if the LLM generates code that doesn't type-check.
- **Import/Export Issues within the generated TSX:**  
  While `wrapTsxWithGlobals` removes top-level imports, if the LLM generates code that internally tries to use modules in an unexpected way, or has faulty export structures that confuse esbuild even before wrapping, it could fail. Your `sanitizeDefaultExports` and `removeDuplicateDefaultExports` functions show you're already fighting with LLM output quality here.
- **esbuild Configuration:**  
  The esbuild config in `buildCustomComponent.ts` is quite basic. It correctly sets `loader: 'tsx'`, `platform: 'browser'`, `format: 'esm'` (or `iife` in another spot - consistency here is good, `esm` is generally more modern for potential dynamic imports in browser if Player supports it, `iife` is simpler for direct script tag). The `external: ['react', 'remotion']` is crucial and correct if React/Remotion are provided globally.
- **Fallback Compiler:**  
  If esbuild fails and it goes to `compileWithFallback`, this fallback is extremely basic and will almost certainly produce non-working JS for any moderately complex component. This would lead to an "error" status or a "successful" build of broken code.
- **The wrapTsxWithGlobals approach:**  
  This is a valid strategy for loading remote components, but it's delicate. The LLM must not try to re-declare React or import remotion itself. Your sanitization tries to handle this.
  - The LLM must also correctly use the exact global names (`window.Remotion.AbsoluteFill`, etc.). If it generates `import { AbsoluteFill } from 'remotion';` and your sanitizer misses it, or uses just `AbsoluteFill` hoping it's a global, it will fail. The prompt in `componentGenerator.service.ts` tries to guide this with `const AbsoluteFill = window.Remotion?.AbsoluteFill;` etc. in the boilerplate, which is good.







---

## A. ADB Validation Failures (Still #1)

- **Raw LLM arguments for `generate_animation_design_brief` tool call:**  
  The JSON string from the LLM before any parsing or fixing in `animationDesigner.service.ts`.

- **The Zod validation error for that raw brief.**

- **Action:**  
  We need to align the `toolParametersJsonSchema` (specifically its `animations` part) in `animationDesigner.service.ts` with your Zod `animationSchema`.

---

## B. Component Build Failures (Errors in `buildCustomComponent.ts`)

- **A `job.tsxCode` example:**  
  For a job that fails the esbuild step, what is the exact TSX string (from the database `customComponentJobs.tsxCode` column) that was fed into esbuild?

- **The exact esbuild error message:**  
  The `buildCustomComponent` logs errors from esbuild. What does it say?

  ```ts
  // In buildCustomComponent.ts (already there, just ensure you capture this log)
  // Inside catch (error) for esbuild.build:
  buildLogger.error(jobId, "esbuild compilation failed", { type: "COMPILE:ERROR" });
  // ... and the more detailed parsing of error.message
  ```

- **Use code with caution.**  
  TypeScript

- **If it uses `compileWithFallback`:**  
  Does the log indicate it's using the fallback? The resulting JS from the fallback will likely be broken.

---

## C. For the Preview Itself

- **How are React and Remotion made globally available in your preview environment?**  
  (e.g., via `<script>` tags in your HTML shell before loading any custom component code?)

- **How does your preview load and render `window.__REMOTION_COMPONENT`?**  
  A snippet of the preview's Player setup would be helpful.

---

## Specific Code Review Points & Small Suggestions

### `generateComponentCode.ts` → `generateComponentCode` function

- The `animationBrief` parameter is typed as `object`.  
  It should be `AnimationDesignBrief | undefined` for better type safety if you intend to pass the parsed brief. Currently, `enhancedDescription` uses it, so it's important.

- The system prompt for this LLM call is quite generic.  
  The much more detailed prompt is passed as the user message (description which is `job.metadata.prompt`). This is fine, but ensure the system prompt doesn't conflict.

- The function call `generate_remotion_component` asks the LLM for `componentName`, `componentCode`, `componentDescription`, `dependencies`.  
  This means the LLM is responsible for the entire file content. This is a common approach.

---

### `buildCustomComponent.ts` → `wrapTsxWithGlobals`

- The logic to find `componentName` to assign to `window.__REMOTION_COMPONENT` is quite heuristic.  
  It tries `defaultExport`, then function/const declarations. This can be brittle if the LLM structures code unexpectedly.  
  A more robust way (if possible) is to have the LLM always export a specific, known name, e.g., `export default function MySceneComponent(...)`.  
  Your prompt in `componentGenerator.service.ts` does specify `export const ${componentName}: React.FC<{ brief: AnimationDesignBrief }> = ({ brief }) => {`, which is good.  
  The wrapper should then try to find that specific `componentName`.

---

### `buildCustomComponent.ts` → `processPendingJobs` status check

- It queries for `status: "pending"`.
- But `processComponentJob` (in `generateComponentCode.ts`) sets the status to `"building"` after the LLM generates the TSX code.
- This means `processPendingJobs` might not pick up jobs processed by `processComponentJob` unless there's another mechanism or if `processComponentJob` could fail before setting status to `"building"`.
- The `buildCustomComponent(jobId, forceRebuild = false)` function seems to be the main entry point for actually building a specific job, and it correctly handles various statuses.  
  Perhaps `processPendingJobs` is a sweeper for jobs that got stuck in `"pending"`.

---