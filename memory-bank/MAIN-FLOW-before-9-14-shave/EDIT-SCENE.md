//memory-bank/sprints/sprint31/EDIT-SCENE.md
# Edit Scene Tool Analysis (`editScene.ts`)

This document provides a detailed analysis of the `EditSceneTool` found in `src/lib/services/mcp-tools/editScene.ts`. Its primary function is to modify existing Remotion scenes based on user prompts, leveraging an LLM for code generation and contextual understanding.

## 1. Overview

- **File Location**: `src/lib/services/mcp-tools/editScene.ts`
- **Purpose**: To provide a structured way to edit existing Remotion scene components. It takes a user's natural language prompt, the current scene's code, name, and duration, along with contextual information like project ID, scene ID, storyboard, and chat history, to generate updated scene code, name, and duration.
- **Core Mechanism**: It utilizes a `DirectCodeEditorService` for precise code modifications and a `ConversationalResponseService` to generate user-facing explanations for the changes.

## 2. Input Schema (`editSceneInputSchema`)

The tool expects an input object validated by a Zod schema. The fields are as follows:

-   `userPrompt` (string, required): The user's natural language description of the desired modifications to the scene.
    *   *Example*: "Change the background color to blue and make the text spin."
-   `existingCode` (string, required): The current JavaScript/TypeScript code of the Remotion scene component.
-   `existingName` (string, required): The current name of the scene (e.g., "IntroScene", "ProductShot").
-   `existingDuration` (number, required): The current duration of the scene in seconds.
-   `projectId` (string, required): The ID of the project to which this scene belongs. Used for contextual understanding and potentially for fetching project-specific assets or configurations.
-   `sceneId` (string, optional): The unique identifier of the scene being edited. This helps in tracking and managing specific scene instances.
-   `storyboardSoFar` (array of any, optional): An array representing the existing scenes in the storyboard. This provides context about preceding and succeeding scenes, which can influence the edit.
    *   *Structure*: Typically an array of objects, where each object might contain `sceneId`, `name`, `duration`, etc.
-   `chatHistory` (array of objects, optional): A history of the conversation leading up to the edit request. This helps the LLM understand the context of the user's prompt.
    *   *Object Structure*: Each object in the array has:
        *   `role` (string): Who said it (e.g., "user", "assistant").
        *   `content` (string): The message content.

## 3. Output Structure (`editSceneOutputSchema`)

The tool produces an output object, also validated by a Zod schema, containing the results of the edit operation:

-   `sceneCode` (string): The modified JavaScript/TypeScript code for the Remotion scene component.
-   `sceneName` (string): The (potentially updated) name of the scene.
-   `duration` (number): The (potentially updated) duration of the scene in seconds.
-   `reasoning` (string): An explanation from the LLM detailing why the changes were made and how they address the user's prompt.
-   `changes` (array of strings): A list of specific changes made to the code. This helps in tracking modifications.
-   `preserved` (array of strings): A list of elements or functionalities from the original code that were intentionally preserved.
-   `debug` (object, optional): An optional object containing debugging information from the editing process.
    *   `originalPrompt` (string): The initial prompt sent to the code editing LLM.
    *   `editedPrompt` (string, optional): If the prompt was modified before sending to the LLM.
    *   `llmResponse` (string): The raw response from the code editing LLM.
-   `chatResponse` (string): A user-facing message summarizing the edit and potentially asking for confirmation or further instructions. This is generated by the `ConversationalResponseService`.

## 4. Operational Flow

1.  **Input Validation**: The input object is first validated against `editSceneInputSchema`.
2.  **Service Initialization**: Instances of `DirectCodeEditorService` and `ConversationalResponseService` are created.
3.  **Code Editing**: 
    *   The `DirectCodeEditorService` is invoked with the `userPrompt`, `existingCode`, `existingName`, `existingDuration`, `storyboardSoFar`, and `chatHistory`.
    *   This service internally uses an LLM to understand the prompt and apply surgical edits to the `existingCode`.
    *   It aims to return the new `sceneCode`, `sceneName`, `duration`, `reasoning` for changes, a list of `changes`, and a list of `preserved` elements.
4.  **Conversational Response Generation**:
    *   The `ConversationalResponseService` is invoked with the `userPrompt`, `reasoning` from the code editor, `changes` made, and `preserved` elements.
    *   This service generates a natural language `chatResponse` to communicate the outcome of the edit to the user.
5.  **Output Assembly**: The results from the code editing and conversational response services, along with any debug information, are assembled into the final output object.
6.  **Output Validation**: The final output object is validated against `editSceneOutputSchema` before being returned.

## 5. Integration with System

-   The `EditSceneTool` is designed to be used as an MCP (Model-Controller-Presenter) tool, likely invoked by an orchestrator or a higher-level service in response to a user's request to edit a scene within the application.
-   It would typically be part of a tRPC procedure that the frontend calls when a user interacts with an "edit scene" feature.
-   The output (`sceneCode`, `sceneName`, `duration`) is used to update the scene's data in the backend (database) and refresh the scene in the Remotion player on the frontend.
-   The `chatResponse` is displayed to the user in the chat interface.

## 6. Key Dependencies

-   **Zod**: For schema definition and validation of inputs and outputs.
-   **`DirectCodeEditorService`**: An internal service responsible for the core logic of understanding the user's edit request and modifying the scene code using an LLM. This service encapsulates the complexities of interacting with the code generation model.
-   **`ConversationalResponseService`**: An internal service that takes the technical details of the code changes and translates them into a user-friendly conversational message.
-   **LLM (Large Language Model)**: Implicitly used by both `DirectCodeEditorService` and `ConversationalResponseService` for code generation, understanding natural language, and generating responses.

## 7. Considerations & Potential Issues

-   **Prompt Engineering**: The quality of the edits heavily depends on the clarity and specificity of the `userPrompt` and the effectiveness of the prompt engineering within `DirectCodeEditorService`.
-   **Code Validity**: Ensuring the LLM-generated `sceneCode` is always valid and functional Remotion code can be challenging. Robust error handling and potentially a validation step for the generated code might be necessary.
-   **Contextual Limitations**: While `storyboardSoFar` and `chatHistory` provide context, complex inter-scene dependencies or long-term project goals might not always be fully captured, potentially leading to suboptimal edits.
-   **Idempotency**: The tool itself is not inherently idempotent. Repeatedly applying the same prompt to the same scene might lead to different or compounded results, depending on the LLM's behavior and the evolving `existingCode`.

This analysis provides a foundational understanding of the `EditSceneTool`. Further testing and observation in a live environment will be crucial to fully grasp its capabilities and limitations.
