
## Remotion Component Generation Pipeline

### 1. `chatOrchestration.service.ts` (`generateRemotionComponent` Tool)
- **Calls** `animationDesigner.service.ts` to get an **AnimationDesignBrief (ADB)**.
- **Calls** `componentGenerator.service.ts` (`generateComponent` function) with this ADB.

---

### 2. `componentGenerator.service.ts` (`generateComponent` function)
- **Constructs** a very detailed prompt for the LLM based on the ADB.
- **Creates** a `customComponentJobs` record in the DB with:
  - status: `"pending"`
  - the detailed prompt in `metadata`
- **Asynchronously calls** `processComponentJob(jobId)` (from `generateComponentCode.ts`).
- **Returns immediately** to the chat, saying the component is being generated.

---

### 3. `generateComponentCode.ts` (`processComponentJob` function)
- **Retrieves** the job (including the detailed prompt from `metadata`).
- **Calls** `generateComponentCode(jobId, prompt)`.

---

### 4. `generateComponentCode.ts` (`generateComponentCode` function)
- **First LLM call for code generation** happens here.
- **Uses** a system prompt and the detailed user prompt (constructed in `componentGenerator.service.ts`) to ask OpenAI (model `o4-mini`) to generate TSX code using a function call `generate_remotion_component`.
- The LLM is expected to return:
  - `componentName`
  - `componentCode` (the TSX string)
  - `componentDescription`
  - `dependencies`
- The `componentCode` (TSX string) is processed:
  - Markdown fences removed
  - `"use client";` added
  - Basic export fix
- This raw TSX string is then **saved back** to the `customComponentJobs` record in the DB (in the `tsxCode` field), and the status is updated to `"building"`.

---

### 5. `buildCustomComponent.ts` (`processPendingJobs` and `processJob` / `buildCustomComponent` functions)
- This worker periodically looks for jobs with status `"pending"` or is called directly with a `jobId`.
  - (It seems `processPendingJobs` looks for `"pending"`, but `generateComponentCode.ts` sets status to `"building"`. `buildCustomComponent` then sets it to `"building"` again. This might be a slight state discrepancy, or `processPendingJobs` is a poller for things that didn't immediately get picked up.)

#### **Key step for "build process fails":**
- **Retrieves** the `tsxCode` (the string generated by the LLM in the previous step) from the database.
- **Performs sanitization**:
  - `sanitizeTsx`
  - `removeDuplicateDefaultExports`
- **`wrapTsxWithGlobals`:**
  - Strips all import statements
  - Tries to make React and Remotion APIs available via `window.React` and `window.Remotion.*`
  - (This implies the component will be run in an environment where these are globally available.)

#### **Compilation:**
- **Attempts** to use `esbuild` to compile the `wrappedTsx` string into a single JavaScript bundle (format: `'iife'` or `esm`).
  - This step transpiles TSX to JS, resolves JSX, and bundles.
- If `esbuild` fails or is unavailable, it uses a `compileWithFallback` which is a very rudimentary string-replacement "compiler" (this will likely break for any non-trivial component).
- The resulting JavaScript bundle (from `esbuild` or fallback) is **uploaded to R2**.
- The job status is updated to `"success"` with the R2 URL or `"error"`.

---

## Root Cause Analysis - Revisited

### 1. ADB Validation Failures (Still High Priority)

- As discussed before, the schema mismatch between `toolParametersJsonSchema` in `animationDesigner.service.ts` and your Zod `animationDesignBriefSchema` is still highly likely to cause ADB validation failures.
- This means the brief passed to `componentGenerator.service.ts` is often a less detailed fallback, potentially impacting the quality of the prompt sent to the LLM for TSX code generation in `generateComponentCode.ts`.

---

### 2. Component Generation Failures (Now points to esbuild or the LLM-generated TSX)

- Your sprint report:  
  _"Most custom component jobs are showing 'error' status." and "The system successfully generates TSX code but the build process fails."_
- **"Successfully generates TSX code"** refers to the output of `generateComponentCode.fn.ts`'s LLM call, which is stored in `job.tsxCode`.
- **"Build process fails"** refers to the esbuild step (or fallback) in `buildCustomComponent.ts`.

#### Possible reasons for esbuild failure:

- **Syntactically Incorrect TSX from LLM:**  
  The LLM, despite the detailed prompt, might still generate TSX that is not valid (e.g., mismatched tags, incorrect hook usage outside components, invalid TypeScript syntax).
- **Type Errors:**  
  Even if syntactically okay, esbuild (which processes TypeScript) might fail on type errors if the LLM generates code that doesn't type-check.
- **Import/Export Issues within the generated TSX:**  
  While `wrapTsxWithGlobals` removes top-level imports, if the LLM generates code that internally tries to use modules in an unexpected way, or has faulty export structures that confuse esbuild even before wrapping, it could fail. Your `sanitizeDefaultExports` and `removeDuplicateDefaultExports` functions show you're already fighting with LLM output quality here.
- **esbuild Configuration:**  
  The esbuild config in `buildCustomComponent.ts` is quite basic. It correctly sets `loader: 'tsx'`, `platform: 'browser'`, `format: 'esm'` (or `iife` in another spot - consistency here is good, `esm` is generally more modern for potential dynamic imports in browser if Player supports it, `iife` is simpler for direct script tag). The `external: ['react', 'remotion']` is crucial and correct if React/Remotion are provided globally.
- **Fallback Compiler:**  
  If esbuild fails and it goes to `compileWithFallback`, this fallback is extremely basic and will almost certainly produce non-working JS for any moderately complex component. This would lead to an "error" status or a "successful" build of broken code.
- **The wrapTsxWithGlobals approach:**  
  This is a valid strategy for loading remote components, but it's delicate. The LLM must not try to re-declare React or import remotion itself. Your sanitization tries to handle this.
  - The LLM must also correctly use the exact global names (`window.Remotion.AbsoluteFill`, etc.). If it generates `import { AbsoluteFill } from 'remotion';` and your sanitizer misses it, or uses just `AbsoluteFill` hoping it's a global, it will fail. The prompt in `componentGenerator.service.ts` tries to guide this with `const AbsoluteFill = window.Remotion?.AbsoluteFill;` etc. in the boilerplate, which is good.







---

## A. ADB Validation Failures (Still #1)

- **Raw LLM arguments for `generate_animation_design_brief` tool call:**  
  The JSON string from the LLM before any parsing or fixing in `animationDesigner.service.ts`.

- **The Zod validation error for that raw brief.**

- **Action:**  
  We need to align the `toolParametersJsonSchema` (specifically its `animations` part) in `animationDesigner.service.ts` with your Zod `animationSchema`.

---

## B. Component Build Failures (Errors in `buildCustomComponent.ts`)

- **A `job.tsxCode` example:**  
  For a job that fails the esbuild step, what is the exact TSX string (from the database `customComponentJobs.tsxCode` column) that was fed into esbuild?

- **The exact esbuild error message:**  
  The `buildCustomComponent` logs errors from esbuild. What does it say?

  ```ts
  // In buildCustomComponent.ts (already there, just ensure you capture this log)
  // Inside catch (error) for esbuild.build:
  buildLogger.error(jobId, "esbuild compilation failed", { type: "COMPILE:ERROR" });
  // ... and the more detailed parsing of error.message
  ```

- **Use code with caution.**  
  TypeScript

- **If it uses `compileWithFallback`:**  
  Does the log indicate it's using the fallback? The resulting JS from the fallback will likely be broken.

---

## C. For the Preview Itself

- **How are React and Remotion made globally available in your preview environment?**  
  (e.g., via `<script>` tags in your HTML shell before loading any custom component code?)

- **How does your preview load and render `window.__REMOTION_COMPONENT`?**  
  A snippet of the preview's Player setup would be helpful.

---

## Specific Code Review Points & Small Suggestions

### `generateComponentCode.ts` → `generateComponentCode` function

- The `animationBrief` parameter is typed as `object`.  
  It should be `AnimationDesignBrief | undefined` for better type safety if you intend to pass the parsed brief. Currently, `enhancedDescription` uses it, so it's important.

- The system prompt for this LLM call is quite generic.  
  The much more detailed prompt is passed as the user message (description which is `job.metadata.prompt`). This is fine, but ensure the system prompt doesn't conflict.

- The function call `generate_remotion_component` asks the LLM for `componentName`, `componentCode`, `componentDescription`, `dependencies`.  
  This means the LLM is responsible for the entire file content. This is a common approach.

---

### `buildCustomComponent.ts` → `wrapTsxWithGlobals`

- The logic to find `componentName` to assign to `window.__REMOTION_COMPONENT` is quite heuristic.  
  It tries `defaultExport`, then function/const declarations. This can be brittle if the LLM structures code unexpectedly.  
  A more robust way (if possible) is to have the LLM always export a specific, known name, e.g., `export default function MySceneComponent(...)`.  
  Your prompt in `componentGenerator.service.ts` does specify `export const ${componentName}: React.FC<{ brief: AnimationDesignBrief }> = ({ brief }) => {`, which is good.  
  The wrapper should then try to find that specific `componentName`.

---

### `buildCustomComponent.ts` → `processPendingJobs` status check

- It queries for `status: "pending"`.
- But `processComponentJob` (in `generateComponentCode.ts`) sets the status to `"building"` after the LLM generates the TSX code.
- This means `processPendingJobs` might not pick up jobs processed by `processComponentJob` unless there's another mechanism or if `processComponentJob` could fail before setting status to `"building"`.
- The `buildCustomComponent(jobId, forceRebuild = false)` function seems to be the main entry point for actually building a specific job, and it correctly handles various statuses.  
  Perhaps `processPendingJobs` is a sweeper for jobs that got stuck in `"pending"`.

---





**Understanding the Dynamic Component Loading Flow:**

1.  **`DynamicVideo.tsx` encounters a scene with `type: "custom"`:**
    *   It uses `sceneRegistry['custom']` which resolves to `CustomScene` (from `src/remotion/components/scenes/index.ts`).

2.  **`CustomScene.tsx` is rendered:**
    *   It receives `data` which includes `componentId` (the job ID).
    *   It renders `<RemoteComponent componentId={componentId} {...data} />`.

3.  **`RemoteComponent` (from `src/hooks/useRemoteComponent.tsx`):**
    *   Calls the `useRemoteComponent(componentId)` hook.

4.  **`useRemoteComponent(componentId)` Hook:**
    *   This is the core of the dynamic loading logic.
    *   It sets `window.React = React` and `window.Remotion = Remotion` to ensure these are globally available *within the Player's iframe context* before the custom script loads. This is crucial and correct.
    *   It dynamically creates a `<script>` tag.
    *   **The `script.src` is `/api/components/${componentId}`.** This means you have an API route (e.g., a Next.js API route, or a tRPC procedure exposed as an API route) that serves the compiled JavaScript bundle for the component.
        *   This API route would fetch the R2 URL (`outputUrl` from `customComponentJobs` for the given `componentId`) and then stream/proxy the content from R2. **Or, even simpler, it could redirect to the R2 URL.**
    *   When the script loads successfully (`script.onload`), it expects `window.__REMOTION_COMPONENT` to be populated (which your `wrapTsxWithGlobals` function in `buildCustomComponent.ts` does).
    *   It then sets this `window.__REMOTION_COMPONENT` as the `component` state.
    *   The hook returns this `component` (or loading/error states).
    *   `RemoteComponent` then renders this loaded `Component` with the passed `props` (which is `scene.data` from `CustomScene`).

**Crucial Prop Passing:**

*   The `componentGenerator.service.ts` creates a prompt instructing the LLM to generate a component expecting `{ brief: AnimationDesignBrief }` as props:
    ```
    enhancedDescriptionLines.push(`- Component MUST accept props: { brief: AnimationDesignBrief } (assume this type is imported).`);
    ```
*   However, `CustomScene.tsx` passes `...data` to `RemoteComponent`, and `RemoteComponent` passes `...props` (which is `scene.data`) to the dynamically loaded component.
    ```typescript
    // CustomScene.tsx
    <RemoteComponent 
      componentId={componentId} 
      {...data} // scene.data is spread here
    />

    // useRemoteComponent.tsx (in RemoteComponent wrapper)
    // The loaded Component gets `...props` which is scene.data
    return <Component {...props} />;
    ```
*   Your `scene.data` for a "custom" scene, as per `input-props.ts`, is `{ componentId: string, /* other props based on component */ }`.
*   **This means the dynamically loaded component is NOT receiving a `brief` prop directly.** It's receiving the contents of `scene.data` spread as individual props.

**Potential Mismatch/Issue:**

If the LLM *strictly* generates a component like:
```typescript
export const MyCustomGeneratedScene: React.FC<{ brief: AnimationDesignBrief }> = ({ brief }) => {
  // ... uses brief.elements, brief.colorPalette, etc.
}
```
Then it will fail at runtime because it's not receiving a `brief` object. Instead, it's receiving `componentId="some-id"` and potentially other properties from `scene.data` as top-level props.

**How to Fix the Prop Mismatch:**

**Option 1: Modify `RemoteComponent` / `CustomScene` to pass the `brief` prop:**
   The `scene.data` contains `componentId`. The `CustomScene` or `RemoteComponent` would need to:
   1. Fetch the full `AnimationDesignBrief` from your database using the `projectId` and `sceneId` (the `scene.id` from `InputProps`, which should match the `sceneId` in the `AnimationDesignBrief`).
   2. Then, pass this fetched `brief` object as the `brief` prop to the dynamically loaded component.
   ```typescript
   // Inside RemoteComponent or a wrapper around it:
   // const { data: adbData } = api.animation.getDesignBriefByScene.useQuery({ projectId, sceneId: props.id_from_scene_data });
   // if (adbData) {
   //   return <Component brief={adbData} {...props} />; // Pass original props too, or just specific ones
   // }
   ```
   This requires `scene.data` to have enough info to fetch the brief, or for the `componentId` to be a reliable link to the ADB.

**Option 2 (Simpler if `scene.data` could hold the ADB): Modify `scene.data` for "custom" types to include the brief:**
   When you construct your `InputProps`, if a scene is "custom", its `data` field could *itself* be the `AnimationDesignBrief`.
   ```typescript
   // input-props.ts - conceptual change
   // For type: "custom"
   // data: animationDesignBriefSchema, // The entire brief
   ```
   Then, `CustomScene` would pass `data={scene.data}` which *is* the brief.
   ```typescript
   // CustomScene.tsx
   <RemoteComponent 
     componentId={data.sceneId} // Assuming sceneId from brief is the componentId
     brief={data} // data is the entire AnimationDesignBrief
   />
   // RemoteComponent.tsx
   return <Component brief={props.brief} {...otherPropsFromSceneData} />;
   ```
   And the LLM prompt would be correct.

**Option 3 (Modify LLM Prompt):** Instruct the LLM to expect props directly from `scene.data`.
   This is more complex because `scene.data` for "custom" is currently just `{ componentId: string, /* other props... */ }`. You'd have to define what "other props" are, and it might be less structured than a full ADB. This is probably not the best approach if you want the component to have rich animation details.

**Recommendation for Prop Passing:**

**Option 1 is generally cleaner if the `AnimationDesignBrief` is large.** The `CustomScene` or a hook within it would be responsible for fetching the full ADB associated with that custom scene (using `projectId` and `scene.id`) and then passing it as `brief={theFetchedAdb}` to `<Component />`. The `componentId` in `scene.data` would still be used by `useRemoteComponent` to load the script.

**API Route `/api/components/${componentId}`:**

*   You need an API route (e.g., in `src/pages/api/components/[componentId].ts` if using Next.js Pages Router, or a similar tRPC procedure mapped to a URL) that does the following:
    1.  Takes `componentId` from the URL.
    2.  Queries the `customComponentJobs` table for that `jobId` (which is `componentId`).
    3.  Gets the `outputUrl` (the R2 URL).
    4.  **Redirects the request to the R2 `outputUrl`** OR fetches the content from R2 and streams it back. A redirect is often simpler and offloads traffic.
        ```typescript
        // Example (Next.js API route)
        // import { NextApiRequest, NextApiResponse } from 'next';
        // import { db, customComponentJobs } from '~/server/db';
        // import { eq } from 'drizzle-orm';

        // export default async function handler(req: NextApiRequest, res: NextApiResponse) {
        //   const { componentId } = req.query;

        //   if (typeof componentId !== 'string') {
        //     return res.status(400).send('Invalid component ID');
        //   }

        //   const job = await db.query.customComponentJobs.findFirst({
        //     where: eq(customComponentJobs.id, componentId),
        //     columns: { outputUrl: true, status: true },
        //   });

        //   if (!job || job.status !== 'success' || !job.outputUrl) {
        //     return res.status(404).send('Component not found or not ready');
        //   }

        //   res.redirect(307, job.outputUrl); // Temporary Redirect
        // }
        ```

**Summary of Key Actionable Areas:**

1.  **ADB Validation (Still #1):**
    *   **Provide:** Raw LLM args for failing ADB, Zod error.
    *   **Goal:** Align tool schema with Zod schema.

2.  **Component Build Failures (`esbuild`):**
    *   **Provide:** `job.tsxCode` for failing job, `esbuild` error.
    *   **Goal:** Debug LLM-generated TSX or `esbuild` config.

3.  **Prop Passing to Custom Components:**
    *   **Decide:** How will the dynamically loaded component receive its `AnimationDesignBrief`?
    *   **Implement:** Adjust `CustomScene` / `RemoteComponent` to fetch and pass the ADB as a `brief` prop, or adjust `scene.data` structure.
    *   Ensure the LLM-generated component correctly accesses this `brief` prop.

4.  **API Route `/api/components/[componentId]`:**
    *   **Implement:** Create this API route to serve/redirect to the R2 component bundle.

This is a very sophisticated setup! The `useRemoteComponent` hook is a good way to handle dynamic loading. We just need to ensure all the pieces connect correctly, especially the data flow (ADB validation) and prop passing.

Section 1 & 2 (No changes needed, very clear)
1. chatOrchestration.service.ts (generateRemotionComponent Tool)
Calls animationDesigner.service.ts to get an AnimationDesignBrief (ADB).
Calls componentGenerator.service.ts (generateComponent function) with this ADB.
2. componentGenerator.service.ts (generateComponent function)
Constructs a very detailed prompt for the LLM based on the ADB.
(Minor addition for LLM context): This prompt includes specific Remotion best practices, boilerplate, and instructions on how to translate ADB elements into TSX.
Creates a customComponentJobs record in the DB with:
status: "pending"
the detailed prompt in metadata
Asynchronously calls processComponentJob(jobId) (from generateComponentCode.ts).
Returns immediately to the chat, saying the component is being generated.
Section 3 (No changes needed, very clear)
3. generateComponentCode.ts (processComponentJob function)
Retrieves the job (including the detailed prompt from metadata).
Calls generateComponentCode(jobId, prompt).
Section 4. generateComponentCode.ts (generateComponentCode function)
First LLM call for code generation happens here.
Uses a system prompt and the detailed user prompt (constructed in componentGenerator.service.ts) to ask OpenAI (model o4-mini) to generate TSX code using a function call generate_remotion_component.
The LLM is expected to return a JSON object containing:
componentName (string)
componentCode (string - the full TSX code)
componentDescription (string)
dependencies (object - though currently not deeply utilized in the build process beyond logging)
The componentCode (TSX string) is processed (processGeneratedCode function):
Markdown fences (e.g., ```tsx) are removed.
"use client"; directive is prepended if not present.
Basic export fix (attempts to add export if missing before the component definition).
This processed TSX string is then saved back to the customComponentJobs record in the DB (in the tsxCode field), and the status is updated to "building".
(Crucial Checkpoint for LLM Agent): The quality and syntactic correctness of this job.tsxCode are paramount for the subsequent build step.
Section 5. buildCustomComponent.ts (...)
This worker periodically looks for jobs with status "pending" or is called directly with a jobId.
(Clarification): The cron worker (src/server/cron/buildWorker.ts) specifically calls processPendingJobs() which queries for status: "pending". However, the main function buildCustomComponent(jobId, ...) can be called for jobs in other states (e.g., for retries or direct triggers). The transition from "building" (set in step 4) to being picked up by buildCustomComponent needs to be robust. Ideally, after generateComponentCode.ts sets status to "building", buildCustomComponent(jobId) should be invoked directly for that job.
Key step for "build process fails":
Retrieves the tsxCode (string) from the database.
Performs sanitization (in sanitizeTsx and removeDuplicateDefaultExports):
sanitizeTsx: Removes all import statements. Removes existing const React = ... declarations.
removeDuplicateDefaultExports: Addresses LLM occasionally generating multiple default exports.
wrapTsxWithGlobals:
Prepends global constants for React and various Remotion APIs (e.g., const React = window.React || globalThis.React; const AbsoluteFill = window.Remotion?.AbsoluteFill;).
Appends code to assign the primary component (heuristically determined or ideally from a known componentName) to window.__REMOTION_COMPONENT.
(LLM Agent Note): The LLM-generated code, after sanitizeTsx strips its imports, MUST rely on these globally provided React and Remotion objects. It should not attempt its own imports of these libraries.
Compilation:
Attempts to use esbuild (compileWithEsbuild function) to compile the wrappedTsx string into a single JavaScript bundle.
Configuration: loader: 'tsx', platform: 'browser', format: 'iife' (or esm - clarify and make consistent, iife aligns well with window.__REMOTION_COMPONENT), external: ['react', 'remotion'].
This step transpiles TSX to JS, resolves JSX, and bundles.
If esbuild fails or is unavailable, it uses a compileWithFallback.
(Critical Warning): The compileWithFallback is extremely rudimentary and highly likely to produce non-functional code for any non-trivial component. Reliance on this fallback indicates a significant problem with the LLM's TSX output or the esbuild setup. The primary goal is for esbuild to succeed.
The resulting JavaScript bundle (ideally from esbuild) is uploaded to R2.
The job status is updated to "success" with the R2 URL or "error" (if esbuild failed and fallback was not attempted or also failed).
Root Cause Analysis - Revisited
1. ADB Validation Failures (Still High Priority)
(Content is good. Emphasize that fixing this is foundational for better LLM input for TSX generation).
2. Component Generation Failures (Now points to esbuild or the LLM-generated TSX)
(Content is good).
(All points are good and valid).
Syntactically Incorrect TSX from LLM: (Emphasize the need for robust sanitization or better prompting).
Type Errors: (Acknowledge that while esbuild handles TS, the LLM's TypeScript quality matters).
Import/Export Issues within the generated TSX: (Good point, wrapTsxWithGlobals handles top-level, but internal structure matters).
esbuild Configuration: (The format consistency is a small point to check).
Fallback Compiler: (Reiterate this is a danger zone).
The wrapTsxWithGlobals approach: (Good explanation. LLM adherence to using provided globals is key).
Section A. ADB Validation Failures (Still #1)
(Content is perfect - clear actions and what's needed).
Section B. Component Build Failures (Errors in buildCustomComponent.ts)
(Content is perfect - clear actions and what's needed).
(Addition for LLM Agent): When analyzing a failing job.tsxCode, pay attention to: JSX structure, React Hook rules, correct usage of Remotion APIs based on the wrapTsxWithGlobals (i.e., using interpolate not Remotion.interpolate if the wrapper sets it up as a direct const), and TypeScript syntax.
Section C. For the Preview Itself
How are React and Remotion made globally available in your preview environment?
Answered: The Remotion @remotion/player creates an environment (likely an iframe) where React and core Remotion APIs are available on the window object. useRemoteComponent also explicitly sets window.React = React and window.Remotion = Remotion before loading the custom script.
(LLM Agent Note): This global availability is critical. The generated component code, after processing by wrapTsxWithGlobals, must rely on these being present.
How does your preview load and render window.__REMOTION_COMPONENT?
Answered: Via DynamicVideo.tsx -> CustomScene.tsx -> RemoteComponent (wrapper) -> useRemoteComponent hook. This hook dynamically creates a <script src="/api/components/${componentId}"> tag. On script load, it expects window.__REMOTION_COMPONENT to be set, and then renders it.
(LLM Agent Note): The /api/components/${componentId} route and the successful execution of the script to populate window.__REMOTION_COMPONENT are vital.
Specific Code Review Points & Small Suggestions
(All existing points are good).
buildCustomComponent.ts → wrapTsxWithGlobals (Component Naming):
(Reiterate): The strategy for making the component available on window.__REMOTION_COMPONENT should be robust. If componentGenerator.service.ts instructs the LLM to use a specific export name (e.g., export const SpecificSceneName = ...), then wrapTsxWithGlobals should use that known SpecificSceneName to assign to window.__REMOTION_COMPONENT. This is more reliable than heuristics.
Understanding the Dynamic Component Loading Flow:
(All points are accurate and well-summarized).
Crucial Prop Passing:
(This entire section is CRITICAL and accurately identifies a major potential issue).
The mismatch between the LLM being told to expect { brief: AnimationDesignBrief } and CustomScene.tsx spreading scene.data (which is { componentId: string, ... }) to the loaded component will cause runtime failures.
Recommendation for Prop Passing:
(Reiterate): Option 1 (fetching the ADB in CustomScene or RemoteComponent and passing it as brief={theFetchedAdb}) is the most robust way to ensure the component gets the rich data it needs, assuming the componentId or other info in scene.data can reliably link back to the correct ADB.
(LLM Agent Task): One of the key fixes will be implementing this ADB fetching and prop passing logic.
API Route /api/components/${componentId}:
(Content is good. Emphasize that this route needs to be implemented and work correctly, likely redirecting to R2).
Summary of Key Actionable Areas:
The four key areas are interconnected. A failure in ADB Validation will make Component Build Failures more likely. Failures in Prop Passing will cause runtime issues even if the build succeeds. The API route is essential for the preview to even attempt loading.