# Type System Cleanup Strategy - Sprint 43

## Executive Summary

Our TypeScript type system has grown organically and now suffers from significant duplication, inconsistent naming, and multiple sources of truth. This document outlines a comprehensive strategy to establish a single source of truth for all types, eliminate duplications, and ensure type safety throughout the application.

## Current State Analysis

### 1. Database Entity Types

#### Auto-Generated (GOOD ✅)
- **Location**: `/src/generated/entities.ts`
- **Contents**: `SceneEntity`, `ProjectEntity`, `MessageEntity`, etc.
- **Generated by**: Drizzle ORM from database schema
- **Field names**: Match database exactly (`tsxCode`, `name`, `duration`)

#### Manual Duplicates (BAD ❌)
- **Location**: `/src/lib/types/database/`
- **Problem**: Manual `Project` interface with only 4 fields vs generated `ProjectEntity` with 8 fields
- **Risk**: Will drift out of sync when database schema changes
- **Example**:
  ```typescript
  // Manual (incomplete)
  interface Project {
    id: string;
    title: string;
    updatedAt: Date;
    userId: string;
  }
  
  // Generated (complete)
  interface ProjectEntity {
    id: string;
    title: string;
    userId: string;
    props: InputProps;
    isWelcome: boolean;
    createdAt: Date;
    updatedAt: Date | null;
    slug: string | null;
  }
  ```

### 2. Brain/AI Decision Types (MAJOR DUPLICATION)

We have **THREE** files defining overlapping brain types:

#### File 1: `/src/lib/types/api/brain-decision.ts`
- Defines `BrainDecision` interface
- Tool names as string literals: `'addScene' | 'editScene' | 'deleteScene'`
- Has its own workflow definition

#### File 2: `/src/lib/types/ai/brain.types.ts`
- Defines `ToolName` enum (better type safety)
- Contains `ToolSelectionResult`, `SceneData`, `EditComplexity`
- Has validation functions
- **Problem**: Uses wrong field names (`sceneCode` instead of `tsxCode`)

#### File 3: `/src/brain/orchestrator_functions/types.ts`
- Redefines `ToolSelectionResult` (duplicate!)
- Redefines `SceneData` with CORRECT field names
- Orchestration-specific types

**Issues**:
- `ToolSelectionResult` defined in 2 places with different shapes
- `SceneData` defined in 2 places with different field names
- No clear import hierarchy

### 3. Field Name Inconsistencies

This is causing bugs and confusion:

| Database/Generated | Wrong in Some Types | Where Used |
|-------------------|-------------------|------------|
| `tsxCode` | `code`, `sceneCode`, `existingCode` | AI types, old tools |
| `name` | `sceneName` | AI types |
| `duration` | Sometimes missing | Various |

### 4. Tool Types (GOOD ✅)

- **Location**: `/src/tools/helpers/types.ts`
- **Well-organized**: Base interfaces + specific tool extensions
- **Correct field names**: Uses `tsxCode`, `name`, `duration`
- **Includes validation**: Zod schemas for runtime validation

### 5. API Response Types

- **Location**: `/src/lib/types/api/universal.ts`
- **Good**: Imports from generated entities
- **Good**: Standardized response format
- **Issue**: Duplicates some enum types from generated file

## Single Source of Truth Strategy

### Core Principle

**"The database schema is the ultimate source of truth"**

All types should flow from the database schema → generated entities → application types.

### Type Hierarchy

```
Database Schema (Drizzle)
    ↓
Generated Entities (/src/generated/entities.ts)
    ↓
Application Types
    ├── Tool Types (/src/tools/helpers/types.ts)
    ├── AI/Brain Types (/src/lib/types/ai/brain.types.ts - consolidated)
    ├── API Types (/src/lib/types/api/universal.ts)
    └── View Types (NEW: /src/lib/types/views/)
```

### Implementation Strategy

#### 1. Database Types
```typescript
// ❌ NEVER DO THIS
interface Project {
  id: string;
  title: string;
  // Manual subset - will drift!
}

// ✅ ALWAYS DO THIS
import type { ProjectEntity } from '~/generated/entities';

// Need a subset? Use TypeScript utilities
type ProjectListItem = Pick<ProjectEntity, 'id' | 'title'>;
type ProjectWithoutDates = Omit<ProjectEntity, 'createdAt' | 'updatedAt'>;
```

#### 2. Consolidate Brain Types

**Delete these files**:
- `/src/brain/orchestrator_functions/types.ts` (move unique types to main file)
- `/src/lib/types/api/brain-decision.ts` (merge into main file)

**Keep and enhance**:
- `/src/lib/types/ai/brain.types.ts` as the single source

**Updated structure**:
```typescript
// /src/lib/types/ai/brain.types.ts

// Use enum for type safety
export enum ToolName {
  ADD_SCENE = 'addScene',
  EDIT_SCENE = 'editScene',
  DELETE_SCENE = 'deleteScene',
  TRIM_SCENE = 'trimScene',
  // ... others
}

// Single definition of brain decision
export interface BrainDecision {
  success: boolean;
  toolName?: ToolName;
  toolContext?: ToolContext;
  reasoning?: string;
  chatResponse?: string;
  needsClarification?: boolean;
  clarificationMessage?: string;
}

// Fix field names to match database
export interface SceneData {
  sceneId?: string;
  name: string;        // NOT sceneName
  tsxCode: string;     // NOT sceneCode or code
  duration: number;
  layoutJson?: any;
  reasoning?: string;
}
```

#### 3. Fix Field Names Globally

Search and replace across codebase:
- `sceneCode` → `tsxCode`
- `sceneName` → `name`
- `existingCode` → `tsxCode`
- `code` → `tsxCode` (in scene context)

#### 4. Create View Types Directory

For UI-specific types that are subsets of entities:
```typescript
// /src/lib/types/views/project.views.ts
import type { ProjectEntity, SceneEntity } from '~/generated/entities';

// List view only needs minimal fields
export type ProjectListView = Pick<ProjectEntity, 'id' | 'title' | 'updatedAt'>;

// Detail view needs more fields
export type ProjectDetailView = Omit<ProjectEntity, 'userId'>;

// Scene preview for timeline
export type ScenePreview = Pick<SceneEntity, 'id' | 'name' | 'duration' | 'order'>;
```

## Migration Plan

### Phase 1: Consolidate Brain Types (1 day)
1. Create comprehensive `/src/lib/types/ai/brain.types.ts`
2. Migrate all unique types from other files
3. Fix field names to match database
4. Update all imports

### Phase 2: Delete Manual Database Types (1 day)
1. Find all uses of manual database types
2. Replace with generated entities + TypeScript utilities
3. Delete `/src/lib/types/database/` directory
4. Update imports

### Phase 3: Fix Field Names (2 days)
1. Global search/replace for wrong field names
2. Test each changed file
3. Update any string-based field references

### Phase 4: Create View Types (1 day)
1. Create `/src/lib/types/views/` directory
2. Define UI-specific type subsets
3. Update components to use view types

### Phase 5: Documentation (1 day)
1. Document type import conventions
2. Add ESLint rules to prevent wrong imports
3. Update developer guide

## Benefits

1. **Single Source of Truth**: Database schema drives all types
2. **No Drift**: Generated types always match database
3. **Type Safety**: Stronger typing with enums and proper names
4. **Maintainability**: Clear import paths and organization
5. **Performance**: No runtime type conversions needed
6. **Developer Experience**: Consistent field names everywhere

## Import Convention

```typescript
// For database entities
import type { SceneEntity, ProjectEntity } from '~/generated/entities';

// For AI/brain operations
import type { ToolName, BrainDecision, SceneData } from '~/lib/types/ai/brain.types';

// For tool operations
import type { AddToolInput, EditToolOutput } from '~/tools/helpers/types';

// For API responses
import type { UniversalResponse } from '~/lib/types/api/universal';

// For UI components
import type { ProjectListView, ScenePreview } from '~/lib/types/views';
```

## Validation Checklist

- [ ] No manual database type definitions
- [ ] Single location for brain/AI types
- [ ] All field names match database schema
- [ ] TypeScript utilities used for subsets
- [ ] Clear import hierarchy established
- [ ] No duplicate type definitions
- [ ] View types separated from entity types

## Long-term Maintenance

1. **Never create manual database types** - Always use generated
2. **Run type generation** after schema changes: `npm run db:generate-types`
3. **Use TypeScript utilities** for variants: `Pick`, `Omit`, `Partial`
4. **Keep field names consistent** with database
5. **Document type decisions** in code comments

This strategy will significantly reduce our type complexity while improving type safety and developer experience.