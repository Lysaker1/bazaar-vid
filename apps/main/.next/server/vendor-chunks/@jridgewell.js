"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@jridgewell";
exports.ids = ["vendor-chunks/@jridgewell"];
exports.modules = {

/***/ "(ssr)/../../node_modules/@jridgewell/gen-mapping/dist/gen-mapping.mjs":
/*!***********************************************************************!*\
  !*** ../../node_modules/@jridgewell/gen-mapping/dist/gen-mapping.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GenMapping: () => (/* binding */ GenMapping),\n/* harmony export */   addMapping: () => (/* binding */ addMapping),\n/* harmony export */   addSegment: () => (/* binding */ addSegment),\n/* harmony export */   allMappings: () => (/* binding */ allMappings),\n/* harmony export */   fromMap: () => (/* binding */ fromMap),\n/* harmony export */   maybeAddMapping: () => (/* binding */ maybeAddMapping),\n/* harmony export */   maybeAddSegment: () => (/* binding */ maybeAddSegment),\n/* harmony export */   setIgnore: () => (/* binding */ setIgnore),\n/* harmony export */   setSourceContent: () => (/* binding */ setSourceContent),\n/* harmony export */   toDecodedMap: () => (/* binding */ toDecodedMap),\n/* harmony export */   toEncodedMap: () => (/* binding */ toEncodedMap)\n/* harmony export */ });\n/* harmony import */ var _jridgewell_set_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jridgewell/set-array */ \"(ssr)/../../node_modules/@jridgewell/set-array/dist/set-array.mjs\");\n/* harmony import */ var _jridgewell_sourcemap_codec__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jridgewell/sourcemap-codec */ \"(ssr)/../../node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs\");\n/* harmony import */ var _jridgewell_trace_mapping__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @jridgewell/trace-mapping */ \"(ssr)/../../node_modules/@jridgewell/trace-mapping/dist/trace-mapping.mjs\");\n\n\n\n\nconst COLUMN = 0;\nconst SOURCES_INDEX = 1;\nconst SOURCE_LINE = 2;\nconst SOURCE_COLUMN = 3;\nconst NAMES_INDEX = 4;\n\nconst NO_NAME = -1;\n/**\n * Provides the state to generate a sourcemap.\n */\nclass GenMapping {\n    constructor({ file, sourceRoot } = {}) {\n        this._names = new _jridgewell_set_array__WEBPACK_IMPORTED_MODULE_0__.SetArray();\n        this._sources = new _jridgewell_set_array__WEBPACK_IMPORTED_MODULE_0__.SetArray();\n        this._sourcesContent = [];\n        this._mappings = [];\n        this.file = file;\n        this.sourceRoot = sourceRoot;\n        this._ignoreList = new _jridgewell_set_array__WEBPACK_IMPORTED_MODULE_0__.SetArray();\n    }\n}\n/**\n * Typescript doesn't allow friend access to private fields, so this just casts the map into a type\n * with public access modifiers.\n */\nfunction cast(map) {\n    return map;\n}\nfunction addSegment(map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {\n    return addSegmentInternal(false, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);\n}\nfunction addMapping(map, mapping) {\n    return addMappingInternal(false, map, mapping);\n}\n/**\n * Same as `addSegment`, but will only add the segment if it generates useful information in the\n * resulting map. This only works correctly if segments are added **in order**, meaning you should\n * not add a segment with a lower generated line/column than one that came before.\n */\nconst maybeAddSegment = (map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) => {\n    return addSegmentInternal(true, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content);\n};\n/**\n * Same as `addMapping`, but will only add the mapping if it generates useful information in the\n * resulting map. This only works correctly if mappings are added **in order**, meaning you should\n * not add a mapping with a lower generated line/column than one that came before.\n */\nconst maybeAddMapping = (map, mapping) => {\n    return addMappingInternal(true, map, mapping);\n};\n/**\n * Adds/removes the content of the source file to the source map.\n */\nfunction setSourceContent(map, source, content) {\n    const { _sources: sources, _sourcesContent: sourcesContent } = cast(map);\n    const index = (0,_jridgewell_set_array__WEBPACK_IMPORTED_MODULE_0__.put)(sources, source);\n    sourcesContent[index] = content;\n}\nfunction setIgnore(map, source, ignore = true) {\n    const { _sources: sources, _sourcesContent: sourcesContent, _ignoreList: ignoreList } = cast(map);\n    const index = (0,_jridgewell_set_array__WEBPACK_IMPORTED_MODULE_0__.put)(sources, source);\n    if (index === sourcesContent.length)\n        sourcesContent[index] = null;\n    if (ignore)\n        (0,_jridgewell_set_array__WEBPACK_IMPORTED_MODULE_0__.put)(ignoreList, index);\n    else\n        (0,_jridgewell_set_array__WEBPACK_IMPORTED_MODULE_0__.remove)(ignoreList, index);\n}\n/**\n * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nfunction toDecodedMap(map) {\n    const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names, _ignoreList: ignoreList, } = cast(map);\n    removeEmptyFinalLines(mappings);\n    return {\n        version: 3,\n        file: map.file || undefined,\n        names: names.array,\n        sourceRoot: map.sourceRoot || undefined,\n        sources: sources.array,\n        sourcesContent,\n        mappings,\n        ignoreList: ignoreList.array,\n    };\n}\n/**\n * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nfunction toEncodedMap(map) {\n    const decoded = toDecodedMap(map);\n    return Object.assign(Object.assign({}, decoded), { mappings: (0,_jridgewell_sourcemap_codec__WEBPACK_IMPORTED_MODULE_1__.encode)(decoded.mappings) });\n}\n/**\n * Constructs a new GenMapping, using the already present mappings of the input.\n */\nfunction fromMap(input) {\n    const map = new _jridgewell_trace_mapping__WEBPACK_IMPORTED_MODULE_2__.TraceMap(input);\n    const gen = new GenMapping({ file: map.file, sourceRoot: map.sourceRoot });\n    putAll(cast(gen)._names, map.names);\n    putAll(cast(gen)._sources, map.sources);\n    cast(gen)._sourcesContent = map.sourcesContent || map.sources.map(() => null);\n    cast(gen)._mappings = (0,_jridgewell_trace_mapping__WEBPACK_IMPORTED_MODULE_2__.decodedMappings)(map);\n    if (map.ignoreList)\n        putAll(cast(gen)._ignoreList, map.ignoreList);\n    return gen;\n}\n/**\n * Returns an array of high-level mapping objects for every recorded segment, which could then be\n * passed to the `source-map` library.\n */\nfunction allMappings(map) {\n    const out = [];\n    const { _mappings: mappings, _sources: sources, _names: names } = cast(map);\n    for (let i = 0; i < mappings.length; i++) {\n        const line = mappings[i];\n        for (let j = 0; j < line.length; j++) {\n            const seg = line[j];\n            const generated = { line: i + 1, column: seg[COLUMN] };\n            let source = undefined;\n            let original = undefined;\n            let name = undefined;\n            if (seg.length !== 1) {\n                source = sources.array[seg[SOURCES_INDEX]];\n                original = { line: seg[SOURCE_LINE] + 1, column: seg[SOURCE_COLUMN] };\n                if (seg.length === 5)\n                    name = names.array[seg[NAMES_INDEX]];\n            }\n            out.push({ generated, source, original, name });\n        }\n    }\n    return out;\n}\n// This split declaration is only so that terser can elminiate the static initialization block.\nfunction addSegmentInternal(skipable, map, genLine, genColumn, source, sourceLine, sourceColumn, name, content) {\n    const { _mappings: mappings, _sources: sources, _sourcesContent: sourcesContent, _names: names, } = cast(map);\n    const line = getLine(mappings, genLine);\n    const index = getColumnIndex(line, genColumn);\n    if (!source) {\n        if (skipable && skipSourceless(line, index))\n            return;\n        return insert(line, index, [genColumn]);\n    }\n    const sourcesIndex = (0,_jridgewell_set_array__WEBPACK_IMPORTED_MODULE_0__.put)(sources, source);\n    const namesIndex = name ? (0,_jridgewell_set_array__WEBPACK_IMPORTED_MODULE_0__.put)(names, name) : NO_NAME;\n    if (sourcesIndex === sourcesContent.length)\n        sourcesContent[sourcesIndex] = content !== null && content !== void 0 ? content : null;\n    if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {\n        return;\n    }\n    return insert(line, index, name\n        ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex]\n        : [genColumn, sourcesIndex, sourceLine, sourceColumn]);\n}\nfunction getLine(mappings, index) {\n    for (let i = mappings.length; i <= index; i++) {\n        mappings[i] = [];\n    }\n    return mappings[index];\n}\nfunction getColumnIndex(line, genColumn) {\n    let index = line.length;\n    for (let i = index - 1; i >= 0; index = i--) {\n        const current = line[i];\n        if (genColumn >= current[COLUMN])\n            break;\n    }\n    return index;\n}\nfunction insert(array, index, value) {\n    for (let i = array.length; i > index; i--) {\n        array[i] = array[i - 1];\n    }\n    array[index] = value;\n}\nfunction removeEmptyFinalLines(mappings) {\n    const { length } = mappings;\n    let len = length;\n    for (let i = len - 1; i >= 0; len = i, i--) {\n        if (mappings[i].length > 0)\n            break;\n    }\n    if (len < length)\n        mappings.length = len;\n}\nfunction putAll(setarr, array) {\n    for (let i = 0; i < array.length; i++)\n        (0,_jridgewell_set_array__WEBPACK_IMPORTED_MODULE_0__.put)(setarr, array[i]);\n}\nfunction skipSourceless(line, index) {\n    // The start of a line is already sourceless, so adding a sourceless segment to the beginning\n    // doesn't generate any useful information.\n    if (index === 0)\n        return true;\n    const prev = line[index - 1];\n    // If the previous segment is also sourceless, then adding another sourceless segment doesn't\n    // genrate any new information. Else, this segment will end the source/named segment and point to\n    // a sourceless position, which is useful.\n    return prev.length === 1;\n}\nfunction skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex) {\n    // A source/named segment at the start of a line gives position at that genColumn\n    if (index === 0)\n        return false;\n    const prev = line[index - 1];\n    // If the previous segment is sourceless, then we're transitioning to a source.\n    if (prev.length === 1)\n        return false;\n    // If the previous segment maps to the exact same source position, then this segment doesn't\n    // provide any new position information.\n    return (sourcesIndex === prev[SOURCES_INDEX] &&\n        sourceLine === prev[SOURCE_LINE] &&\n        sourceColumn === prev[SOURCE_COLUMN] &&\n        namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME));\n}\nfunction addMappingInternal(skipable, map, mapping) {\n    const { generated, source, original, name, content } = mapping;\n    if (!source) {\n        return addSegmentInternal(skipable, map, generated.line - 1, generated.column, null, null, null, null, null);\n    }\n    return addSegmentInternal(skipable, map, generated.line - 1, generated.column, source, original.line - 1, original.column, name, content);\n}\n\n\n//# sourceMappingURL=gen-mapping.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BqcmlkZ2V3ZWxsL2dlbi1tYXBwaW5nL2Rpc3QvZ2VuLW1hcHBpbmcubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQThEO0FBQ1Q7QUFDaUI7O0FBRXRFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUIsSUFBSTtBQUN6QywwQkFBMEIsMkRBQVE7QUFDbEMsNEJBQTRCLDJEQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDJEQUFRO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFEQUFxRDtBQUNqRSxrQkFBa0IsMERBQUc7QUFDckI7QUFDQTtBQUNBO0FBQ0EsWUFBWSw4RUFBOEU7QUFDMUYsa0JBQWtCLDBEQUFHO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMERBQUc7QUFDWDtBQUNBLFFBQVEsNkRBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1IQUFtSDtBQUMvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsY0FBYyxVQUFVLG1FQUFNLG9CQUFvQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLCtEQUFRO0FBQzVCLGlDQUFpQyw0Q0FBNEM7QUFDN0U7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDBFQUFlO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3REFBd0Q7QUFDcEUsb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUNBQW1DO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMEZBQTBGO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDBEQUFHO0FBQzVCLDhCQUE4QiwwREFBRztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxZQUFZO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFdBQVc7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBLDBCQUEwQixRQUFRO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QyxRQUFRLDBEQUFHO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZDQUE2QztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUrSjtBQUMvSiIsInNvdXJjZXMiOlsiL1VzZXJzL21hcmt1c2hvZ25lL0RvY3VtZW50cy9BUFBTL2JhemFhci12aWQvYmF6YWFyLXZpZC9ub2RlX21vZHVsZXMvQGpyaWRnZXdlbGwvZ2VuLW1hcHBpbmcvZGlzdC9nZW4tbWFwcGluZy5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU2V0QXJyYXksIHB1dCwgcmVtb3ZlIH0gZnJvbSAnQGpyaWRnZXdlbGwvc2V0LWFycmF5JztcbmltcG9ydCB7IGVuY29kZSB9IGZyb20gJ0BqcmlkZ2V3ZWxsL3NvdXJjZW1hcC1jb2RlYyc7XG5pbXBvcnQgeyBUcmFjZU1hcCwgZGVjb2RlZE1hcHBpbmdzIH0gZnJvbSAnQGpyaWRnZXdlbGwvdHJhY2UtbWFwcGluZyc7XG5cbmNvbnN0IENPTFVNTiA9IDA7XG5jb25zdCBTT1VSQ0VTX0lOREVYID0gMTtcbmNvbnN0IFNPVVJDRV9MSU5FID0gMjtcbmNvbnN0IFNPVVJDRV9DT0xVTU4gPSAzO1xuY29uc3QgTkFNRVNfSU5ERVggPSA0O1xuXG5jb25zdCBOT19OQU1FID0gLTE7XG4vKipcbiAqIFByb3ZpZGVzIHRoZSBzdGF0ZSB0byBnZW5lcmF0ZSBhIHNvdXJjZW1hcC5cbiAqL1xuY2xhc3MgR2VuTWFwcGluZyB7XG4gICAgY29uc3RydWN0b3IoeyBmaWxlLCBzb3VyY2VSb290IH0gPSB7fSkge1xuICAgICAgICB0aGlzLl9uYW1lcyA9IG5ldyBTZXRBcnJheSgpO1xuICAgICAgICB0aGlzLl9zb3VyY2VzID0gbmV3IFNldEFycmF5KCk7XG4gICAgICAgIHRoaXMuX3NvdXJjZXNDb250ZW50ID0gW107XG4gICAgICAgIHRoaXMuX21hcHBpbmdzID0gW107XG4gICAgICAgIHRoaXMuZmlsZSA9IGZpbGU7XG4gICAgICAgIHRoaXMuc291cmNlUm9vdCA9IHNvdXJjZVJvb3Q7XG4gICAgICAgIHRoaXMuX2lnbm9yZUxpc3QgPSBuZXcgU2V0QXJyYXkoKTtcbiAgICB9XG59XG4vKipcbiAqIFR5cGVzY3JpcHQgZG9lc24ndCBhbGxvdyBmcmllbmQgYWNjZXNzIHRvIHByaXZhdGUgZmllbGRzLCBzbyB0aGlzIGp1c3QgY2FzdHMgdGhlIG1hcCBpbnRvIGEgdHlwZVxuICogd2l0aCBwdWJsaWMgYWNjZXNzIG1vZGlmaWVycy5cbiAqL1xuZnVuY3Rpb24gY2FzdChtYXApIHtcbiAgICByZXR1cm4gbWFwO1xufVxuZnVuY3Rpb24gYWRkU2VnbWVudChtYXAsIGdlbkxpbmUsIGdlbkNvbHVtbiwgc291cmNlLCBzb3VyY2VMaW5lLCBzb3VyY2VDb2x1bW4sIG5hbWUsIGNvbnRlbnQpIHtcbiAgICByZXR1cm4gYWRkU2VnbWVudEludGVybmFsKGZhbHNlLCBtYXAsIGdlbkxpbmUsIGdlbkNvbHVtbiwgc291cmNlLCBzb3VyY2VMaW5lLCBzb3VyY2VDb2x1bW4sIG5hbWUsIGNvbnRlbnQpO1xufVxuZnVuY3Rpb24gYWRkTWFwcGluZyhtYXAsIG1hcHBpbmcpIHtcbiAgICByZXR1cm4gYWRkTWFwcGluZ0ludGVybmFsKGZhbHNlLCBtYXAsIG1hcHBpbmcpO1xufVxuLyoqXG4gKiBTYW1lIGFzIGBhZGRTZWdtZW50YCwgYnV0IHdpbGwgb25seSBhZGQgdGhlIHNlZ21lbnQgaWYgaXQgZ2VuZXJhdGVzIHVzZWZ1bCBpbmZvcm1hdGlvbiBpbiB0aGVcbiAqIHJlc3VsdGluZyBtYXAuIFRoaXMgb25seSB3b3JrcyBjb3JyZWN0bHkgaWYgc2VnbWVudHMgYXJlIGFkZGVkICoqaW4gb3JkZXIqKiwgbWVhbmluZyB5b3Ugc2hvdWxkXG4gKiBub3QgYWRkIGEgc2VnbWVudCB3aXRoIGEgbG93ZXIgZ2VuZXJhdGVkIGxpbmUvY29sdW1uIHRoYW4gb25lIHRoYXQgY2FtZSBiZWZvcmUuXG4gKi9cbmNvbnN0IG1heWJlQWRkU2VnbWVudCA9IChtYXAsIGdlbkxpbmUsIGdlbkNvbHVtbiwgc291cmNlLCBzb3VyY2VMaW5lLCBzb3VyY2VDb2x1bW4sIG5hbWUsIGNvbnRlbnQpID0+IHtcbiAgICByZXR1cm4gYWRkU2VnbWVudEludGVybmFsKHRydWUsIG1hcCwgZ2VuTGluZSwgZ2VuQ29sdW1uLCBzb3VyY2UsIHNvdXJjZUxpbmUsIHNvdXJjZUNvbHVtbiwgbmFtZSwgY29udGVudCk7XG59O1xuLyoqXG4gKiBTYW1lIGFzIGBhZGRNYXBwaW5nYCwgYnV0IHdpbGwgb25seSBhZGQgdGhlIG1hcHBpbmcgaWYgaXQgZ2VuZXJhdGVzIHVzZWZ1bCBpbmZvcm1hdGlvbiBpbiB0aGVcbiAqIHJlc3VsdGluZyBtYXAuIFRoaXMgb25seSB3b3JrcyBjb3JyZWN0bHkgaWYgbWFwcGluZ3MgYXJlIGFkZGVkICoqaW4gb3JkZXIqKiwgbWVhbmluZyB5b3Ugc2hvdWxkXG4gKiBub3QgYWRkIGEgbWFwcGluZyB3aXRoIGEgbG93ZXIgZ2VuZXJhdGVkIGxpbmUvY29sdW1uIHRoYW4gb25lIHRoYXQgY2FtZSBiZWZvcmUuXG4gKi9cbmNvbnN0IG1heWJlQWRkTWFwcGluZyA9IChtYXAsIG1hcHBpbmcpID0+IHtcbiAgICByZXR1cm4gYWRkTWFwcGluZ0ludGVybmFsKHRydWUsIG1hcCwgbWFwcGluZyk7XG59O1xuLyoqXG4gKiBBZGRzL3JlbW92ZXMgdGhlIGNvbnRlbnQgb2YgdGhlIHNvdXJjZSBmaWxlIHRvIHRoZSBzb3VyY2UgbWFwLlxuICovXG5mdW5jdGlvbiBzZXRTb3VyY2VDb250ZW50KG1hcCwgc291cmNlLCBjb250ZW50KSB7XG4gICAgY29uc3QgeyBfc291cmNlczogc291cmNlcywgX3NvdXJjZXNDb250ZW50OiBzb3VyY2VzQ29udGVudCB9ID0gY2FzdChtYXApO1xuICAgIGNvbnN0IGluZGV4ID0gcHV0KHNvdXJjZXMsIHNvdXJjZSk7XG4gICAgc291cmNlc0NvbnRlbnRbaW5kZXhdID0gY29udGVudDtcbn1cbmZ1bmN0aW9uIHNldElnbm9yZShtYXAsIHNvdXJjZSwgaWdub3JlID0gdHJ1ZSkge1xuICAgIGNvbnN0IHsgX3NvdXJjZXM6IHNvdXJjZXMsIF9zb3VyY2VzQ29udGVudDogc291cmNlc0NvbnRlbnQsIF9pZ25vcmVMaXN0OiBpZ25vcmVMaXN0IH0gPSBjYXN0KG1hcCk7XG4gICAgY29uc3QgaW5kZXggPSBwdXQoc291cmNlcywgc291cmNlKTtcbiAgICBpZiAoaW5kZXggPT09IHNvdXJjZXNDb250ZW50Lmxlbmd0aClcbiAgICAgICAgc291cmNlc0NvbnRlbnRbaW5kZXhdID0gbnVsbDtcbiAgICBpZiAoaWdub3JlKVxuICAgICAgICBwdXQoaWdub3JlTGlzdCwgaW5kZXgpO1xuICAgIGVsc2VcbiAgICAgICAgcmVtb3ZlKGlnbm9yZUxpc3QsIGluZGV4KTtcbn1cbi8qKlxuICogUmV0dXJucyBhIHNvdXJjZW1hcCBvYmplY3QgKHdpdGggZGVjb2RlZCBtYXBwaW5ncykgc3VpdGFibGUgZm9yIHBhc3NpbmcgdG8gYSBsaWJyYXJ5IHRoYXQgZXhwZWN0c1xuICogYSBzb3VyY2VtYXAsIG9yIHRvIEpTT04uc3RyaW5naWZ5LlxuICovXG5mdW5jdGlvbiB0b0RlY29kZWRNYXAobWFwKSB7XG4gICAgY29uc3QgeyBfbWFwcGluZ3M6IG1hcHBpbmdzLCBfc291cmNlczogc291cmNlcywgX3NvdXJjZXNDb250ZW50OiBzb3VyY2VzQ29udGVudCwgX25hbWVzOiBuYW1lcywgX2lnbm9yZUxpc3Q6IGlnbm9yZUxpc3QsIH0gPSBjYXN0KG1hcCk7XG4gICAgcmVtb3ZlRW1wdHlGaW5hbExpbmVzKG1hcHBpbmdzKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB2ZXJzaW9uOiAzLFxuICAgICAgICBmaWxlOiBtYXAuZmlsZSB8fCB1bmRlZmluZWQsXG4gICAgICAgIG5hbWVzOiBuYW1lcy5hcnJheSxcbiAgICAgICAgc291cmNlUm9vdDogbWFwLnNvdXJjZVJvb3QgfHwgdW5kZWZpbmVkLFxuICAgICAgICBzb3VyY2VzOiBzb3VyY2VzLmFycmF5LFxuICAgICAgICBzb3VyY2VzQ29udGVudCxcbiAgICAgICAgbWFwcGluZ3MsXG4gICAgICAgIGlnbm9yZUxpc3Q6IGlnbm9yZUxpc3QuYXJyYXksXG4gICAgfTtcbn1cbi8qKlxuICogUmV0dXJucyBhIHNvdXJjZW1hcCBvYmplY3QgKHdpdGggZW5jb2RlZCBtYXBwaW5ncykgc3VpdGFibGUgZm9yIHBhc3NpbmcgdG8gYSBsaWJyYXJ5IHRoYXQgZXhwZWN0c1xuICogYSBzb3VyY2VtYXAsIG9yIHRvIEpTT04uc3RyaW5naWZ5LlxuICovXG5mdW5jdGlvbiB0b0VuY29kZWRNYXAobWFwKSB7XG4gICAgY29uc3QgZGVjb2RlZCA9IHRvRGVjb2RlZE1hcChtYXApO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlY29kZWQpLCB7IG1hcHBpbmdzOiBlbmNvZGUoZGVjb2RlZC5tYXBwaW5ncykgfSk7XG59XG4vKipcbiAqIENvbnN0cnVjdHMgYSBuZXcgR2VuTWFwcGluZywgdXNpbmcgdGhlIGFscmVhZHkgcHJlc2VudCBtYXBwaW5ncyBvZiB0aGUgaW5wdXQuXG4gKi9cbmZ1bmN0aW9uIGZyb21NYXAoaW5wdXQpIHtcbiAgICBjb25zdCBtYXAgPSBuZXcgVHJhY2VNYXAoaW5wdXQpO1xuICAgIGNvbnN0IGdlbiA9IG5ldyBHZW5NYXBwaW5nKHsgZmlsZTogbWFwLmZpbGUsIHNvdXJjZVJvb3Q6IG1hcC5zb3VyY2VSb290IH0pO1xuICAgIHB1dEFsbChjYXN0KGdlbikuX25hbWVzLCBtYXAubmFtZXMpO1xuICAgIHB1dEFsbChjYXN0KGdlbikuX3NvdXJjZXMsIG1hcC5zb3VyY2VzKTtcbiAgICBjYXN0KGdlbikuX3NvdXJjZXNDb250ZW50ID0gbWFwLnNvdXJjZXNDb250ZW50IHx8IG1hcC5zb3VyY2VzLm1hcCgoKSA9PiBudWxsKTtcbiAgICBjYXN0KGdlbikuX21hcHBpbmdzID0gZGVjb2RlZE1hcHBpbmdzKG1hcCk7XG4gICAgaWYgKG1hcC5pZ25vcmVMaXN0KVxuICAgICAgICBwdXRBbGwoY2FzdChnZW4pLl9pZ25vcmVMaXN0LCBtYXAuaWdub3JlTGlzdCk7XG4gICAgcmV0dXJuIGdlbjtcbn1cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiBoaWdoLWxldmVsIG1hcHBpbmcgb2JqZWN0cyBmb3IgZXZlcnkgcmVjb3JkZWQgc2VnbWVudCwgd2hpY2ggY291bGQgdGhlbiBiZVxuICogcGFzc2VkIHRvIHRoZSBgc291cmNlLW1hcGAgbGlicmFyeS5cbiAqL1xuZnVuY3Rpb24gYWxsTWFwcGluZ3MobWFwKSB7XG4gICAgY29uc3Qgb3V0ID0gW107XG4gICAgY29uc3QgeyBfbWFwcGluZ3M6IG1hcHBpbmdzLCBfc291cmNlczogc291cmNlcywgX25hbWVzOiBuYW1lcyB9ID0gY2FzdChtYXApO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFwcGluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbGluZSA9IG1hcHBpbmdzW2ldO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxpbmUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNlZyA9IGxpbmVbal07XG4gICAgICAgICAgICBjb25zdCBnZW5lcmF0ZWQgPSB7IGxpbmU6IGkgKyAxLCBjb2x1bW46IHNlZ1tDT0xVTU5dIH07XG4gICAgICAgICAgICBsZXQgc291cmNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgbGV0IG9yaWdpbmFsID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgbGV0IG5hbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoc2VnLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgICAgIHNvdXJjZSA9IHNvdXJjZXMuYXJyYXlbc2VnW1NPVVJDRVNfSU5ERVhdXTtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbCA9IHsgbGluZTogc2VnW1NPVVJDRV9MSU5FXSArIDEsIGNvbHVtbjogc2VnW1NPVVJDRV9DT0xVTU5dIH07XG4gICAgICAgICAgICAgICAgaWYgKHNlZy5sZW5ndGggPT09IDUpXG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lcy5hcnJheVtzZWdbTkFNRVNfSU5ERVhdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG91dC5wdXNoKHsgZ2VuZXJhdGVkLCBzb3VyY2UsIG9yaWdpbmFsLCBuYW1lIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG59XG4vLyBUaGlzIHNwbGl0IGRlY2xhcmF0aW9uIGlzIG9ubHkgc28gdGhhdCB0ZXJzZXIgY2FuIGVsbWluaWF0ZSB0aGUgc3RhdGljIGluaXRpYWxpemF0aW9uIGJsb2NrLlxuZnVuY3Rpb24gYWRkU2VnbWVudEludGVybmFsKHNraXBhYmxlLCBtYXAsIGdlbkxpbmUsIGdlbkNvbHVtbiwgc291cmNlLCBzb3VyY2VMaW5lLCBzb3VyY2VDb2x1bW4sIG5hbWUsIGNvbnRlbnQpIHtcbiAgICBjb25zdCB7IF9tYXBwaW5nczogbWFwcGluZ3MsIF9zb3VyY2VzOiBzb3VyY2VzLCBfc291cmNlc0NvbnRlbnQ6IHNvdXJjZXNDb250ZW50LCBfbmFtZXM6IG5hbWVzLCB9ID0gY2FzdChtYXApO1xuICAgIGNvbnN0IGxpbmUgPSBnZXRMaW5lKG1hcHBpbmdzLCBnZW5MaW5lKTtcbiAgICBjb25zdCBpbmRleCA9IGdldENvbHVtbkluZGV4KGxpbmUsIGdlbkNvbHVtbik7XG4gICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgaWYgKHNraXBhYmxlICYmIHNraXBTb3VyY2VsZXNzKGxpbmUsIGluZGV4KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmV0dXJuIGluc2VydChsaW5lLCBpbmRleCwgW2dlbkNvbHVtbl0pO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2VzSW5kZXggPSBwdXQoc291cmNlcywgc291cmNlKTtcbiAgICBjb25zdCBuYW1lc0luZGV4ID0gbmFtZSA/IHB1dChuYW1lcywgbmFtZSkgOiBOT19OQU1FO1xuICAgIGlmIChzb3VyY2VzSW5kZXggPT09IHNvdXJjZXNDb250ZW50Lmxlbmd0aClcbiAgICAgICAgc291cmNlc0NvbnRlbnRbc291cmNlc0luZGV4XSA9IGNvbnRlbnQgIT09IG51bGwgJiYgY29udGVudCAhPT0gdm9pZCAwID8gY29udGVudCA6IG51bGw7XG4gICAgaWYgKHNraXBhYmxlICYmIHNraXBTb3VyY2UobGluZSwgaW5kZXgsIHNvdXJjZXNJbmRleCwgc291cmNlTGluZSwgc291cmNlQ29sdW1uLCBuYW1lc0luZGV4KSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBpbnNlcnQobGluZSwgaW5kZXgsIG5hbWVcbiAgICAgICAgPyBbZ2VuQ29sdW1uLCBzb3VyY2VzSW5kZXgsIHNvdXJjZUxpbmUsIHNvdXJjZUNvbHVtbiwgbmFtZXNJbmRleF1cbiAgICAgICAgOiBbZ2VuQ29sdW1uLCBzb3VyY2VzSW5kZXgsIHNvdXJjZUxpbmUsIHNvdXJjZUNvbHVtbl0pO1xufVxuZnVuY3Rpb24gZ2V0TGluZShtYXBwaW5ncywgaW5kZXgpIHtcbiAgICBmb3IgKGxldCBpID0gbWFwcGluZ3MubGVuZ3RoOyBpIDw9IGluZGV4OyBpKyspIHtcbiAgICAgICAgbWFwcGluZ3NbaV0gPSBbXTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcHBpbmdzW2luZGV4XTtcbn1cbmZ1bmN0aW9uIGdldENvbHVtbkluZGV4KGxpbmUsIGdlbkNvbHVtbikge1xuICAgIGxldCBpbmRleCA9IGxpbmUubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSBpbmRleCAtIDE7IGkgPj0gMDsgaW5kZXggPSBpLS0pIHtcbiAgICAgICAgY29uc3QgY3VycmVudCA9IGxpbmVbaV07XG4gICAgICAgIGlmIChnZW5Db2x1bW4gPj0gY3VycmVudFtDT0xVTU5dKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIGluc2VydChhcnJheSwgaW5kZXgsIHZhbHVlKSB7XG4gICAgZm9yIChsZXQgaSA9IGFycmF5Lmxlbmd0aDsgaSA+IGluZGV4OyBpLS0pIHtcbiAgICAgICAgYXJyYXlbaV0gPSBhcnJheVtpIC0gMV07XG4gICAgfVxuICAgIGFycmF5W2luZGV4XSA9IHZhbHVlO1xufVxuZnVuY3Rpb24gcmVtb3ZlRW1wdHlGaW5hbExpbmVzKG1hcHBpbmdzKSB7XG4gICAgY29uc3QgeyBsZW5ndGggfSA9IG1hcHBpbmdzO1xuICAgIGxldCBsZW4gPSBsZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IGxlbiAtIDE7IGkgPj0gMDsgbGVuID0gaSwgaS0tKSB7XG4gICAgICAgIGlmIChtYXBwaW5nc1tpXS5sZW5ndGggPiAwKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChsZW4gPCBsZW5ndGgpXG4gICAgICAgIG1hcHBpbmdzLmxlbmd0aCA9IGxlbjtcbn1cbmZ1bmN0aW9uIHB1dEFsbChzZXRhcnIsIGFycmF5KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKylcbiAgICAgICAgcHV0KHNldGFyciwgYXJyYXlbaV0pO1xufVxuZnVuY3Rpb24gc2tpcFNvdXJjZWxlc3MobGluZSwgaW5kZXgpIHtcbiAgICAvLyBUaGUgc3RhcnQgb2YgYSBsaW5lIGlzIGFscmVhZHkgc291cmNlbGVzcywgc28gYWRkaW5nIGEgc291cmNlbGVzcyBzZWdtZW50IHRvIHRoZSBiZWdpbm5pbmdcbiAgICAvLyBkb2Vzbid0IGdlbmVyYXRlIGFueSB1c2VmdWwgaW5mb3JtYXRpb24uXG4gICAgaWYgKGluZGV4ID09PSAwKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjb25zdCBwcmV2ID0gbGluZVtpbmRleCAtIDFdO1xuICAgIC8vIElmIHRoZSBwcmV2aW91cyBzZWdtZW50IGlzIGFsc28gc291cmNlbGVzcywgdGhlbiBhZGRpbmcgYW5vdGhlciBzb3VyY2VsZXNzIHNlZ21lbnQgZG9lc24ndFxuICAgIC8vIGdlbnJhdGUgYW55IG5ldyBpbmZvcm1hdGlvbi4gRWxzZSwgdGhpcyBzZWdtZW50IHdpbGwgZW5kIHRoZSBzb3VyY2UvbmFtZWQgc2VnbWVudCBhbmQgcG9pbnQgdG9cbiAgICAvLyBhIHNvdXJjZWxlc3MgcG9zaXRpb24sIHdoaWNoIGlzIHVzZWZ1bC5cbiAgICByZXR1cm4gcHJldi5sZW5ndGggPT09IDE7XG59XG5mdW5jdGlvbiBza2lwU291cmNlKGxpbmUsIGluZGV4LCBzb3VyY2VzSW5kZXgsIHNvdXJjZUxpbmUsIHNvdXJjZUNvbHVtbiwgbmFtZXNJbmRleCkge1xuICAgIC8vIEEgc291cmNlL25hbWVkIHNlZ21lbnQgYXQgdGhlIHN0YXJ0IG9mIGEgbGluZSBnaXZlcyBwb3NpdGlvbiBhdCB0aGF0IGdlbkNvbHVtblxuICAgIGlmIChpbmRleCA9PT0gMClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHByZXYgPSBsaW5lW2luZGV4IC0gMV07XG4gICAgLy8gSWYgdGhlIHByZXZpb3VzIHNlZ21lbnQgaXMgc291cmNlbGVzcywgdGhlbiB3ZSdyZSB0cmFuc2l0aW9uaW5nIHRvIGEgc291cmNlLlxuICAgIGlmIChwcmV2Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIElmIHRoZSBwcmV2aW91cyBzZWdtZW50IG1hcHMgdG8gdGhlIGV4YWN0IHNhbWUgc291cmNlIHBvc2l0aW9uLCB0aGVuIHRoaXMgc2VnbWVudCBkb2Vzbid0XG4gICAgLy8gcHJvdmlkZSBhbnkgbmV3IHBvc2l0aW9uIGluZm9ybWF0aW9uLlxuICAgIHJldHVybiAoc291cmNlc0luZGV4ID09PSBwcmV2W1NPVVJDRVNfSU5ERVhdICYmXG4gICAgICAgIHNvdXJjZUxpbmUgPT09IHByZXZbU09VUkNFX0xJTkVdICYmXG4gICAgICAgIHNvdXJjZUNvbHVtbiA9PT0gcHJldltTT1VSQ0VfQ09MVU1OXSAmJlxuICAgICAgICBuYW1lc0luZGV4ID09PSAocHJldi5sZW5ndGggPT09IDUgPyBwcmV2W05BTUVTX0lOREVYXSA6IE5PX05BTUUpKTtcbn1cbmZ1bmN0aW9uIGFkZE1hcHBpbmdJbnRlcm5hbChza2lwYWJsZSwgbWFwLCBtYXBwaW5nKSB7XG4gICAgY29uc3QgeyBnZW5lcmF0ZWQsIHNvdXJjZSwgb3JpZ2luYWwsIG5hbWUsIGNvbnRlbnQgfSA9IG1hcHBpbmc7XG4gICAgaWYgKCFzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIGFkZFNlZ21lbnRJbnRlcm5hbChza2lwYWJsZSwgbWFwLCBnZW5lcmF0ZWQubGluZSAtIDEsIGdlbmVyYXRlZC5jb2x1bW4sIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwpO1xuICAgIH1cbiAgICByZXR1cm4gYWRkU2VnbWVudEludGVybmFsKHNraXBhYmxlLCBtYXAsIGdlbmVyYXRlZC5saW5lIC0gMSwgZ2VuZXJhdGVkLmNvbHVtbiwgc291cmNlLCBvcmlnaW5hbC5saW5lIC0gMSwgb3JpZ2luYWwuY29sdW1uLCBuYW1lLCBjb250ZW50KTtcbn1cblxuZXhwb3J0IHsgR2VuTWFwcGluZywgYWRkTWFwcGluZywgYWRkU2VnbWVudCwgYWxsTWFwcGluZ3MsIGZyb21NYXAsIG1heWJlQWRkTWFwcGluZywgbWF5YmVBZGRTZWdtZW50LCBzZXRJZ25vcmUsIHNldFNvdXJjZUNvbnRlbnQsIHRvRGVjb2RlZE1hcCwgdG9FbmNvZGVkTWFwIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZW4tbWFwcGluZy5tanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@jridgewell/gen-mapping/dist/gen-mapping.mjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@jridgewell/resolve-uri/dist/resolve-uri.mjs":
/*!***********************************************************************!*\
  !*** ../../node_modules/@jridgewell/resolve-uri/dist/resolve-uri.mjs ***!
  \***********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ resolve)\n/* harmony export */ });\n// Matches the scheme of a URL, eg \"http://\"\nconst schemeRegex = /^[\\w+.-]+:\\/\\//;\n/**\n * Matches the parts of a URL:\n * 1. Scheme, including \":\", guaranteed.\n * 2. User/password, including \"@\", optional.\n * 3. Host, guaranteed.\n * 4. Port, including \":\", optional.\n * 5. Path, including \"/\", optional.\n * 6. Query, including \"?\", optional.\n * 7. Hash, including \"#\", optional.\n */\nconst urlRegex = /^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?(\\?[^#]*)?(#.*)?/;\n/**\n * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start\n * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).\n *\n * 1. Host, optional.\n * 2. Path, which may include \"/\", guaranteed.\n * 3. Query, including \"?\", optional.\n * 4. Hash, including \"#\", optional.\n */\nconst fileRegex = /^file:(?:\\/\\/((?![a-z]:)[^/#?]*)?)?(\\/?[^#?]*)(\\?[^#]*)?(#.*)?/i;\nfunction isAbsoluteUrl(input) {\n    return schemeRegex.test(input);\n}\nfunction isSchemeRelativeUrl(input) {\n    return input.startsWith('//');\n}\nfunction isAbsolutePath(input) {\n    return input.startsWith('/');\n}\nfunction isFileUrl(input) {\n    return input.startsWith('file:');\n}\nfunction isRelative(input) {\n    return /^[.?#]/.test(input);\n}\nfunction parseAbsoluteUrl(input) {\n    const match = urlRegex.exec(input);\n    return makeUrl(match[1], match[2] || '', match[3], match[4] || '', match[5] || '/', match[6] || '', match[7] || '');\n}\nfunction parseFileUrl(input) {\n    const match = fileRegex.exec(input);\n    const path = match[2];\n    return makeUrl('file:', '', match[1] || '', '', isAbsolutePath(path) ? path : '/' + path, match[3] || '', match[4] || '');\n}\nfunction makeUrl(scheme, user, host, port, path, query, hash) {\n    return {\n        scheme,\n        user,\n        host,\n        port,\n        path,\n        query,\n        hash,\n        type: 7 /* Absolute */,\n    };\n}\nfunction parseUrl(input) {\n    if (isSchemeRelativeUrl(input)) {\n        const url = parseAbsoluteUrl('http:' + input);\n        url.scheme = '';\n        url.type = 6 /* SchemeRelative */;\n        return url;\n    }\n    if (isAbsolutePath(input)) {\n        const url = parseAbsoluteUrl('http://foo.com' + input);\n        url.scheme = '';\n        url.host = '';\n        url.type = 5 /* AbsolutePath */;\n        return url;\n    }\n    if (isFileUrl(input))\n        return parseFileUrl(input);\n    if (isAbsoluteUrl(input))\n        return parseAbsoluteUrl(input);\n    const url = parseAbsoluteUrl('http://foo.com/' + input);\n    url.scheme = '';\n    url.host = '';\n    url.type = input\n        ? input.startsWith('?')\n            ? 3 /* Query */\n            : input.startsWith('#')\n                ? 2 /* Hash */\n                : 4 /* RelativePath */\n        : 1 /* Empty */;\n    return url;\n}\nfunction stripPathFilename(path) {\n    // If a path ends with a parent directory \"..\", then it's a relative path with excess parent\n    // paths. It's not a file, so we can't strip it.\n    if (path.endsWith('/..'))\n        return path;\n    const index = path.lastIndexOf('/');\n    return path.slice(0, index + 1);\n}\nfunction mergePaths(url, base) {\n    normalizePath(base, base.type);\n    // If the path is just a \"/\", then it was an empty path to begin with (remember, we're a relative\n    // path).\n    if (url.path === '/') {\n        url.path = base.path;\n    }\n    else {\n        // Resolution happens relative to the base path's directory, not the file.\n        url.path = stripPathFilename(base.path) + url.path;\n    }\n}\n/**\n * The path can have empty directories \"//\", unneeded parents \"foo/..\", or current directory\n * \"foo/.\". We need to normalize to a standard representation.\n */\nfunction normalizePath(url, type) {\n    const rel = type <= 4 /* RelativePath */;\n    const pieces = url.path.split('/');\n    // We need to preserve the first piece always, so that we output a leading slash. The item at\n    // pieces[0] is an empty string.\n    let pointer = 1;\n    // Positive is the number of real directories we've output, used for popping a parent directory.\n    // Eg, \"foo/bar/..\" will have a positive 2, and we can decrement to be left with just \"foo\".\n    let positive = 0;\n    // We need to keep a trailing slash if we encounter an empty directory (eg, splitting \"foo/\" will\n    // generate `[\"foo\", \"\"]` pieces). And, if we pop a parent directory. But once we encounter a\n    // real directory, we won't need to append, unless the other conditions happen again.\n    let addTrailingSlash = false;\n    for (let i = 1; i < pieces.length; i++) {\n        const piece = pieces[i];\n        // An empty directory, could be a trailing slash, or just a double \"//\" in the path.\n        if (!piece) {\n            addTrailingSlash = true;\n            continue;\n        }\n        // If we encounter a real directory, then we don't need to append anymore.\n        addTrailingSlash = false;\n        // A current directory, which we can always drop.\n        if (piece === '.')\n            continue;\n        // A parent directory, we need to see if there are any real directories we can pop. Else, we\n        // have an excess of parents, and we'll need to keep the \"..\".\n        if (piece === '..') {\n            if (positive) {\n                addTrailingSlash = true;\n                positive--;\n                pointer--;\n            }\n            else if (rel) {\n                // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute\n                // URL, protocol relative URL, or an absolute path, we don't need to keep excess.\n                pieces[pointer++] = piece;\n            }\n            continue;\n        }\n        // We've encountered a real directory. Move it to the next insertion pointer, which accounts for\n        // any popped or dropped directories.\n        pieces[pointer++] = piece;\n        positive++;\n    }\n    let path = '';\n    for (let i = 1; i < pointer; i++) {\n        path += '/' + pieces[i];\n    }\n    if (!path || (addTrailingSlash && !path.endsWith('/..'))) {\n        path += '/';\n    }\n    url.path = path;\n}\n/**\n * Attempts to resolve `input` URL/path relative to `base`.\n */\nfunction resolve(input, base) {\n    if (!input && !base)\n        return '';\n    const url = parseUrl(input);\n    let inputType = url.type;\n    if (base && inputType !== 7 /* Absolute */) {\n        const baseUrl = parseUrl(base);\n        const baseType = baseUrl.type;\n        switch (inputType) {\n            case 1 /* Empty */:\n                url.hash = baseUrl.hash;\n            // fall through\n            case 2 /* Hash */:\n                url.query = baseUrl.query;\n            // fall through\n            case 3 /* Query */:\n            case 4 /* RelativePath */:\n                mergePaths(url, baseUrl);\n            // fall through\n            case 5 /* AbsolutePath */:\n                // The host, user, and port are joined, you can't copy one without the others.\n                url.user = baseUrl.user;\n                url.host = baseUrl.host;\n                url.port = baseUrl.port;\n            // fall through\n            case 6 /* SchemeRelative */:\n                // The input doesn't have a schema at least, so we need to copy at least that over.\n                url.scheme = baseUrl.scheme;\n        }\n        if (baseType > inputType)\n            inputType = baseType;\n    }\n    normalizePath(url, inputType);\n    const queryHash = url.query + url.hash;\n    switch (inputType) {\n        // This is impossible, because of the empty checks at the start of the function.\n        // case UrlType.Empty:\n        case 2 /* Hash */:\n        case 3 /* Query */:\n            return queryHash;\n        case 4 /* RelativePath */: {\n            // The first char is always a \"/\", and we need it to be relative.\n            const path = url.path.slice(1);\n            if (!path)\n                return queryHash || '.';\n            if (isRelative(base || input) && !isRelative(path)) {\n                // If base started with a leading \".\", or there is no base and input started with a \".\",\n                // then we need to ensure that the relative path starts with a \".\". We don't know if\n                // relative starts with a \"..\", though, so check before prepending.\n                return './' + path + queryHash;\n            }\n            return path + queryHash;\n        }\n        case 5 /* AbsolutePath */:\n            return url.path + queryHash;\n        default:\n            return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;\n    }\n}\n\n\n//# sourceMappingURL=resolve-uri.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BqcmlkZ2V3ZWxsL3Jlc29sdmUtdXJpL2Rpc3QvcmVzb2x2ZS11cmkubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRThCO0FBQzlCIiwic291cmNlcyI6WyIvVXNlcnMvbWFya3VzaG9nbmUvRG9jdW1lbnRzL0FQUFMvYmF6YWFyLXZpZC9iYXphYXItdmlkL25vZGVfbW9kdWxlcy9AanJpZGdld2VsbC9yZXNvbHZlLXVyaS9kaXN0L3Jlc29sdmUtdXJpLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBNYXRjaGVzIHRoZSBzY2hlbWUgb2YgYSBVUkwsIGVnIFwiaHR0cDovL1wiXG5jb25zdCBzY2hlbWVSZWdleCA9IC9eW1xcdysuLV0rOlxcL1xcLy87XG4vKipcbiAqIE1hdGNoZXMgdGhlIHBhcnRzIG9mIGEgVVJMOlxuICogMS4gU2NoZW1lLCBpbmNsdWRpbmcgXCI6XCIsIGd1YXJhbnRlZWQuXG4gKiAyLiBVc2VyL3Bhc3N3b3JkLCBpbmNsdWRpbmcgXCJAXCIsIG9wdGlvbmFsLlxuICogMy4gSG9zdCwgZ3VhcmFudGVlZC5cbiAqIDQuIFBvcnQsIGluY2x1ZGluZyBcIjpcIiwgb3B0aW9uYWwuXG4gKiA1LiBQYXRoLCBpbmNsdWRpbmcgXCIvXCIsIG9wdGlvbmFsLlxuICogNi4gUXVlcnksIGluY2x1ZGluZyBcIj9cIiwgb3B0aW9uYWwuXG4gKiA3LiBIYXNoLCBpbmNsdWRpbmcgXCIjXCIsIG9wdGlvbmFsLlxuICovXG5jb25zdCB1cmxSZWdleCA9IC9eKFtcXHcrLi1dKzopXFwvXFwvKFteQC8jP10qQCk/KFteOi8jP10qKSg6XFxkKyk/KFxcL1teIz9dKik/KFxcP1teI10qKT8oIy4qKT8vO1xuLyoqXG4gKiBGaWxlIFVSTHMgYXJlIHdlaXJkLiBUaGV5IGRvbnQnIG5lZWQgdGhlIHJlZ3VsYXIgYC8vYCBpbiB0aGUgc2NoZW1lLCB0aGV5IG1heSBvciBtYXkgbm90IHN0YXJ0XG4gKiB3aXRoIGEgbGVhZGluZyBgL2AsIHRoZXkgY2FuIGhhdmUgYSBkb21haW4gKGJ1dCBvbmx5IGlmIHRoZXkgZG9uJ3Qgc3RhcnQgd2l0aCBhIFdpbmRvd3MgZHJpdmUpLlxuICpcbiAqIDEuIEhvc3QsIG9wdGlvbmFsLlxuICogMi4gUGF0aCwgd2hpY2ggbWF5IGluY2x1ZGUgXCIvXCIsIGd1YXJhbnRlZWQuXG4gKiAzLiBRdWVyeSwgaW5jbHVkaW5nIFwiP1wiLCBvcHRpb25hbC5cbiAqIDQuIEhhc2gsIGluY2x1ZGluZyBcIiNcIiwgb3B0aW9uYWwuXG4gKi9cbmNvbnN0IGZpbGVSZWdleCA9IC9eZmlsZTooPzpcXC9cXC8oKD8hW2Etel06KVteLyM/XSopPyk/KFxcLz9bXiM/XSopKFxcP1teI10qKT8oIy4qKT8vaTtcbmZ1bmN0aW9uIGlzQWJzb2x1dGVVcmwoaW5wdXQpIHtcbiAgICByZXR1cm4gc2NoZW1lUmVnZXgudGVzdChpbnB1dCk7XG59XG5mdW5jdGlvbiBpc1NjaGVtZVJlbGF0aXZlVXJsKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0LnN0YXJ0c1dpdGgoJy8vJyk7XG59XG5mdW5jdGlvbiBpc0Fic29sdXRlUGF0aChpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dC5zdGFydHNXaXRoKCcvJyk7XG59XG5mdW5jdGlvbiBpc0ZpbGVVcmwoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQuc3RhcnRzV2l0aCgnZmlsZTonKTtcbn1cbmZ1bmN0aW9uIGlzUmVsYXRpdmUoaW5wdXQpIHtcbiAgICByZXR1cm4gL15bLj8jXS8udGVzdChpbnB1dCk7XG59XG5mdW5jdGlvbiBwYXJzZUFic29sdXRlVXJsKGlucHV0KSB7XG4gICAgY29uc3QgbWF0Y2ggPSB1cmxSZWdleC5leGVjKGlucHV0KTtcbiAgICByZXR1cm4gbWFrZVVybChtYXRjaFsxXSwgbWF0Y2hbMl0gfHwgJycsIG1hdGNoWzNdLCBtYXRjaFs0XSB8fCAnJywgbWF0Y2hbNV0gfHwgJy8nLCBtYXRjaFs2XSB8fCAnJywgbWF0Y2hbN10gfHwgJycpO1xufVxuZnVuY3Rpb24gcGFyc2VGaWxlVXJsKGlucHV0KSB7XG4gICAgY29uc3QgbWF0Y2ggPSBmaWxlUmVnZXguZXhlYyhpbnB1dCk7XG4gICAgY29uc3QgcGF0aCA9IG1hdGNoWzJdO1xuICAgIHJldHVybiBtYWtlVXJsKCdmaWxlOicsICcnLCBtYXRjaFsxXSB8fCAnJywgJycsIGlzQWJzb2x1dGVQYXRoKHBhdGgpID8gcGF0aCA6ICcvJyArIHBhdGgsIG1hdGNoWzNdIHx8ICcnLCBtYXRjaFs0XSB8fCAnJyk7XG59XG5mdW5jdGlvbiBtYWtlVXJsKHNjaGVtZSwgdXNlciwgaG9zdCwgcG9ydCwgcGF0aCwgcXVlcnksIGhhc2gpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzY2hlbWUsXG4gICAgICAgIHVzZXIsXG4gICAgICAgIGhvc3QsXG4gICAgICAgIHBvcnQsXG4gICAgICAgIHBhdGgsXG4gICAgICAgIHF1ZXJ5LFxuICAgICAgICBoYXNoLFxuICAgICAgICB0eXBlOiA3IC8qIEFic29sdXRlICovLFxuICAgIH07XG59XG5mdW5jdGlvbiBwYXJzZVVybChpbnB1dCkge1xuICAgIGlmIChpc1NjaGVtZVJlbGF0aXZlVXJsKGlucHV0KSkge1xuICAgICAgICBjb25zdCB1cmwgPSBwYXJzZUFic29sdXRlVXJsKCdodHRwOicgKyBpbnB1dCk7XG4gICAgICAgIHVybC5zY2hlbWUgPSAnJztcbiAgICAgICAgdXJsLnR5cGUgPSA2IC8qIFNjaGVtZVJlbGF0aXZlICovO1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cbiAgICBpZiAoaXNBYnNvbHV0ZVBhdGgoaW5wdXQpKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IHBhcnNlQWJzb2x1dGVVcmwoJ2h0dHA6Ly9mb28uY29tJyArIGlucHV0KTtcbiAgICAgICAgdXJsLnNjaGVtZSA9ICcnO1xuICAgICAgICB1cmwuaG9zdCA9ICcnO1xuICAgICAgICB1cmwudHlwZSA9IDUgLyogQWJzb2x1dGVQYXRoICovO1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH1cbiAgICBpZiAoaXNGaWxlVXJsKGlucHV0KSlcbiAgICAgICAgcmV0dXJuIHBhcnNlRmlsZVVybChpbnB1dCk7XG4gICAgaWYgKGlzQWJzb2x1dGVVcmwoaW5wdXQpKVxuICAgICAgICByZXR1cm4gcGFyc2VBYnNvbHV0ZVVybChpbnB1dCk7XG4gICAgY29uc3QgdXJsID0gcGFyc2VBYnNvbHV0ZVVybCgnaHR0cDovL2Zvby5jb20vJyArIGlucHV0KTtcbiAgICB1cmwuc2NoZW1lID0gJyc7XG4gICAgdXJsLmhvc3QgPSAnJztcbiAgICB1cmwudHlwZSA9IGlucHV0XG4gICAgICAgID8gaW5wdXQuc3RhcnRzV2l0aCgnPycpXG4gICAgICAgICAgICA/IDMgLyogUXVlcnkgKi9cbiAgICAgICAgICAgIDogaW5wdXQuc3RhcnRzV2l0aCgnIycpXG4gICAgICAgICAgICAgICAgPyAyIC8qIEhhc2ggKi9cbiAgICAgICAgICAgICAgICA6IDQgLyogUmVsYXRpdmVQYXRoICovXG4gICAgICAgIDogMSAvKiBFbXB0eSAqLztcbiAgICByZXR1cm4gdXJsO1xufVxuZnVuY3Rpb24gc3RyaXBQYXRoRmlsZW5hbWUocGF0aCkge1xuICAgIC8vIElmIGEgcGF0aCBlbmRzIHdpdGggYSBwYXJlbnQgZGlyZWN0b3J5IFwiLi5cIiwgdGhlbiBpdCdzIGEgcmVsYXRpdmUgcGF0aCB3aXRoIGV4Y2VzcyBwYXJlbnRcbiAgICAvLyBwYXRocy4gSXQncyBub3QgYSBmaWxlLCBzbyB3ZSBjYW4ndCBzdHJpcCBpdC5cbiAgICBpZiAocGF0aC5lbmRzV2l0aCgnLy4uJykpXG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIGNvbnN0IGluZGV4ID0gcGF0aC5sYXN0SW5kZXhPZignLycpO1xuICAgIHJldHVybiBwYXRoLnNsaWNlKDAsIGluZGV4ICsgMSk7XG59XG5mdW5jdGlvbiBtZXJnZVBhdGhzKHVybCwgYmFzZSkge1xuICAgIG5vcm1hbGl6ZVBhdGgoYmFzZSwgYmFzZS50eXBlKTtcbiAgICAvLyBJZiB0aGUgcGF0aCBpcyBqdXN0IGEgXCIvXCIsIHRoZW4gaXQgd2FzIGFuIGVtcHR5IHBhdGggdG8gYmVnaW4gd2l0aCAocmVtZW1iZXIsIHdlJ3JlIGEgcmVsYXRpdmVcbiAgICAvLyBwYXRoKS5cbiAgICBpZiAodXJsLnBhdGggPT09ICcvJykge1xuICAgICAgICB1cmwucGF0aCA9IGJhc2UucGF0aDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFJlc29sdXRpb24gaGFwcGVucyByZWxhdGl2ZSB0byB0aGUgYmFzZSBwYXRoJ3MgZGlyZWN0b3J5LCBub3QgdGhlIGZpbGUuXG4gICAgICAgIHVybC5wYXRoID0gc3RyaXBQYXRoRmlsZW5hbWUoYmFzZS5wYXRoKSArIHVybC5wYXRoO1xuICAgIH1cbn1cbi8qKlxuICogVGhlIHBhdGggY2FuIGhhdmUgZW1wdHkgZGlyZWN0b3JpZXMgXCIvL1wiLCB1bm5lZWRlZCBwYXJlbnRzIFwiZm9vLy4uXCIsIG9yIGN1cnJlbnQgZGlyZWN0b3J5XG4gKiBcImZvby8uXCIuIFdlIG5lZWQgdG8gbm9ybWFsaXplIHRvIGEgc3RhbmRhcmQgcmVwcmVzZW50YXRpb24uXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVBhdGgodXJsLCB0eXBlKSB7XG4gICAgY29uc3QgcmVsID0gdHlwZSA8PSA0IC8qIFJlbGF0aXZlUGF0aCAqLztcbiAgICBjb25zdCBwaWVjZXMgPSB1cmwucGF0aC5zcGxpdCgnLycpO1xuICAgIC8vIFdlIG5lZWQgdG8gcHJlc2VydmUgdGhlIGZpcnN0IHBpZWNlIGFsd2F5cywgc28gdGhhdCB3ZSBvdXRwdXQgYSBsZWFkaW5nIHNsYXNoLiBUaGUgaXRlbSBhdFxuICAgIC8vIHBpZWNlc1swXSBpcyBhbiBlbXB0eSBzdHJpbmcuXG4gICAgbGV0IHBvaW50ZXIgPSAxO1xuICAgIC8vIFBvc2l0aXZlIGlzIHRoZSBudW1iZXIgb2YgcmVhbCBkaXJlY3RvcmllcyB3ZSd2ZSBvdXRwdXQsIHVzZWQgZm9yIHBvcHBpbmcgYSBwYXJlbnQgZGlyZWN0b3J5LlxuICAgIC8vIEVnLCBcImZvby9iYXIvLi5cIiB3aWxsIGhhdmUgYSBwb3NpdGl2ZSAyLCBhbmQgd2UgY2FuIGRlY3JlbWVudCB0byBiZSBsZWZ0IHdpdGgganVzdCBcImZvb1wiLlxuICAgIGxldCBwb3NpdGl2ZSA9IDA7XG4gICAgLy8gV2UgbmVlZCB0byBrZWVwIGEgdHJhaWxpbmcgc2xhc2ggaWYgd2UgZW5jb3VudGVyIGFuIGVtcHR5IGRpcmVjdG9yeSAoZWcsIHNwbGl0dGluZyBcImZvby9cIiB3aWxsXG4gICAgLy8gZ2VuZXJhdGUgYFtcImZvb1wiLCBcIlwiXWAgcGllY2VzKS4gQW5kLCBpZiB3ZSBwb3AgYSBwYXJlbnQgZGlyZWN0b3J5LiBCdXQgb25jZSB3ZSBlbmNvdW50ZXIgYVxuICAgIC8vIHJlYWwgZGlyZWN0b3J5LCB3ZSB3b24ndCBuZWVkIHRvIGFwcGVuZCwgdW5sZXNzIHRoZSBvdGhlciBjb25kaXRpb25zIGhhcHBlbiBhZ2Fpbi5cbiAgICBsZXQgYWRkVHJhaWxpbmdTbGFzaCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcGllY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHBpZWNlID0gcGllY2VzW2ldO1xuICAgICAgICAvLyBBbiBlbXB0eSBkaXJlY3RvcnksIGNvdWxkIGJlIGEgdHJhaWxpbmcgc2xhc2gsIG9yIGp1c3QgYSBkb3VibGUgXCIvL1wiIGluIHRoZSBwYXRoLlxuICAgICAgICBpZiAoIXBpZWNlKSB7XG4gICAgICAgICAgICBhZGRUcmFpbGluZ1NsYXNoID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGVuY291bnRlciBhIHJlYWwgZGlyZWN0b3J5LCB0aGVuIHdlIGRvbid0IG5lZWQgdG8gYXBwZW5kIGFueW1vcmUuXG4gICAgICAgIGFkZFRyYWlsaW5nU2xhc2ggPSBmYWxzZTtcbiAgICAgICAgLy8gQSBjdXJyZW50IGRpcmVjdG9yeSwgd2hpY2ggd2UgY2FuIGFsd2F5cyBkcm9wLlxuICAgICAgICBpZiAocGllY2UgPT09ICcuJylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAvLyBBIHBhcmVudCBkaXJlY3RvcnksIHdlIG5lZWQgdG8gc2VlIGlmIHRoZXJlIGFyZSBhbnkgcmVhbCBkaXJlY3RvcmllcyB3ZSBjYW4gcG9wLiBFbHNlLCB3ZVxuICAgICAgICAvLyBoYXZlIGFuIGV4Y2VzcyBvZiBwYXJlbnRzLCBhbmQgd2UnbGwgbmVlZCB0byBrZWVwIHRoZSBcIi4uXCIuXG4gICAgICAgIGlmIChwaWVjZSA9PT0gJy4uJykge1xuICAgICAgICAgICAgaWYgKHBvc2l0aXZlKSB7XG4gICAgICAgICAgICAgICAgYWRkVHJhaWxpbmdTbGFzaCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcG9zaXRpdmUtLTtcbiAgICAgICAgICAgICAgICBwb2ludGVyLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZWwpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBpbiBhIHJlbGF0aXZlUGF0aCwgdGhlbiB3ZSBuZWVkIHRvIGtlZXAgdGhlIGV4Y2VzcyBwYXJlbnRzLiBFbHNlLCBpbiBhbiBhYnNvbHV0ZVxuICAgICAgICAgICAgICAgIC8vIFVSTCwgcHJvdG9jb2wgcmVsYXRpdmUgVVJMLCBvciBhbiBhYnNvbHV0ZSBwYXRoLCB3ZSBkb24ndCBuZWVkIHRvIGtlZXAgZXhjZXNzLlxuICAgICAgICAgICAgICAgIHBpZWNlc1twb2ludGVyKytdID0gcGllY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSd2ZSBlbmNvdW50ZXJlZCBhIHJlYWwgZGlyZWN0b3J5LiBNb3ZlIGl0IHRvIHRoZSBuZXh0IGluc2VydGlvbiBwb2ludGVyLCB3aGljaCBhY2NvdW50cyBmb3JcbiAgICAgICAgLy8gYW55IHBvcHBlZCBvciBkcm9wcGVkIGRpcmVjdG9yaWVzLlxuICAgICAgICBwaWVjZXNbcG9pbnRlcisrXSA9IHBpZWNlO1xuICAgICAgICBwb3NpdGl2ZSsrO1xuICAgIH1cbiAgICBsZXQgcGF0aCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcG9pbnRlcjsgaSsrKSB7XG4gICAgICAgIHBhdGggKz0gJy8nICsgcGllY2VzW2ldO1xuICAgIH1cbiAgICBpZiAoIXBhdGggfHwgKGFkZFRyYWlsaW5nU2xhc2ggJiYgIXBhdGguZW5kc1dpdGgoJy8uLicpKSkge1xuICAgICAgICBwYXRoICs9ICcvJztcbiAgICB9XG4gICAgdXJsLnBhdGggPSBwYXRoO1xufVxuLyoqXG4gKiBBdHRlbXB0cyB0byByZXNvbHZlIGBpbnB1dGAgVVJML3BhdGggcmVsYXRpdmUgdG8gYGJhc2VgLlxuICovXG5mdW5jdGlvbiByZXNvbHZlKGlucHV0LCBiYXNlKSB7XG4gICAgaWYgKCFpbnB1dCAmJiAhYmFzZSlcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIGNvbnN0IHVybCA9IHBhcnNlVXJsKGlucHV0KTtcbiAgICBsZXQgaW5wdXRUeXBlID0gdXJsLnR5cGU7XG4gICAgaWYgKGJhc2UgJiYgaW5wdXRUeXBlICE9PSA3IC8qIEFic29sdXRlICovKSB7XG4gICAgICAgIGNvbnN0IGJhc2VVcmwgPSBwYXJzZVVybChiYXNlKTtcbiAgICAgICAgY29uc3QgYmFzZVR5cGUgPSBiYXNlVXJsLnR5cGU7XG4gICAgICAgIHN3aXRjaCAoaW5wdXRUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIDEgLyogRW1wdHkgKi86XG4gICAgICAgICAgICAgICAgdXJsLmhhc2ggPSBiYXNlVXJsLmhhc2g7XG4gICAgICAgICAgICAvLyBmYWxsIHRocm91Z2hcbiAgICAgICAgICAgIGNhc2UgMiAvKiBIYXNoICovOlxuICAgICAgICAgICAgICAgIHVybC5xdWVyeSA9IGJhc2VVcmwucXVlcnk7XG4gICAgICAgICAgICAvLyBmYWxsIHRocm91Z2hcbiAgICAgICAgICAgIGNhc2UgMyAvKiBRdWVyeSAqLzpcbiAgICAgICAgICAgIGNhc2UgNCAvKiBSZWxhdGl2ZVBhdGggKi86XG4gICAgICAgICAgICAgICAgbWVyZ2VQYXRocyh1cmwsIGJhc2VVcmwpO1xuICAgICAgICAgICAgLy8gZmFsbCB0aHJvdWdoXG4gICAgICAgICAgICBjYXNlIDUgLyogQWJzb2x1dGVQYXRoICovOlxuICAgICAgICAgICAgICAgIC8vIFRoZSBob3N0LCB1c2VyLCBhbmQgcG9ydCBhcmUgam9pbmVkLCB5b3UgY2FuJ3QgY29weSBvbmUgd2l0aG91dCB0aGUgb3RoZXJzLlxuICAgICAgICAgICAgICAgIHVybC51c2VyID0gYmFzZVVybC51c2VyO1xuICAgICAgICAgICAgICAgIHVybC5ob3N0ID0gYmFzZVVybC5ob3N0O1xuICAgICAgICAgICAgICAgIHVybC5wb3J0ID0gYmFzZVVybC5wb3J0O1xuICAgICAgICAgICAgLy8gZmFsbCB0aHJvdWdoXG4gICAgICAgICAgICBjYXNlIDYgLyogU2NoZW1lUmVsYXRpdmUgKi86XG4gICAgICAgICAgICAgICAgLy8gVGhlIGlucHV0IGRvZXNuJ3QgaGF2ZSBhIHNjaGVtYSBhdCBsZWFzdCwgc28gd2UgbmVlZCB0byBjb3B5IGF0IGxlYXN0IHRoYXQgb3Zlci5cbiAgICAgICAgICAgICAgICB1cmwuc2NoZW1lID0gYmFzZVVybC5zY2hlbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJhc2VUeXBlID4gaW5wdXRUeXBlKVxuICAgICAgICAgICAgaW5wdXRUeXBlID0gYmFzZVR5cGU7XG4gICAgfVxuICAgIG5vcm1hbGl6ZVBhdGgodXJsLCBpbnB1dFR5cGUpO1xuICAgIGNvbnN0IHF1ZXJ5SGFzaCA9IHVybC5xdWVyeSArIHVybC5oYXNoO1xuICAgIHN3aXRjaCAoaW5wdXRUeXBlKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgaW1wb3NzaWJsZSwgYmVjYXVzZSBvZiB0aGUgZW1wdHkgY2hlY2tzIGF0IHRoZSBzdGFydCBvZiB0aGUgZnVuY3Rpb24uXG4gICAgICAgIC8vIGNhc2UgVXJsVHlwZS5FbXB0eTpcbiAgICAgICAgY2FzZSAyIC8qIEhhc2ggKi86XG4gICAgICAgIGNhc2UgMyAvKiBRdWVyeSAqLzpcbiAgICAgICAgICAgIHJldHVybiBxdWVyeUhhc2g7XG4gICAgICAgIGNhc2UgNCAvKiBSZWxhdGl2ZVBhdGggKi86IHtcbiAgICAgICAgICAgIC8vIFRoZSBmaXJzdCBjaGFyIGlzIGFsd2F5cyBhIFwiL1wiLCBhbmQgd2UgbmVlZCBpdCB0byBiZSByZWxhdGl2ZS5cbiAgICAgICAgICAgIGNvbnN0IHBhdGggPSB1cmwucGF0aC5zbGljZSgxKTtcbiAgICAgICAgICAgIGlmICghcGF0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gcXVlcnlIYXNoIHx8ICcuJztcbiAgICAgICAgICAgIGlmIChpc1JlbGF0aXZlKGJhc2UgfHwgaW5wdXQpICYmICFpc1JlbGF0aXZlKHBhdGgpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgYmFzZSBzdGFydGVkIHdpdGggYSBsZWFkaW5nIFwiLlwiLCBvciB0aGVyZSBpcyBubyBiYXNlIGFuZCBpbnB1dCBzdGFydGVkIHdpdGggYSBcIi5cIixcbiAgICAgICAgICAgICAgICAvLyB0aGVuIHdlIG5lZWQgdG8gZW5zdXJlIHRoYXQgdGhlIHJlbGF0aXZlIHBhdGggc3RhcnRzIHdpdGggYSBcIi5cIi4gV2UgZG9uJ3Qga25vdyBpZlxuICAgICAgICAgICAgICAgIC8vIHJlbGF0aXZlIHN0YXJ0cyB3aXRoIGEgXCIuLlwiLCB0aG91Z2gsIHNvIGNoZWNrIGJlZm9yZSBwcmVwZW5kaW5nLlxuICAgICAgICAgICAgICAgIHJldHVybiAnLi8nICsgcGF0aCArIHF1ZXJ5SGFzaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXRoICsgcXVlcnlIYXNoO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgNSAvKiBBYnNvbHV0ZVBhdGggKi86XG4gICAgICAgICAgICByZXR1cm4gdXJsLnBhdGggKyBxdWVyeUhhc2g7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gdXJsLnNjaGVtZSArICcvLycgKyB1cmwudXNlciArIHVybC5ob3N0ICsgdXJsLnBvcnQgKyB1cmwucGF0aCArIHF1ZXJ5SGFzaDtcbiAgICB9XG59XG5cbmV4cG9ydCB7IHJlc29sdmUgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb2x2ZS11cmkubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@jridgewell/resolve-uri/dist/resolve-uri.mjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@jridgewell/set-array/dist/set-array.mjs":
/*!*******************************************************************!*\
  !*** ../../node_modules/@jridgewell/set-array/dist/set-array.mjs ***!
  \*******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SetArray: () => (/* binding */ SetArray),\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   pop: () => (/* binding */ pop),\n/* harmony export */   put: () => (/* binding */ put),\n/* harmony export */   remove: () => (/* binding */ remove)\n/* harmony export */ });\n/**\n * SetArray acts like a `Set` (allowing only one occurrence of a string `key`), but provides the\n * index of the `key` in the backing array.\n *\n * This is designed to allow synchronizing a second array with the contents of the backing array,\n * like how in a sourcemap `sourcesContent[i]` is the source content associated with `source[i]`,\n * and there are never duplicates.\n */\nclass SetArray {\n    constructor() {\n        this._indexes = { __proto__: null };\n        this.array = [];\n    }\n}\n/**\n * Typescript doesn't allow friend access to private fields, so this just casts the set into a type\n * with public access modifiers.\n */\nfunction cast(set) {\n    return set;\n}\n/**\n * Gets the index associated with `key` in the backing array, if it is already present.\n */\nfunction get(setarr, key) {\n    return cast(setarr)._indexes[key];\n}\n/**\n * Puts `key` into the backing array, if it is not already present. Returns\n * the index of the `key` in the backing array.\n */\nfunction put(setarr, key) {\n    // The key may or may not be present. If it is present, it's a number.\n    const index = get(setarr, key);\n    if (index !== undefined)\n        return index;\n    const { array, _indexes: indexes } = cast(setarr);\n    const length = array.push(key);\n    return (indexes[key] = length - 1);\n}\n/**\n * Pops the last added item out of the SetArray.\n */\nfunction pop(setarr) {\n    const { array, _indexes: indexes } = cast(setarr);\n    if (array.length === 0)\n        return;\n    const last = array.pop();\n    indexes[last] = undefined;\n}\n/**\n * Removes the key, if it exists in the set.\n */\nfunction remove(setarr, key) {\n    const index = get(setarr, key);\n    if (index === undefined)\n        return;\n    const { array, _indexes: indexes } = cast(setarr);\n    for (let i = index + 1; i < array.length; i++) {\n        const k = array[i];\n        array[i - 1] = k;\n        indexes[k]--;\n    }\n    indexes[key] = undefined;\n    array.pop();\n}\n\n\n//# sourceMappingURL=set-array.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BqcmlkZ2V3ZWxsL3NldC1hcnJheS9kaXN0L3NldC1hcnJheS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkJBQTJCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwyQkFBMkI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwyQkFBMkI7QUFDdkMsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMkM7QUFDM0MiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXJrdXNob2duZS9Eb2N1bWVudHMvQVBQUy9iYXphYXItdmlkL2JhemFhci12aWQvbm9kZV9tb2R1bGVzL0BqcmlkZ2V3ZWxsL3NldC1hcnJheS9kaXN0L3NldC1hcnJheS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBTZXRBcnJheSBhY3RzIGxpa2UgYSBgU2V0YCAoYWxsb3dpbmcgb25seSBvbmUgb2NjdXJyZW5jZSBvZiBhIHN0cmluZyBga2V5YCksIGJ1dCBwcm92aWRlcyB0aGVcbiAqIGluZGV4IG9mIHRoZSBga2V5YCBpbiB0aGUgYmFja2luZyBhcnJheS5cbiAqXG4gKiBUaGlzIGlzIGRlc2lnbmVkIHRvIGFsbG93IHN5bmNocm9uaXppbmcgYSBzZWNvbmQgYXJyYXkgd2l0aCB0aGUgY29udGVudHMgb2YgdGhlIGJhY2tpbmcgYXJyYXksXG4gKiBsaWtlIGhvdyBpbiBhIHNvdXJjZW1hcCBgc291cmNlc0NvbnRlbnRbaV1gIGlzIHRoZSBzb3VyY2UgY29udGVudCBhc3NvY2lhdGVkIHdpdGggYHNvdXJjZVtpXWAsXG4gKiBhbmQgdGhlcmUgYXJlIG5ldmVyIGR1cGxpY2F0ZXMuXG4gKi9cbmNsYXNzIFNldEFycmF5IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5faW5kZXhlcyA9IHsgX19wcm90b19fOiBudWxsIH07XG4gICAgICAgIHRoaXMuYXJyYXkgPSBbXTtcbiAgICB9XG59XG4vKipcbiAqIFR5cGVzY3JpcHQgZG9lc24ndCBhbGxvdyBmcmllbmQgYWNjZXNzIHRvIHByaXZhdGUgZmllbGRzLCBzbyB0aGlzIGp1c3QgY2FzdHMgdGhlIHNldCBpbnRvIGEgdHlwZVxuICogd2l0aCBwdWJsaWMgYWNjZXNzIG1vZGlmaWVycy5cbiAqL1xuZnVuY3Rpb24gY2FzdChzZXQpIHtcbiAgICByZXR1cm4gc2V0O1xufVxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhc3NvY2lhdGVkIHdpdGggYGtleWAgaW4gdGhlIGJhY2tpbmcgYXJyYXksIGlmIGl0IGlzIGFscmVhZHkgcHJlc2VudC5cbiAqL1xuZnVuY3Rpb24gZ2V0KHNldGFyciwga2V5KSB7XG4gICAgcmV0dXJuIGNhc3Qoc2V0YXJyKS5faW5kZXhlc1trZXldO1xufVxuLyoqXG4gKiBQdXRzIGBrZXlgIGludG8gdGhlIGJhY2tpbmcgYXJyYXksIGlmIGl0IGlzIG5vdCBhbHJlYWR5IHByZXNlbnQuIFJldHVybnNcbiAqIHRoZSBpbmRleCBvZiB0aGUgYGtleWAgaW4gdGhlIGJhY2tpbmcgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHB1dChzZXRhcnIsIGtleSkge1xuICAgIC8vIFRoZSBrZXkgbWF5IG9yIG1heSBub3QgYmUgcHJlc2VudC4gSWYgaXQgaXMgcHJlc2VudCwgaXQncyBhIG51bWJlci5cbiAgICBjb25zdCBpbmRleCA9IGdldChzZXRhcnIsIGtleSk7XG4gICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICBjb25zdCB7IGFycmF5LCBfaW5kZXhlczogaW5kZXhlcyB9ID0gY2FzdChzZXRhcnIpO1xuICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5LnB1c2goa2V5KTtcbiAgICByZXR1cm4gKGluZGV4ZXNba2V5XSA9IGxlbmd0aCAtIDEpO1xufVxuLyoqXG4gKiBQb3BzIHRoZSBsYXN0IGFkZGVkIGl0ZW0gb3V0IG9mIHRoZSBTZXRBcnJheS5cbiAqL1xuZnVuY3Rpb24gcG9wKHNldGFycikge1xuICAgIGNvbnN0IHsgYXJyYXksIF9pbmRleGVzOiBpbmRleGVzIH0gPSBjYXN0KHNldGFycik7XG4gICAgaWYgKGFycmF5Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGxhc3QgPSBhcnJheS5wb3AoKTtcbiAgICBpbmRleGVzW2xhc3RdID0gdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBSZW1vdmVzIHRoZSBrZXksIGlmIGl0IGV4aXN0cyBpbiB0aGUgc2V0LlxuICovXG5mdW5jdGlvbiByZW1vdmUoc2V0YXJyLCBrZXkpIHtcbiAgICBjb25zdCBpbmRleCA9IGdldChzZXRhcnIsIGtleSk7XG4gICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IGFycmF5LCBfaW5kZXhlczogaW5kZXhlcyB9ID0gY2FzdChzZXRhcnIpO1xuICAgIGZvciAobGV0IGkgPSBpbmRleCArIDE7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBrID0gYXJyYXlbaV07XG4gICAgICAgIGFycmF5W2kgLSAxXSA9IGs7XG4gICAgICAgIGluZGV4ZXNba10tLTtcbiAgICB9XG4gICAgaW5kZXhlc1trZXldID0gdW5kZWZpbmVkO1xuICAgIGFycmF5LnBvcCgpO1xufVxuXG5leHBvcnQgeyBTZXRBcnJheSwgZ2V0LCBwb3AsIHB1dCwgcmVtb3ZlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXQtYXJyYXkubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@jridgewell/set-array/dist/set-array.mjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs":
/*!*******************************************************************************!*\
  !*** ../../node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs ***!
  \*******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decode: () => (/* binding */ decode),\n/* harmony export */   decodeGeneratedRanges: () => (/* binding */ decodeGeneratedRanges),\n/* harmony export */   decodeOriginalScopes: () => (/* binding */ decodeOriginalScopes),\n/* harmony export */   encode: () => (/* binding */ encode),\n/* harmony export */   encodeGeneratedRanges: () => (/* binding */ encodeGeneratedRanges),\n/* harmony export */   encodeOriginalScopes: () => (/* binding */ encodeOriginalScopes)\n/* harmony export */ });\nconst comma = ','.charCodeAt(0);\nconst semicolon = ';'.charCodeAt(0);\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst intToChar = new Uint8Array(64); // 64 possible chars.\nconst charToInt = new Uint8Array(128); // z is 122 in ASCII\nfor (let i = 0; i < chars.length; i++) {\n    const c = chars.charCodeAt(i);\n    intToChar[i] = c;\n    charToInt[c] = i;\n}\nfunction decodeInteger(reader, relative) {\n    let value = 0;\n    let shift = 0;\n    let integer = 0;\n    do {\n        const c = reader.next();\n        integer = charToInt[c];\n        value |= (integer & 31) << shift;\n        shift += 5;\n    } while (integer & 32);\n    const shouldNegate = value & 1;\n    value >>>= 1;\n    if (shouldNegate) {\n        value = -0x80000000 | -value;\n    }\n    return relative + value;\n}\nfunction encodeInteger(builder, num, relative) {\n    let delta = num - relative;\n    delta = delta < 0 ? (-delta << 1) | 1 : delta << 1;\n    do {\n        let clamped = delta & 0b011111;\n        delta >>>= 5;\n        if (delta > 0)\n            clamped |= 0b100000;\n        builder.write(intToChar[clamped]);\n    } while (delta > 0);\n    return num;\n}\nfunction hasMoreVlq(reader, max) {\n    if (reader.pos >= max)\n        return false;\n    return reader.peek() !== comma;\n}\n\nconst bufLength = 1024 * 16;\n// Provide a fallback for older environments.\nconst td = typeof TextDecoder !== 'undefined'\n    ? /* #__PURE__ */ new TextDecoder()\n    : typeof Buffer !== 'undefined'\n        ? {\n            decode(buf) {\n                const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n                return out.toString();\n            },\n        }\n        : {\n            decode(buf) {\n                let out = '';\n                for (let i = 0; i < buf.length; i++) {\n                    out += String.fromCharCode(buf[i]);\n                }\n                return out;\n            },\n        };\nclass StringWriter {\n    constructor() {\n        this.pos = 0;\n        this.out = '';\n        this.buffer = new Uint8Array(bufLength);\n    }\n    write(v) {\n        const { buffer } = this;\n        buffer[this.pos++] = v;\n        if (this.pos === bufLength) {\n            this.out += td.decode(buffer);\n            this.pos = 0;\n        }\n    }\n    flush() {\n        const { buffer, out, pos } = this;\n        return pos > 0 ? out + td.decode(buffer.subarray(0, pos)) : out;\n    }\n}\nclass StringReader {\n    constructor(buffer) {\n        this.pos = 0;\n        this.buffer = buffer;\n    }\n    next() {\n        return this.buffer.charCodeAt(this.pos++);\n    }\n    peek() {\n        return this.buffer.charCodeAt(this.pos);\n    }\n    indexOf(char) {\n        const { buffer, pos } = this;\n        const idx = buffer.indexOf(char, pos);\n        return idx === -1 ? buffer.length : idx;\n    }\n}\n\nconst EMPTY = [];\nfunction decodeOriginalScopes(input) {\n    const { length } = input;\n    const reader = new StringReader(input);\n    const scopes = [];\n    const stack = [];\n    let line = 0;\n    for (; reader.pos < length; reader.pos++) {\n        line = decodeInteger(reader, line);\n        const column = decodeInteger(reader, 0);\n        if (!hasMoreVlq(reader, length)) {\n            const last = stack.pop();\n            last[2] = line;\n            last[3] = column;\n            continue;\n        }\n        const kind = decodeInteger(reader, 0);\n        const fields = decodeInteger(reader, 0);\n        const hasName = fields & 0b0001;\n        const scope = (hasName ? [line, column, 0, 0, kind, decodeInteger(reader, 0)] : [line, column, 0, 0, kind]);\n        let vars = EMPTY;\n        if (hasMoreVlq(reader, length)) {\n            vars = [];\n            do {\n                const varsIndex = decodeInteger(reader, 0);\n                vars.push(varsIndex);\n            } while (hasMoreVlq(reader, length));\n        }\n        scope.vars = vars;\n        scopes.push(scope);\n        stack.push(scope);\n    }\n    return scopes;\n}\nfunction encodeOriginalScopes(scopes) {\n    const writer = new StringWriter();\n    for (let i = 0; i < scopes.length;) {\n        i = _encodeOriginalScopes(scopes, i, writer, [0]);\n    }\n    return writer.flush();\n}\nfunction _encodeOriginalScopes(scopes, index, writer, state) {\n    const scope = scopes[index];\n    const { 0: startLine, 1: startColumn, 2: endLine, 3: endColumn, 4: kind, vars } = scope;\n    if (index > 0)\n        writer.write(comma);\n    state[0] = encodeInteger(writer, startLine, state[0]);\n    encodeInteger(writer, startColumn, 0);\n    encodeInteger(writer, kind, 0);\n    const fields = scope.length === 6 ? 0b0001 : 0;\n    encodeInteger(writer, fields, 0);\n    if (scope.length === 6)\n        encodeInteger(writer, scope[5], 0);\n    for (const v of vars) {\n        encodeInteger(writer, v, 0);\n    }\n    for (index++; index < scopes.length;) {\n        const next = scopes[index];\n        const { 0: l, 1: c } = next;\n        if (l > endLine || (l === endLine && c >= endColumn)) {\n            break;\n        }\n        index = _encodeOriginalScopes(scopes, index, writer, state);\n    }\n    writer.write(comma);\n    state[0] = encodeInteger(writer, endLine, state[0]);\n    encodeInteger(writer, endColumn, 0);\n    return index;\n}\nfunction decodeGeneratedRanges(input) {\n    const { length } = input;\n    const reader = new StringReader(input);\n    const ranges = [];\n    const stack = [];\n    let genLine = 0;\n    let definitionSourcesIndex = 0;\n    let definitionScopeIndex = 0;\n    let callsiteSourcesIndex = 0;\n    let callsiteLine = 0;\n    let callsiteColumn = 0;\n    let bindingLine = 0;\n    let bindingColumn = 0;\n    do {\n        const semi = reader.indexOf(';');\n        let genColumn = 0;\n        for (; reader.pos < semi; reader.pos++) {\n            genColumn = decodeInteger(reader, genColumn);\n            if (!hasMoreVlq(reader, semi)) {\n                const last = stack.pop();\n                last[2] = genLine;\n                last[3] = genColumn;\n                continue;\n            }\n            const fields = decodeInteger(reader, 0);\n            const hasDefinition = fields & 0b0001;\n            const hasCallsite = fields & 0b0010;\n            const hasScope = fields & 0b0100;\n            let callsite = null;\n            let bindings = EMPTY;\n            let range;\n            if (hasDefinition) {\n                const defSourcesIndex = decodeInteger(reader, definitionSourcesIndex);\n                definitionScopeIndex = decodeInteger(reader, definitionSourcesIndex === defSourcesIndex ? definitionScopeIndex : 0);\n                definitionSourcesIndex = defSourcesIndex;\n                range = [genLine, genColumn, 0, 0, defSourcesIndex, definitionScopeIndex];\n            }\n            else {\n                range = [genLine, genColumn, 0, 0];\n            }\n            range.isScope = !!hasScope;\n            if (hasCallsite) {\n                const prevCsi = callsiteSourcesIndex;\n                const prevLine = callsiteLine;\n                callsiteSourcesIndex = decodeInteger(reader, callsiteSourcesIndex);\n                const sameSource = prevCsi === callsiteSourcesIndex;\n                callsiteLine = decodeInteger(reader, sameSource ? callsiteLine : 0);\n                callsiteColumn = decodeInteger(reader, sameSource && prevLine === callsiteLine ? callsiteColumn : 0);\n                callsite = [callsiteSourcesIndex, callsiteLine, callsiteColumn];\n            }\n            range.callsite = callsite;\n            if (hasMoreVlq(reader, semi)) {\n                bindings = [];\n                do {\n                    bindingLine = genLine;\n                    bindingColumn = genColumn;\n                    const expressionsCount = decodeInteger(reader, 0);\n                    let expressionRanges;\n                    if (expressionsCount < -1) {\n                        expressionRanges = [[decodeInteger(reader, 0)]];\n                        for (let i = -1; i > expressionsCount; i--) {\n                            const prevBl = bindingLine;\n                            bindingLine = decodeInteger(reader, bindingLine);\n                            bindingColumn = decodeInteger(reader, bindingLine === prevBl ? bindingColumn : 0);\n                            const expression = decodeInteger(reader, 0);\n                            expressionRanges.push([expression, bindingLine, bindingColumn]);\n                        }\n                    }\n                    else {\n                        expressionRanges = [[expressionsCount]];\n                    }\n                    bindings.push(expressionRanges);\n                } while (hasMoreVlq(reader, semi));\n            }\n            range.bindings = bindings;\n            ranges.push(range);\n            stack.push(range);\n        }\n        genLine++;\n        reader.pos = semi + 1;\n    } while (reader.pos < length);\n    return ranges;\n}\nfunction encodeGeneratedRanges(ranges) {\n    if (ranges.length === 0)\n        return '';\n    const writer = new StringWriter();\n    for (let i = 0; i < ranges.length;) {\n        i = _encodeGeneratedRanges(ranges, i, writer, [0, 0, 0, 0, 0, 0, 0]);\n    }\n    return writer.flush();\n}\nfunction _encodeGeneratedRanges(ranges, index, writer, state) {\n    const range = ranges[index];\n    const { 0: startLine, 1: startColumn, 2: endLine, 3: endColumn, isScope, callsite, bindings, } = range;\n    if (state[0] < startLine) {\n        catchupLine(writer, state[0], startLine);\n        state[0] = startLine;\n        state[1] = 0;\n    }\n    else if (index > 0) {\n        writer.write(comma);\n    }\n    state[1] = encodeInteger(writer, range[1], state[1]);\n    const fields = (range.length === 6 ? 0b0001 : 0) | (callsite ? 0b0010 : 0) | (isScope ? 0b0100 : 0);\n    encodeInteger(writer, fields, 0);\n    if (range.length === 6) {\n        const { 4: sourcesIndex, 5: scopesIndex } = range;\n        if (sourcesIndex !== state[2]) {\n            state[3] = 0;\n        }\n        state[2] = encodeInteger(writer, sourcesIndex, state[2]);\n        state[3] = encodeInteger(writer, scopesIndex, state[3]);\n    }\n    if (callsite) {\n        const { 0: sourcesIndex, 1: callLine, 2: callColumn } = range.callsite;\n        if (sourcesIndex !== state[4]) {\n            state[5] = 0;\n            state[6] = 0;\n        }\n        else if (callLine !== state[5]) {\n            state[6] = 0;\n        }\n        state[4] = encodeInteger(writer, sourcesIndex, state[4]);\n        state[5] = encodeInteger(writer, callLine, state[5]);\n        state[6] = encodeInteger(writer, callColumn, state[6]);\n    }\n    if (bindings) {\n        for (const binding of bindings) {\n            if (binding.length > 1)\n                encodeInteger(writer, -binding.length, 0);\n            const expression = binding[0][0];\n            encodeInteger(writer, expression, 0);\n            let bindingStartLine = startLine;\n            let bindingStartColumn = startColumn;\n            for (let i = 1; i < binding.length; i++) {\n                const expRange = binding[i];\n                bindingStartLine = encodeInteger(writer, expRange[1], bindingStartLine);\n                bindingStartColumn = encodeInteger(writer, expRange[2], bindingStartColumn);\n                encodeInteger(writer, expRange[0], 0);\n            }\n        }\n    }\n    for (index++; index < ranges.length;) {\n        const next = ranges[index];\n        const { 0: l, 1: c } = next;\n        if (l > endLine || (l === endLine && c >= endColumn)) {\n            break;\n        }\n        index = _encodeGeneratedRanges(ranges, index, writer, state);\n    }\n    if (state[0] < endLine) {\n        catchupLine(writer, state[0], endLine);\n        state[0] = endLine;\n        state[1] = 0;\n    }\n    else {\n        writer.write(comma);\n    }\n    state[1] = encodeInteger(writer, endColumn, state[1]);\n    return index;\n}\nfunction catchupLine(writer, lastLine, line) {\n    do {\n        writer.write(semicolon);\n    } while (++lastLine < line);\n}\n\nfunction decode(mappings) {\n    const { length } = mappings;\n    const reader = new StringReader(mappings);\n    const decoded = [];\n    let genColumn = 0;\n    let sourcesIndex = 0;\n    let sourceLine = 0;\n    let sourceColumn = 0;\n    let namesIndex = 0;\n    do {\n        const semi = reader.indexOf(';');\n        const line = [];\n        let sorted = true;\n        let lastCol = 0;\n        genColumn = 0;\n        while (reader.pos < semi) {\n            let seg;\n            genColumn = decodeInteger(reader, genColumn);\n            if (genColumn < lastCol)\n                sorted = false;\n            lastCol = genColumn;\n            if (hasMoreVlq(reader, semi)) {\n                sourcesIndex = decodeInteger(reader, sourcesIndex);\n                sourceLine = decodeInteger(reader, sourceLine);\n                sourceColumn = decodeInteger(reader, sourceColumn);\n                if (hasMoreVlq(reader, semi)) {\n                    namesIndex = decodeInteger(reader, namesIndex);\n                    seg = [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex];\n                }\n                else {\n                    seg = [genColumn, sourcesIndex, sourceLine, sourceColumn];\n                }\n            }\n            else {\n                seg = [genColumn];\n            }\n            line.push(seg);\n            reader.pos++;\n        }\n        if (!sorted)\n            sort(line);\n        decoded.push(line);\n        reader.pos = semi + 1;\n    } while (reader.pos <= length);\n    return decoded;\n}\nfunction sort(line) {\n    line.sort(sortComparator);\n}\nfunction sortComparator(a, b) {\n    return a[0] - b[0];\n}\nfunction encode(decoded) {\n    const writer = new StringWriter();\n    let sourcesIndex = 0;\n    let sourceLine = 0;\n    let sourceColumn = 0;\n    let namesIndex = 0;\n    for (let i = 0; i < decoded.length; i++) {\n        const line = decoded[i];\n        if (i > 0)\n            writer.write(semicolon);\n        if (line.length === 0)\n            continue;\n        let genColumn = 0;\n        for (let j = 0; j < line.length; j++) {\n            const segment = line[j];\n            if (j > 0)\n                writer.write(comma);\n            genColumn = encodeInteger(writer, segment[0], genColumn);\n            if (segment.length === 1)\n                continue;\n            sourcesIndex = encodeInteger(writer, segment[1], sourcesIndex);\n            sourceLine = encodeInteger(writer, segment[2], sourceLine);\n            sourceColumn = encodeInteger(writer, segment[3], sourceColumn);\n            if (segment.length === 4)\n                continue;\n            namesIndex = encodeInteger(writer, segment[4], namesIndex);\n        }\n    }\n    return writer.flush();\n}\n\n\n//# sourceMappingURL=sourcemap-codec.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BqcmlkZ2V3ZWxsL3NvdXJjZW1hcC1jb2RlYy9kaXN0L3NvdXJjZW1hcC1jb2RlYy5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxzQ0FBc0M7QUFDdEMsdUNBQXVDO0FBQ3ZDLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdCQUFnQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3RUFBd0U7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsc0JBQXNCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVGQUF1RjtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0NBQWtDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDhDQUE4QztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixvQkFBb0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW9IO0FBQ3BIIiwic291cmNlcyI6WyIvVXNlcnMvbWFya3VzaG9nbmUvRG9jdW1lbnRzL0FQUFMvYmF6YWFyLXZpZC9iYXphYXItdmlkL25vZGVfbW9kdWxlcy9AanJpZGdld2VsbC9zb3VyY2VtYXAtY29kZWMvZGlzdC9zb3VyY2VtYXAtY29kZWMubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNvbW1hID0gJywnLmNoYXJDb2RlQXQoMCk7XG5jb25zdCBzZW1pY29sb24gPSAnOycuY2hhckNvZGVBdCgwKTtcbmNvbnN0IGNoYXJzID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuY29uc3QgaW50VG9DaGFyID0gbmV3IFVpbnQ4QXJyYXkoNjQpOyAvLyA2NCBwb3NzaWJsZSBjaGFycy5cbmNvbnN0IGNoYXJUb0ludCA9IG5ldyBVaW50OEFycmF5KDEyOCk7IC8vIHogaXMgMTIyIGluIEFTQ0lJXG5mb3IgKGxldCBpID0gMDsgaSA8IGNoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYyA9IGNoYXJzLmNoYXJDb2RlQXQoaSk7XG4gICAgaW50VG9DaGFyW2ldID0gYztcbiAgICBjaGFyVG9JbnRbY10gPSBpO1xufVxuZnVuY3Rpb24gZGVjb2RlSW50ZWdlcihyZWFkZXIsIHJlbGF0aXZlKSB7XG4gICAgbGV0IHZhbHVlID0gMDtcbiAgICBsZXQgc2hpZnQgPSAwO1xuICAgIGxldCBpbnRlZ2VyID0gMDtcbiAgICBkbyB7XG4gICAgICAgIGNvbnN0IGMgPSByZWFkZXIubmV4dCgpO1xuICAgICAgICBpbnRlZ2VyID0gY2hhclRvSW50W2NdO1xuICAgICAgICB2YWx1ZSB8PSAoaW50ZWdlciAmIDMxKSA8PCBzaGlmdDtcbiAgICAgICAgc2hpZnQgKz0gNTtcbiAgICB9IHdoaWxlIChpbnRlZ2VyICYgMzIpO1xuICAgIGNvbnN0IHNob3VsZE5lZ2F0ZSA9IHZhbHVlICYgMTtcbiAgICB2YWx1ZSA+Pj49IDE7XG4gICAgaWYgKHNob3VsZE5lZ2F0ZSkge1xuICAgICAgICB2YWx1ZSA9IC0weDgwMDAwMDAwIHwgLXZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVsYXRpdmUgKyB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGVuY29kZUludGVnZXIoYnVpbGRlciwgbnVtLCByZWxhdGl2ZSkge1xuICAgIGxldCBkZWx0YSA9IG51bSAtIHJlbGF0aXZlO1xuICAgIGRlbHRhID0gZGVsdGEgPCAwID8gKC1kZWx0YSA8PCAxKSB8IDEgOiBkZWx0YSA8PCAxO1xuICAgIGRvIHtcbiAgICAgICAgbGV0IGNsYW1wZWQgPSBkZWx0YSAmIDBiMDExMTExO1xuICAgICAgICBkZWx0YSA+Pj49IDU7XG4gICAgICAgIGlmIChkZWx0YSA+IDApXG4gICAgICAgICAgICBjbGFtcGVkIHw9IDBiMTAwMDAwO1xuICAgICAgICBidWlsZGVyLndyaXRlKGludFRvQ2hhcltjbGFtcGVkXSk7XG4gICAgfSB3aGlsZSAoZGVsdGEgPiAwKTtcbiAgICByZXR1cm4gbnVtO1xufVxuZnVuY3Rpb24gaGFzTW9yZVZscShyZWFkZXIsIG1heCkge1xuICAgIGlmIChyZWFkZXIucG9zID49IG1heClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiByZWFkZXIucGVlaygpICE9PSBjb21tYTtcbn1cblxuY29uc3QgYnVmTGVuZ3RoID0gMTAyNCAqIDE2O1xuLy8gUHJvdmlkZSBhIGZhbGxiYWNrIGZvciBvbGRlciBlbnZpcm9ubWVudHMuXG5jb25zdCB0ZCA9IHR5cGVvZiBUZXh0RGVjb2RlciAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IC8qICNfX1BVUkVfXyAqLyBuZXcgVGV4dERlY29kZXIoKVxuICAgIDogdHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyB7XG4gICAgICAgICAgICBkZWNvZGUoYnVmKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0ID0gQnVmZmVyLmZyb20oYnVmLmJ1ZmZlciwgYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9XG4gICAgICAgIDoge1xuICAgICAgICAgICAgZGVjb2RlKGJ1Zikge1xuICAgICAgICAgICAgICAgIGxldCBvdXQgPSAnJztcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbmNsYXNzIFN0cmluZ1dyaXRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5vdXQgPSAnJztcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheShidWZMZW5ndGgpO1xuICAgIH1cbiAgICB3cml0ZSh2KSB7XG4gICAgICAgIGNvbnN0IHsgYnVmZmVyIH0gPSB0aGlzO1xuICAgICAgICBidWZmZXJbdGhpcy5wb3MrK10gPSB2O1xuICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJ1Zkxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5vdXQgKz0gdGQuZGVjb2RlKGJ1ZmZlcik7XG4gICAgICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmx1c2goKSB7XG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCBvdXQsIHBvcyB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHBvcyA+IDAgPyBvdXQgKyB0ZC5kZWNvZGUoYnVmZmVyLnN1YmFycmF5KDAsIHBvcykpIDogb3V0O1xuICAgIH1cbn1cbmNsYXNzIFN0cmluZ1JlYWRlciB7XG4gICAgY29uc3RydWN0b3IoYnVmZmVyKSB7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5jaGFyQ29kZUF0KHRoaXMucG9zKyspO1xuICAgIH1cbiAgICBwZWVrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIuY2hhckNvZGVBdCh0aGlzLnBvcyk7XG4gICAgfVxuICAgIGluZGV4T2YoY2hhcikge1xuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgcG9zIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBpZHggPSBidWZmZXIuaW5kZXhPZihjaGFyLCBwb3MpO1xuICAgICAgICByZXR1cm4gaWR4ID09PSAtMSA/IGJ1ZmZlci5sZW5ndGggOiBpZHg7XG4gICAgfVxufVxuXG5jb25zdCBFTVBUWSA9IFtdO1xuZnVuY3Rpb24gZGVjb2RlT3JpZ2luYWxTY29wZXMoaW5wdXQpIHtcbiAgICBjb25zdCB7IGxlbmd0aCB9ID0gaW5wdXQ7XG4gICAgY29uc3QgcmVhZGVyID0gbmV3IFN0cmluZ1JlYWRlcihpbnB1dCk7XG4gICAgY29uc3Qgc2NvcGVzID0gW107XG4gICAgY29uc3Qgc3RhY2sgPSBbXTtcbiAgICBsZXQgbGluZSA9IDA7XG4gICAgZm9yICg7IHJlYWRlci5wb3MgPCBsZW5ndGg7IHJlYWRlci5wb3MrKykge1xuICAgICAgICBsaW5lID0gZGVjb2RlSW50ZWdlcihyZWFkZXIsIGxpbmUpO1xuICAgICAgICBjb25zdCBjb2x1bW4gPSBkZWNvZGVJbnRlZ2VyKHJlYWRlciwgMCk7XG4gICAgICAgIGlmICghaGFzTW9yZVZscShyZWFkZXIsIGxlbmd0aCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3QgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGxhc3RbMl0gPSBsaW5lO1xuICAgICAgICAgICAgbGFzdFszXSA9IGNvbHVtbjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtpbmQgPSBkZWNvZGVJbnRlZ2VyKHJlYWRlciwgMCk7XG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IGRlY29kZUludGVnZXIocmVhZGVyLCAwKTtcbiAgICAgICAgY29uc3QgaGFzTmFtZSA9IGZpZWxkcyAmIDBiMDAwMTtcbiAgICAgICAgY29uc3Qgc2NvcGUgPSAoaGFzTmFtZSA/IFtsaW5lLCBjb2x1bW4sIDAsIDAsIGtpbmQsIGRlY29kZUludGVnZXIocmVhZGVyLCAwKV0gOiBbbGluZSwgY29sdW1uLCAwLCAwLCBraW5kXSk7XG4gICAgICAgIGxldCB2YXJzID0gRU1QVFk7XG4gICAgICAgIGlmIChoYXNNb3JlVmxxKHJlYWRlciwgbGVuZ3RoKSkge1xuICAgICAgICAgICAgdmFycyA9IFtdO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhcnNJbmRleCA9IGRlY29kZUludGVnZXIocmVhZGVyLCAwKTtcbiAgICAgICAgICAgICAgICB2YXJzLnB1c2godmFyc0luZGV4KTtcbiAgICAgICAgICAgIH0gd2hpbGUgKGhhc01vcmVWbHEocmVhZGVyLCBsZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICBzY29wZS52YXJzID0gdmFycztcbiAgICAgICAgc2NvcGVzLnB1c2goc2NvcGUpO1xuICAgICAgICBzdGFjay5wdXNoKHNjb3BlKTtcbiAgICB9XG4gICAgcmV0dXJuIHNjb3Blcztcbn1cbmZ1bmN0aW9uIGVuY29kZU9yaWdpbmFsU2NvcGVzKHNjb3Blcykge1xuICAgIGNvbnN0IHdyaXRlciA9IG5ldyBTdHJpbmdXcml0ZXIoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNjb3Blcy5sZW5ndGg7KSB7XG4gICAgICAgIGkgPSBfZW5jb2RlT3JpZ2luYWxTY29wZXMoc2NvcGVzLCBpLCB3cml0ZXIsIFswXSk7XG4gICAgfVxuICAgIHJldHVybiB3cml0ZXIuZmx1c2goKTtcbn1cbmZ1bmN0aW9uIF9lbmNvZGVPcmlnaW5hbFNjb3BlcyhzY29wZXMsIGluZGV4LCB3cml0ZXIsIHN0YXRlKSB7XG4gICAgY29uc3Qgc2NvcGUgPSBzY29wZXNbaW5kZXhdO1xuICAgIGNvbnN0IHsgMDogc3RhcnRMaW5lLCAxOiBzdGFydENvbHVtbiwgMjogZW5kTGluZSwgMzogZW5kQ29sdW1uLCA0OiBraW5kLCB2YXJzIH0gPSBzY29wZTtcbiAgICBpZiAoaW5kZXggPiAwKVxuICAgICAgICB3cml0ZXIud3JpdGUoY29tbWEpO1xuICAgIHN0YXRlWzBdID0gZW5jb2RlSW50ZWdlcih3cml0ZXIsIHN0YXJ0TGluZSwgc3RhdGVbMF0pO1xuICAgIGVuY29kZUludGVnZXIod3JpdGVyLCBzdGFydENvbHVtbiwgMCk7XG4gICAgZW5jb2RlSW50ZWdlcih3cml0ZXIsIGtpbmQsIDApO1xuICAgIGNvbnN0IGZpZWxkcyA9IHNjb3BlLmxlbmd0aCA9PT0gNiA/IDBiMDAwMSA6IDA7XG4gICAgZW5jb2RlSW50ZWdlcih3cml0ZXIsIGZpZWxkcywgMCk7XG4gICAgaWYgKHNjb3BlLmxlbmd0aCA9PT0gNilcbiAgICAgICAgZW5jb2RlSW50ZWdlcih3cml0ZXIsIHNjb3BlWzVdLCAwKTtcbiAgICBmb3IgKGNvbnN0IHYgb2YgdmFycykge1xuICAgICAgICBlbmNvZGVJbnRlZ2VyKHdyaXRlciwgdiwgMCk7XG4gICAgfVxuICAgIGZvciAoaW5kZXgrKzsgaW5kZXggPCBzY29wZXMubGVuZ3RoOykge1xuICAgICAgICBjb25zdCBuZXh0ID0gc2NvcGVzW2luZGV4XTtcbiAgICAgICAgY29uc3QgeyAwOiBsLCAxOiBjIH0gPSBuZXh0O1xuICAgICAgICBpZiAobCA+IGVuZExpbmUgfHwgKGwgPT09IGVuZExpbmUgJiYgYyA+PSBlbmRDb2x1bW4pKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IF9lbmNvZGVPcmlnaW5hbFNjb3BlcyhzY29wZXMsIGluZGV4LCB3cml0ZXIsIHN0YXRlKTtcbiAgICB9XG4gICAgd3JpdGVyLndyaXRlKGNvbW1hKTtcbiAgICBzdGF0ZVswXSA9IGVuY29kZUludGVnZXIod3JpdGVyLCBlbmRMaW5lLCBzdGF0ZVswXSk7XG4gICAgZW5jb2RlSW50ZWdlcih3cml0ZXIsIGVuZENvbHVtbiwgMCk7XG4gICAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gZGVjb2RlR2VuZXJhdGVkUmFuZ2VzKGlucHV0KSB7XG4gICAgY29uc3QgeyBsZW5ndGggfSA9IGlucHV0O1xuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBTdHJpbmdSZWFkZXIoaW5wdXQpO1xuICAgIGNvbnN0IHJhbmdlcyA9IFtdO1xuICAgIGNvbnN0IHN0YWNrID0gW107XG4gICAgbGV0IGdlbkxpbmUgPSAwO1xuICAgIGxldCBkZWZpbml0aW9uU291cmNlc0luZGV4ID0gMDtcbiAgICBsZXQgZGVmaW5pdGlvblNjb3BlSW5kZXggPSAwO1xuICAgIGxldCBjYWxsc2l0ZVNvdXJjZXNJbmRleCA9IDA7XG4gICAgbGV0IGNhbGxzaXRlTGluZSA9IDA7XG4gICAgbGV0IGNhbGxzaXRlQ29sdW1uID0gMDtcbiAgICBsZXQgYmluZGluZ0xpbmUgPSAwO1xuICAgIGxldCBiaW5kaW5nQ29sdW1uID0gMDtcbiAgICBkbyB7XG4gICAgICAgIGNvbnN0IHNlbWkgPSByZWFkZXIuaW5kZXhPZignOycpO1xuICAgICAgICBsZXQgZ2VuQ29sdW1uID0gMDtcbiAgICAgICAgZm9yICg7IHJlYWRlci5wb3MgPCBzZW1pOyByZWFkZXIucG9zKyspIHtcbiAgICAgICAgICAgIGdlbkNvbHVtbiA9IGRlY29kZUludGVnZXIocmVhZGVyLCBnZW5Db2x1bW4pO1xuICAgICAgICAgICAgaWYgKCFoYXNNb3JlVmxxKHJlYWRlciwgc2VtaSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXN0ID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgbGFzdFsyXSA9IGdlbkxpbmU7XG4gICAgICAgICAgICAgICAgbGFzdFszXSA9IGdlbkNvbHVtbjtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZpZWxkcyA9IGRlY29kZUludGVnZXIocmVhZGVyLCAwKTtcbiAgICAgICAgICAgIGNvbnN0IGhhc0RlZmluaXRpb24gPSBmaWVsZHMgJiAwYjAwMDE7XG4gICAgICAgICAgICBjb25zdCBoYXNDYWxsc2l0ZSA9IGZpZWxkcyAmIDBiMDAxMDtcbiAgICAgICAgICAgIGNvbnN0IGhhc1Njb3BlID0gZmllbGRzICYgMGIwMTAwO1xuICAgICAgICAgICAgbGV0IGNhbGxzaXRlID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBiaW5kaW5ncyA9IEVNUFRZO1xuICAgICAgICAgICAgbGV0IHJhbmdlO1xuICAgICAgICAgICAgaWYgKGhhc0RlZmluaXRpb24pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWZTb3VyY2VzSW5kZXggPSBkZWNvZGVJbnRlZ2VyKHJlYWRlciwgZGVmaW5pdGlvblNvdXJjZXNJbmRleCk7XG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvblNjb3BlSW5kZXggPSBkZWNvZGVJbnRlZ2VyKHJlYWRlciwgZGVmaW5pdGlvblNvdXJjZXNJbmRleCA9PT0gZGVmU291cmNlc0luZGV4ID8gZGVmaW5pdGlvblNjb3BlSW5kZXggOiAwKTtcbiAgICAgICAgICAgICAgICBkZWZpbml0aW9uU291cmNlc0luZGV4ID0gZGVmU291cmNlc0luZGV4O1xuICAgICAgICAgICAgICAgIHJhbmdlID0gW2dlbkxpbmUsIGdlbkNvbHVtbiwgMCwgMCwgZGVmU291cmNlc0luZGV4LCBkZWZpbml0aW9uU2NvcGVJbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByYW5nZSA9IFtnZW5MaW5lLCBnZW5Db2x1bW4sIDAsIDBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmFuZ2UuaXNTY29wZSA9ICEhaGFzU2NvcGU7XG4gICAgICAgICAgICBpZiAoaGFzQ2FsbHNpdGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2Q3NpID0gY2FsbHNpdGVTb3VyY2VzSW5kZXg7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldkxpbmUgPSBjYWxsc2l0ZUxpbmU7XG4gICAgICAgICAgICAgICAgY2FsbHNpdGVTb3VyY2VzSW5kZXggPSBkZWNvZGVJbnRlZ2VyKHJlYWRlciwgY2FsbHNpdGVTb3VyY2VzSW5kZXgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNhbWVTb3VyY2UgPSBwcmV2Q3NpID09PSBjYWxsc2l0ZVNvdXJjZXNJbmRleDtcbiAgICAgICAgICAgICAgICBjYWxsc2l0ZUxpbmUgPSBkZWNvZGVJbnRlZ2VyKHJlYWRlciwgc2FtZVNvdXJjZSA/IGNhbGxzaXRlTGluZSA6IDApO1xuICAgICAgICAgICAgICAgIGNhbGxzaXRlQ29sdW1uID0gZGVjb2RlSW50ZWdlcihyZWFkZXIsIHNhbWVTb3VyY2UgJiYgcHJldkxpbmUgPT09IGNhbGxzaXRlTGluZSA/IGNhbGxzaXRlQ29sdW1uIDogMCk7XG4gICAgICAgICAgICAgICAgY2FsbHNpdGUgPSBbY2FsbHNpdGVTb3VyY2VzSW5kZXgsIGNhbGxzaXRlTGluZSwgY2FsbHNpdGVDb2x1bW5dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmFuZ2UuY2FsbHNpdGUgPSBjYWxsc2l0ZTtcbiAgICAgICAgICAgIGlmIChoYXNNb3JlVmxxKHJlYWRlciwgc2VtaSkpIHtcbiAgICAgICAgICAgICAgICBiaW5kaW5ncyA9IFtdO1xuICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgYmluZGluZ0xpbmUgPSBnZW5MaW5lO1xuICAgICAgICAgICAgICAgICAgICBiaW5kaW5nQ29sdW1uID0gZ2VuQ29sdW1uO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBleHByZXNzaW9uc0NvdW50ID0gZGVjb2RlSW50ZWdlcihyZWFkZXIsIDApO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZXhwcmVzc2lvblJhbmdlcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHJlc3Npb25zQ291bnQgPCAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvblJhbmdlcyA9IFtbZGVjb2RlSW50ZWdlcihyZWFkZXIsIDApXV07XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gLTE7IGkgPiBleHByZXNzaW9uc0NvdW50OyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2QmwgPSBiaW5kaW5nTGluZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiaW5kaW5nTGluZSA9IGRlY29kZUludGVnZXIocmVhZGVyLCBiaW5kaW5nTGluZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmluZGluZ0NvbHVtbiA9IGRlY29kZUludGVnZXIocmVhZGVyLCBiaW5kaW5nTGluZSA9PT0gcHJldkJsID8gYmluZGluZ0NvbHVtbiA6IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4cHJlc3Npb24gPSBkZWNvZGVJbnRlZ2VyKHJlYWRlciwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvblJhbmdlcy5wdXNoKFtleHByZXNzaW9uLCBiaW5kaW5nTGluZSwgYmluZGluZ0NvbHVtbl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwcmVzc2lvblJhbmdlcyA9IFtbZXhwcmVzc2lvbnNDb3VudF1dO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJpbmRpbmdzLnB1c2goZXhwcmVzc2lvblJhbmdlcyk7XG4gICAgICAgICAgICAgICAgfSB3aGlsZSAoaGFzTW9yZVZscShyZWFkZXIsIHNlbWkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJhbmdlLmJpbmRpbmdzID0gYmluZGluZ3M7XG4gICAgICAgICAgICByYW5nZXMucHVzaChyYW5nZSk7XG4gICAgICAgICAgICBzdGFjay5wdXNoKHJhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBnZW5MaW5lKys7XG4gICAgICAgIHJlYWRlci5wb3MgPSBzZW1pICsgMTtcbiAgICB9IHdoaWxlIChyZWFkZXIucG9zIDwgbGVuZ3RoKTtcbiAgICByZXR1cm4gcmFuZ2VzO1xufVxuZnVuY3Rpb24gZW5jb2RlR2VuZXJhdGVkUmFuZ2VzKHJhbmdlcykge1xuICAgIGlmIChyYW5nZXMubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgY29uc3Qgd3JpdGVyID0gbmV3IFN0cmluZ1dyaXRlcigpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDspIHtcbiAgICAgICAgaSA9IF9lbmNvZGVHZW5lcmF0ZWRSYW5nZXMocmFuZ2VzLCBpLCB3cml0ZXIsIFswLCAwLCAwLCAwLCAwLCAwLCAwXSk7XG4gICAgfVxuICAgIHJldHVybiB3cml0ZXIuZmx1c2goKTtcbn1cbmZ1bmN0aW9uIF9lbmNvZGVHZW5lcmF0ZWRSYW5nZXMocmFuZ2VzLCBpbmRleCwgd3JpdGVyLCBzdGF0ZSkge1xuICAgIGNvbnN0IHJhbmdlID0gcmFuZ2VzW2luZGV4XTtcbiAgICBjb25zdCB7IDA6IHN0YXJ0TGluZSwgMTogc3RhcnRDb2x1bW4sIDI6IGVuZExpbmUsIDM6IGVuZENvbHVtbiwgaXNTY29wZSwgY2FsbHNpdGUsIGJpbmRpbmdzLCB9ID0gcmFuZ2U7XG4gICAgaWYgKHN0YXRlWzBdIDwgc3RhcnRMaW5lKSB7XG4gICAgICAgIGNhdGNodXBMaW5lKHdyaXRlciwgc3RhdGVbMF0sIHN0YXJ0TGluZSk7XG4gICAgICAgIHN0YXRlWzBdID0gc3RhcnRMaW5lO1xuICAgICAgICBzdGF0ZVsxXSA9IDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKGluZGV4ID4gMCkge1xuICAgICAgICB3cml0ZXIud3JpdGUoY29tbWEpO1xuICAgIH1cbiAgICBzdGF0ZVsxXSA9IGVuY29kZUludGVnZXIod3JpdGVyLCByYW5nZVsxXSwgc3RhdGVbMV0pO1xuICAgIGNvbnN0IGZpZWxkcyA9IChyYW5nZS5sZW5ndGggPT09IDYgPyAwYjAwMDEgOiAwKSB8IChjYWxsc2l0ZSA/IDBiMDAxMCA6IDApIHwgKGlzU2NvcGUgPyAwYjAxMDAgOiAwKTtcbiAgICBlbmNvZGVJbnRlZ2VyKHdyaXRlciwgZmllbGRzLCAwKTtcbiAgICBpZiAocmFuZ2UubGVuZ3RoID09PSA2KSB7XG4gICAgICAgIGNvbnN0IHsgNDogc291cmNlc0luZGV4LCA1OiBzY29wZXNJbmRleCB9ID0gcmFuZ2U7XG4gICAgICAgIGlmIChzb3VyY2VzSW5kZXggIT09IHN0YXRlWzJdKSB7XG4gICAgICAgICAgICBzdGF0ZVszXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGVbMl0gPSBlbmNvZGVJbnRlZ2VyKHdyaXRlciwgc291cmNlc0luZGV4LCBzdGF0ZVsyXSk7XG4gICAgICAgIHN0YXRlWzNdID0gZW5jb2RlSW50ZWdlcih3cml0ZXIsIHNjb3Blc0luZGV4LCBzdGF0ZVszXSk7XG4gICAgfVxuICAgIGlmIChjYWxsc2l0ZSkge1xuICAgICAgICBjb25zdCB7IDA6IHNvdXJjZXNJbmRleCwgMTogY2FsbExpbmUsIDI6IGNhbGxDb2x1bW4gfSA9IHJhbmdlLmNhbGxzaXRlO1xuICAgICAgICBpZiAoc291cmNlc0luZGV4ICE9PSBzdGF0ZVs0XSkge1xuICAgICAgICAgICAgc3RhdGVbNV0gPSAwO1xuICAgICAgICAgICAgc3RhdGVbNl0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNhbGxMaW5lICE9PSBzdGF0ZVs1XSkge1xuICAgICAgICAgICAgc3RhdGVbNl0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlWzRdID0gZW5jb2RlSW50ZWdlcih3cml0ZXIsIHNvdXJjZXNJbmRleCwgc3RhdGVbNF0pO1xuICAgICAgICBzdGF0ZVs1XSA9IGVuY29kZUludGVnZXIod3JpdGVyLCBjYWxsTGluZSwgc3RhdGVbNV0pO1xuICAgICAgICBzdGF0ZVs2XSA9IGVuY29kZUludGVnZXIod3JpdGVyLCBjYWxsQ29sdW1uLCBzdGF0ZVs2XSk7XG4gICAgfVxuICAgIGlmIChiaW5kaW5ncykge1xuICAgICAgICBmb3IgKGNvbnN0IGJpbmRpbmcgb2YgYmluZGluZ3MpIHtcbiAgICAgICAgICAgIGlmIChiaW5kaW5nLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICAgICAgZW5jb2RlSW50ZWdlcih3cml0ZXIsIC1iaW5kaW5nLmxlbmd0aCwgMCk7XG4gICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gYmluZGluZ1swXVswXTtcbiAgICAgICAgICAgIGVuY29kZUludGVnZXIod3JpdGVyLCBleHByZXNzaW9uLCAwKTtcbiAgICAgICAgICAgIGxldCBiaW5kaW5nU3RhcnRMaW5lID0gc3RhcnRMaW5lO1xuICAgICAgICAgICAgbGV0IGJpbmRpbmdTdGFydENvbHVtbiA9IHN0YXJ0Q29sdW1uO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBiaW5kaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhwUmFuZ2UgPSBiaW5kaW5nW2ldO1xuICAgICAgICAgICAgICAgIGJpbmRpbmdTdGFydExpbmUgPSBlbmNvZGVJbnRlZ2VyKHdyaXRlciwgZXhwUmFuZ2VbMV0sIGJpbmRpbmdTdGFydExpbmUpO1xuICAgICAgICAgICAgICAgIGJpbmRpbmdTdGFydENvbHVtbiA9IGVuY29kZUludGVnZXIod3JpdGVyLCBleHBSYW5nZVsyXSwgYmluZGluZ1N0YXJ0Q29sdW1uKTtcbiAgICAgICAgICAgICAgICBlbmNvZGVJbnRlZ2VyKHdyaXRlciwgZXhwUmFuZ2VbMF0sIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoaW5kZXgrKzsgaW5kZXggPCByYW5nZXMubGVuZ3RoOykge1xuICAgICAgICBjb25zdCBuZXh0ID0gcmFuZ2VzW2luZGV4XTtcbiAgICAgICAgY29uc3QgeyAwOiBsLCAxOiBjIH0gPSBuZXh0O1xuICAgICAgICBpZiAobCA+IGVuZExpbmUgfHwgKGwgPT09IGVuZExpbmUgJiYgYyA+PSBlbmRDb2x1bW4pKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpbmRleCA9IF9lbmNvZGVHZW5lcmF0ZWRSYW5nZXMocmFuZ2VzLCBpbmRleCwgd3JpdGVyLCBzdGF0ZSk7XG4gICAgfVxuICAgIGlmIChzdGF0ZVswXSA8IGVuZExpbmUpIHtcbiAgICAgICAgY2F0Y2h1cExpbmUod3JpdGVyLCBzdGF0ZVswXSwgZW5kTGluZSk7XG4gICAgICAgIHN0YXRlWzBdID0gZW5kTGluZTtcbiAgICAgICAgc3RhdGVbMV0gPSAwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgd3JpdGVyLndyaXRlKGNvbW1hKTtcbiAgICB9XG4gICAgc3RhdGVbMV0gPSBlbmNvZGVJbnRlZ2VyKHdyaXRlciwgZW5kQ29sdW1uLCBzdGF0ZVsxXSk7XG4gICAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gY2F0Y2h1cExpbmUod3JpdGVyLCBsYXN0TGluZSwgbGluZSkge1xuICAgIGRvIHtcbiAgICAgICAgd3JpdGVyLndyaXRlKHNlbWljb2xvbik7XG4gICAgfSB3aGlsZSAoKytsYXN0TGluZSA8IGxpbmUpO1xufVxuXG5mdW5jdGlvbiBkZWNvZGUobWFwcGluZ3MpIHtcbiAgICBjb25zdCB7IGxlbmd0aCB9ID0gbWFwcGluZ3M7XG4gICAgY29uc3QgcmVhZGVyID0gbmV3IFN0cmluZ1JlYWRlcihtYXBwaW5ncyk7XG4gICAgY29uc3QgZGVjb2RlZCA9IFtdO1xuICAgIGxldCBnZW5Db2x1bW4gPSAwO1xuICAgIGxldCBzb3VyY2VzSW5kZXggPSAwO1xuICAgIGxldCBzb3VyY2VMaW5lID0gMDtcbiAgICBsZXQgc291cmNlQ29sdW1uID0gMDtcbiAgICBsZXQgbmFtZXNJbmRleCA9IDA7XG4gICAgZG8ge1xuICAgICAgICBjb25zdCBzZW1pID0gcmVhZGVyLmluZGV4T2YoJzsnKTtcbiAgICAgICAgY29uc3QgbGluZSA9IFtdO1xuICAgICAgICBsZXQgc29ydGVkID0gdHJ1ZTtcbiAgICAgICAgbGV0IGxhc3RDb2wgPSAwO1xuICAgICAgICBnZW5Db2x1bW4gPSAwO1xuICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IHNlbWkpIHtcbiAgICAgICAgICAgIGxldCBzZWc7XG4gICAgICAgICAgICBnZW5Db2x1bW4gPSBkZWNvZGVJbnRlZ2VyKHJlYWRlciwgZ2VuQ29sdW1uKTtcbiAgICAgICAgICAgIGlmIChnZW5Db2x1bW4gPCBsYXN0Q29sKVxuICAgICAgICAgICAgICAgIHNvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgbGFzdENvbCA9IGdlbkNvbHVtbjtcbiAgICAgICAgICAgIGlmIChoYXNNb3JlVmxxKHJlYWRlciwgc2VtaSkpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2VzSW5kZXggPSBkZWNvZGVJbnRlZ2VyKHJlYWRlciwgc291cmNlc0luZGV4KTtcbiAgICAgICAgICAgICAgICBzb3VyY2VMaW5lID0gZGVjb2RlSW50ZWdlcihyZWFkZXIsIHNvdXJjZUxpbmUpO1xuICAgICAgICAgICAgICAgIHNvdXJjZUNvbHVtbiA9IGRlY29kZUludGVnZXIocmVhZGVyLCBzb3VyY2VDb2x1bW4pO1xuICAgICAgICAgICAgICAgIGlmIChoYXNNb3JlVmxxKHJlYWRlciwgc2VtaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZXNJbmRleCA9IGRlY29kZUludGVnZXIocmVhZGVyLCBuYW1lc0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgc2VnID0gW2dlbkNvbHVtbiwgc291cmNlc0luZGV4LCBzb3VyY2VMaW5lLCBzb3VyY2VDb2x1bW4sIG5hbWVzSW5kZXhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VnID0gW2dlbkNvbHVtbiwgc291cmNlc0luZGV4LCBzb3VyY2VMaW5lLCBzb3VyY2VDb2x1bW5dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlZyA9IFtnZW5Db2x1bW5dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGluZS5wdXNoKHNlZyk7XG4gICAgICAgICAgICByZWFkZXIucG9zKys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzb3J0ZWQpXG4gICAgICAgICAgICBzb3J0KGxpbmUpO1xuICAgICAgICBkZWNvZGVkLnB1c2gobGluZSk7XG4gICAgICAgIHJlYWRlci5wb3MgPSBzZW1pICsgMTtcbiAgICB9IHdoaWxlIChyZWFkZXIucG9zIDw9IGxlbmd0aCk7XG4gICAgcmV0dXJuIGRlY29kZWQ7XG59XG5mdW5jdGlvbiBzb3J0KGxpbmUpIHtcbiAgICBsaW5lLnNvcnQoc29ydENvbXBhcmF0b3IpO1xufVxuZnVuY3Rpb24gc29ydENvbXBhcmF0b3IoYSwgYikge1xuICAgIHJldHVybiBhWzBdIC0gYlswXTtcbn1cbmZ1bmN0aW9uIGVuY29kZShkZWNvZGVkKSB7XG4gICAgY29uc3Qgd3JpdGVyID0gbmV3IFN0cmluZ1dyaXRlcigpO1xuICAgIGxldCBzb3VyY2VzSW5kZXggPSAwO1xuICAgIGxldCBzb3VyY2VMaW5lID0gMDtcbiAgICBsZXQgc291cmNlQ29sdW1uID0gMDtcbiAgICBsZXQgbmFtZXNJbmRleCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWNvZGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGxpbmUgPSBkZWNvZGVkW2ldO1xuICAgICAgICBpZiAoaSA+IDApXG4gICAgICAgICAgICB3cml0ZXIud3JpdGUoc2VtaWNvbG9uKTtcbiAgICAgICAgaWYgKGxpbmUubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGxldCBnZW5Db2x1bW4gPSAwO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxpbmUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNlZ21lbnQgPSBsaW5lW2pdO1xuICAgICAgICAgICAgaWYgKGogPiAwKVxuICAgICAgICAgICAgICAgIHdyaXRlci53cml0ZShjb21tYSk7XG4gICAgICAgICAgICBnZW5Db2x1bW4gPSBlbmNvZGVJbnRlZ2VyKHdyaXRlciwgc2VnbWVudFswXSwgZ2VuQ29sdW1uKTtcbiAgICAgICAgICAgIGlmIChzZWdtZW50Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHNvdXJjZXNJbmRleCA9IGVuY29kZUludGVnZXIod3JpdGVyLCBzZWdtZW50WzFdLCBzb3VyY2VzSW5kZXgpO1xuICAgICAgICAgICAgc291cmNlTGluZSA9IGVuY29kZUludGVnZXIod3JpdGVyLCBzZWdtZW50WzJdLCBzb3VyY2VMaW5lKTtcbiAgICAgICAgICAgIHNvdXJjZUNvbHVtbiA9IGVuY29kZUludGVnZXIod3JpdGVyLCBzZWdtZW50WzNdLCBzb3VyY2VDb2x1bW4pO1xuICAgICAgICAgICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSA0KVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbmFtZXNJbmRleCA9IGVuY29kZUludGVnZXIod3JpdGVyLCBzZWdtZW50WzRdLCBuYW1lc0luZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gd3JpdGVyLmZsdXNoKCk7XG59XG5cbmV4cG9ydCB7IGRlY29kZSwgZGVjb2RlR2VuZXJhdGVkUmFuZ2VzLCBkZWNvZGVPcmlnaW5hbFNjb3BlcywgZW5jb2RlLCBlbmNvZGVHZW5lcmF0ZWRSYW5nZXMsIGVuY29kZU9yaWdpbmFsU2NvcGVzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zb3VyY2VtYXAtY29kZWMubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs\n");

/***/ }),

/***/ "(ssr)/../../node_modules/@jridgewell/trace-mapping/dist/trace-mapping.mjs":
/*!***************************************************************************!*\
  !*** ../../node_modules/@jridgewell/trace-mapping/dist/trace-mapping.mjs ***!
  \***************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnyMap: () => (/* binding */ AnyMap),\n/* harmony export */   GREATEST_LOWER_BOUND: () => (/* binding */ GREATEST_LOWER_BOUND),\n/* harmony export */   LEAST_UPPER_BOUND: () => (/* binding */ LEAST_UPPER_BOUND),\n/* harmony export */   TraceMap: () => (/* binding */ TraceMap),\n/* harmony export */   allGeneratedPositionsFor: () => (/* binding */ allGeneratedPositionsFor),\n/* harmony export */   decodedMap: () => (/* binding */ decodedMap),\n/* harmony export */   decodedMappings: () => (/* binding */ decodedMappings),\n/* harmony export */   eachMapping: () => (/* binding */ eachMapping),\n/* harmony export */   encodedMap: () => (/* binding */ encodedMap),\n/* harmony export */   encodedMappings: () => (/* binding */ encodedMappings),\n/* harmony export */   generatedPositionFor: () => (/* binding */ generatedPositionFor),\n/* harmony export */   isIgnored: () => (/* binding */ isIgnored),\n/* harmony export */   originalPositionFor: () => (/* binding */ originalPositionFor),\n/* harmony export */   presortedDecodedMap: () => (/* binding */ presortedDecodedMap),\n/* harmony export */   sourceContentFor: () => (/* binding */ sourceContentFor),\n/* harmony export */   traceSegment: () => (/* binding */ traceSegment)\n/* harmony export */ });\n/* harmony import */ var _jridgewell_sourcemap_codec__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @jridgewell/sourcemap-codec */ \"(ssr)/../../node_modules/@jridgewell/sourcemap-codec/dist/sourcemap-codec.mjs\");\n/* harmony import */ var _jridgewell_resolve_uri__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @jridgewell/resolve-uri */ \"(ssr)/../../node_modules/@jridgewell/resolve-uri/dist/resolve-uri.mjs\");\n\n\n\nfunction resolve(input, base) {\n    // The base is always treated as a directory, if it's not empty.\n    // https://github.com/mozilla/source-map/blob/8cb3ee57/lib/util.js#L327\n    // https://github.com/chromium/chromium/blob/da4adbb3/third_party/blink/renderer/devtools/front_end/sdk/SourceMap.js#L400-L401\n    if (base && !base.endsWith('/'))\n        base += '/';\n    return (0,_jridgewell_resolve_uri__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(input, base);\n}\n\n/**\n * Removes everything after the last \"/\", but leaves the slash.\n */\nfunction stripFilename(path) {\n    if (!path)\n        return '';\n    const index = path.lastIndexOf('/');\n    return path.slice(0, index + 1);\n}\n\nconst COLUMN = 0;\nconst SOURCES_INDEX = 1;\nconst SOURCE_LINE = 2;\nconst SOURCE_COLUMN = 3;\nconst NAMES_INDEX = 4;\nconst REV_GENERATED_LINE = 1;\nconst REV_GENERATED_COLUMN = 2;\n\nfunction maybeSort(mappings, owned) {\n    const unsortedIndex = nextUnsortedSegmentLine(mappings, 0);\n    if (unsortedIndex === mappings.length)\n        return mappings;\n    // If we own the array (meaning we parsed it from JSON), then we're free to directly mutate it. If\n    // not, we do not want to modify the consumer's input array.\n    if (!owned)\n        mappings = mappings.slice();\n    for (let i = unsortedIndex; i < mappings.length; i = nextUnsortedSegmentLine(mappings, i + 1)) {\n        mappings[i] = sortSegments(mappings[i], owned);\n    }\n    return mappings;\n}\nfunction nextUnsortedSegmentLine(mappings, start) {\n    for (let i = start; i < mappings.length; i++) {\n        if (!isSorted(mappings[i]))\n            return i;\n    }\n    return mappings.length;\n}\nfunction isSorted(line) {\n    for (let j = 1; j < line.length; j++) {\n        if (line[j][COLUMN] < line[j - 1][COLUMN]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction sortSegments(line, owned) {\n    if (!owned)\n        line = line.slice();\n    return line.sort(sortComparator);\n}\nfunction sortComparator(a, b) {\n    return a[COLUMN] - b[COLUMN];\n}\n\nlet found = false;\n/**\n * A binary search implementation that returns the index if a match is found.\n * If no match is found, then the left-index (the index associated with the item that comes just\n * before the desired index) is returned. To maintain proper sort order, a splice would happen at\n * the next index:\n *\n * ```js\n * const array = [1, 3];\n * const needle = 2;\n * const index = binarySearch(array, needle, (item, needle) => item - needle);\n *\n * assert.equal(index, 0);\n * array.splice(index + 1, 0, needle);\n * assert.deepEqual(array, [1, 2, 3]);\n * ```\n */\nfunction binarySearch(haystack, needle, low, high) {\n    while (low <= high) {\n        const mid = low + ((high - low) >> 1);\n        const cmp = haystack[mid][COLUMN] - needle;\n        if (cmp === 0) {\n            found = true;\n            return mid;\n        }\n        if (cmp < 0) {\n            low = mid + 1;\n        }\n        else {\n            high = mid - 1;\n        }\n    }\n    found = false;\n    return low - 1;\n}\nfunction upperBound(haystack, needle, index) {\n    for (let i = index + 1; i < haystack.length; index = i++) {\n        if (haystack[i][COLUMN] !== needle)\n            break;\n    }\n    return index;\n}\nfunction lowerBound(haystack, needle, index) {\n    for (let i = index - 1; i >= 0; index = i--) {\n        if (haystack[i][COLUMN] !== needle)\n            break;\n    }\n    return index;\n}\nfunction memoizedState() {\n    return {\n        lastKey: -1,\n        lastNeedle: -1,\n        lastIndex: -1,\n    };\n}\n/**\n * This overly complicated beast is just to record the last tested line/column and the resulting\n * index, allowing us to skip a few tests if mappings are monotonically increasing.\n */\nfunction memoizedBinarySearch(haystack, needle, state, key) {\n    const { lastKey, lastNeedle, lastIndex } = state;\n    let low = 0;\n    let high = haystack.length - 1;\n    if (key === lastKey) {\n        if (needle === lastNeedle) {\n            found = lastIndex !== -1 && haystack[lastIndex][COLUMN] === needle;\n            return lastIndex;\n        }\n        if (needle >= lastNeedle) {\n            // lastIndex may be -1 if the previous needle was not found.\n            low = lastIndex === -1 ? 0 : lastIndex;\n        }\n        else {\n            high = lastIndex;\n        }\n    }\n    state.lastKey = key;\n    state.lastNeedle = needle;\n    return (state.lastIndex = binarySearch(haystack, needle, low, high));\n}\n\n// Rebuilds the original source files, with mappings that are ordered by source line/column instead\n// of generated line/column.\nfunction buildBySources(decoded, memos) {\n    const sources = memos.map(buildNullArray);\n    for (let i = 0; i < decoded.length; i++) {\n        const line = decoded[i];\n        for (let j = 0; j < line.length; j++) {\n            const seg = line[j];\n            if (seg.length === 1)\n                continue;\n            const sourceIndex = seg[SOURCES_INDEX];\n            const sourceLine = seg[SOURCE_LINE];\n            const sourceColumn = seg[SOURCE_COLUMN];\n            const originalSource = sources[sourceIndex];\n            const originalLine = (originalSource[sourceLine] || (originalSource[sourceLine] = []));\n            const memo = memos[sourceIndex];\n            // The binary search either found a match, or it found the left-index just before where the\n            // segment should go. Either way, we want to insert after that. And there may be multiple\n            // generated segments associated with an original location, so there may need to move several\n            // indexes before we find where we need to insert.\n            let index = upperBound(originalLine, sourceColumn, memoizedBinarySearch(originalLine, sourceColumn, memo, sourceLine));\n            memo.lastIndex = ++index;\n            insert(originalLine, index, [sourceColumn, i, seg[COLUMN]]);\n        }\n    }\n    return sources;\n}\nfunction insert(array, index, value) {\n    for (let i = array.length; i > index; i--) {\n        array[i] = array[i - 1];\n    }\n    array[index] = value;\n}\n// Null arrays allow us to use ordered index keys without actually allocating contiguous memory like\n// a real array. We use a null-prototype object to avoid prototype pollution and deoptimizations.\n// Numeric properties on objects are magically sorted in ascending order by the engine regardless of\n// the insertion order. So, by setting any numeric keys, even out of order, we'll get ascending\n// order when iterating with for-in.\nfunction buildNullArray() {\n    return { __proto__: null };\n}\n\nconst AnyMap = function (map, mapUrl) {\n    const parsed = parse(map);\n    if (!('sections' in parsed)) {\n        return new TraceMap(parsed, mapUrl);\n    }\n    const mappings = [];\n    const sources = [];\n    const sourcesContent = [];\n    const names = [];\n    const ignoreList = [];\n    recurse(parsed, mapUrl, mappings, sources, sourcesContent, names, ignoreList, 0, 0, Infinity, Infinity);\n    const joined = {\n        version: 3,\n        file: parsed.file,\n        names,\n        sources,\n        sourcesContent,\n        mappings,\n        ignoreList,\n    };\n    return presortedDecodedMap(joined);\n};\nfunction parse(map) {\n    return typeof map === 'string' ? JSON.parse(map) : map;\n}\nfunction recurse(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {\n    const { sections } = input;\n    for (let i = 0; i < sections.length; i++) {\n        const { map, offset } = sections[i];\n        let sl = stopLine;\n        let sc = stopColumn;\n        if (i + 1 < sections.length) {\n            const nextOffset = sections[i + 1].offset;\n            sl = Math.min(stopLine, lineOffset + nextOffset.line);\n            if (sl === stopLine) {\n                sc = Math.min(stopColumn, columnOffset + nextOffset.column);\n            }\n            else if (sl < stopLine) {\n                sc = columnOffset + nextOffset.column;\n            }\n        }\n        addSection(map, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset + offset.line, columnOffset + offset.column, sl, sc);\n    }\n}\nfunction addSection(input, mapUrl, mappings, sources, sourcesContent, names, ignoreList, lineOffset, columnOffset, stopLine, stopColumn) {\n    const parsed = parse(input);\n    if ('sections' in parsed)\n        return recurse(...arguments);\n    const map = new TraceMap(parsed, mapUrl);\n    const sourcesOffset = sources.length;\n    const namesOffset = names.length;\n    const decoded = decodedMappings(map);\n    const { resolvedSources, sourcesContent: contents, ignoreList: ignores } = map;\n    append(sources, resolvedSources);\n    append(names, map.names);\n    if (contents)\n        append(sourcesContent, contents);\n    else\n        for (let i = 0; i < resolvedSources.length; i++)\n            sourcesContent.push(null);\n    if (ignores)\n        for (let i = 0; i < ignores.length; i++)\n            ignoreList.push(ignores[i] + sourcesOffset);\n    for (let i = 0; i < decoded.length; i++) {\n        const lineI = lineOffset + i;\n        // We can only add so many lines before we step into the range that the next section's map\n        // controls. When we get to the last line, then we'll start checking the segments to see if\n        // they've crossed into the column range. But it may not have any columns that overstep, so we\n        // still need to check that we don't overstep lines, too.\n        if (lineI > stopLine)\n            return;\n        // The out line may already exist in mappings (if we're continuing the line started by a\n        // previous section). Or, we may have jumped ahead several lines to start this section.\n        const out = getLine(mappings, lineI);\n        // On the 0th loop, the section's column offset shifts us forward. On all other lines (since the\n        // map can be multiple lines), it doesn't.\n        const cOffset = i === 0 ? columnOffset : 0;\n        const line = decoded[i];\n        for (let j = 0; j < line.length; j++) {\n            const seg = line[j];\n            const column = cOffset + seg[COLUMN];\n            // If this segment steps into the column range that the next section's map controls, we need\n            // to stop early.\n            if (lineI === stopLine && column >= stopColumn)\n                return;\n            if (seg.length === 1) {\n                out.push([column]);\n                continue;\n            }\n            const sourcesIndex = sourcesOffset + seg[SOURCES_INDEX];\n            const sourceLine = seg[SOURCE_LINE];\n            const sourceColumn = seg[SOURCE_COLUMN];\n            out.push(seg.length === 4\n                ? [column, sourcesIndex, sourceLine, sourceColumn]\n                : [column, sourcesIndex, sourceLine, sourceColumn, namesOffset + seg[NAMES_INDEX]]);\n        }\n    }\n}\nfunction append(arr, other) {\n    for (let i = 0; i < other.length; i++)\n        arr.push(other[i]);\n}\nfunction getLine(arr, index) {\n    for (let i = arr.length; i <= index; i++)\n        arr[i] = [];\n    return arr[index];\n}\n\nconst LINE_GTR_ZERO = '`line` must be greater than 0 (lines start at line 1)';\nconst COL_GTR_EQ_ZERO = '`column` must be greater than or equal to 0 (columns start at column 0)';\nconst LEAST_UPPER_BOUND = -1;\nconst GREATEST_LOWER_BOUND = 1;\nclass TraceMap {\n    constructor(map, mapUrl) {\n        const isString = typeof map === 'string';\n        if (!isString && map._decodedMemo)\n            return map;\n        const parsed = (isString ? JSON.parse(map) : map);\n        const { version, file, names, sourceRoot, sources, sourcesContent } = parsed;\n        this.version = version;\n        this.file = file;\n        this.names = names || [];\n        this.sourceRoot = sourceRoot;\n        this.sources = sources;\n        this.sourcesContent = sourcesContent;\n        this.ignoreList = parsed.ignoreList || parsed.x_google_ignoreList || undefined;\n        const from = resolve(sourceRoot || '', stripFilename(mapUrl));\n        this.resolvedSources = sources.map((s) => resolve(s || '', from));\n        const { mappings } = parsed;\n        if (typeof mappings === 'string') {\n            this._encoded = mappings;\n            this._decoded = undefined;\n        }\n        else {\n            this._encoded = undefined;\n            this._decoded = maybeSort(mappings, isString);\n        }\n        this._decodedMemo = memoizedState();\n        this._bySources = undefined;\n        this._bySourceMemos = undefined;\n    }\n}\n/**\n * Typescript doesn't allow friend access to private fields, so this just casts the map into a type\n * with public access modifiers.\n */\nfunction cast(map) {\n    return map;\n}\n/**\n * Returns the encoded (VLQ string) form of the SourceMap's mappings field.\n */\nfunction encodedMappings(map) {\n    var _a;\n    var _b;\n    return ((_a = (_b = cast(map))._encoded) !== null && _a !== void 0 ? _a : (_b._encoded = (0,_jridgewell_sourcemap_codec__WEBPACK_IMPORTED_MODULE_0__.encode)(cast(map)._decoded)));\n}\n/**\n * Returns the decoded (array of lines of segments) form of the SourceMap's mappings field.\n */\nfunction decodedMappings(map) {\n    var _a;\n    return ((_a = cast(map))._decoded || (_a._decoded = (0,_jridgewell_sourcemap_codec__WEBPACK_IMPORTED_MODULE_0__.decode)(cast(map)._encoded)));\n}\n/**\n * A low-level API to find the segment associated with a generated line/column (think, from a\n * stack trace). Line and column here are 0-based, unlike `originalPositionFor`.\n */\nfunction traceSegment(map, line, column) {\n    const decoded = decodedMappings(map);\n    // It's common for parent source maps to have pointers to lines that have no\n    // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n    if (line >= decoded.length)\n        return null;\n    const segments = decoded[line];\n    const index = traceSegmentInternal(segments, cast(map)._decodedMemo, line, column, GREATEST_LOWER_BOUND);\n    return index === -1 ? null : segments[index];\n}\n/**\n * A higher-level API to find the source/line/column associated with a generated line/column\n * (think, from a stack trace). Line is 1-based, but column is 0-based, due to legacy behavior in\n * `source-map` library.\n */\nfunction originalPositionFor(map, needle) {\n    let { line, column, bias } = needle;\n    line--;\n    if (line < 0)\n        throw new Error(LINE_GTR_ZERO);\n    if (column < 0)\n        throw new Error(COL_GTR_EQ_ZERO);\n    const decoded = decodedMappings(map);\n    // It's common for parent source maps to have pointers to lines that have no\n    // mapping (like a \"//# sourceMappingURL=\") at the end of the child file.\n    if (line >= decoded.length)\n        return OMapping(null, null, null, null);\n    const segments = decoded[line];\n    const index = traceSegmentInternal(segments, cast(map)._decodedMemo, line, column, bias || GREATEST_LOWER_BOUND);\n    if (index === -1)\n        return OMapping(null, null, null, null);\n    const segment = segments[index];\n    if (segment.length === 1)\n        return OMapping(null, null, null, null);\n    const { names, resolvedSources } = map;\n    return OMapping(resolvedSources[segment[SOURCES_INDEX]], segment[SOURCE_LINE] + 1, segment[SOURCE_COLUMN], segment.length === 5 ? names[segment[NAMES_INDEX]] : null);\n}\n/**\n * Finds the generated line/column position of the provided source/line/column source position.\n */\nfunction generatedPositionFor(map, needle) {\n    const { source, line, column, bias } = needle;\n    return generatedPosition(map, source, line, column, bias || GREATEST_LOWER_BOUND, false);\n}\n/**\n * Finds all generated line/column positions of the provided source/line/column source position.\n */\nfunction allGeneratedPositionsFor(map, needle) {\n    const { source, line, column, bias } = needle;\n    // SourceMapConsumer uses LEAST_UPPER_BOUND for some reason, so we follow suit.\n    return generatedPosition(map, source, line, column, bias || LEAST_UPPER_BOUND, true);\n}\n/**\n * Iterates each mapping in generated position order.\n */\nfunction eachMapping(map, cb) {\n    const decoded = decodedMappings(map);\n    const { names, resolvedSources } = map;\n    for (let i = 0; i < decoded.length; i++) {\n        const line = decoded[i];\n        for (let j = 0; j < line.length; j++) {\n            const seg = line[j];\n            const generatedLine = i + 1;\n            const generatedColumn = seg[0];\n            let source = null;\n            let originalLine = null;\n            let originalColumn = null;\n            let name = null;\n            if (seg.length !== 1) {\n                source = resolvedSources[seg[1]];\n                originalLine = seg[2] + 1;\n                originalColumn = seg[3];\n            }\n            if (seg.length === 5)\n                name = names[seg[4]];\n            cb({\n                generatedLine,\n                generatedColumn,\n                source,\n                originalLine,\n                originalColumn,\n                name,\n            });\n        }\n    }\n}\nfunction sourceIndex(map, source) {\n    const { sources, resolvedSources } = map;\n    let index = sources.indexOf(source);\n    if (index === -1)\n        index = resolvedSources.indexOf(source);\n    return index;\n}\n/**\n * Retrieves the source content for a particular source, if its found. Returns null if not.\n */\nfunction sourceContentFor(map, source) {\n    const { sourcesContent } = map;\n    if (sourcesContent == null)\n        return null;\n    const index = sourceIndex(map, source);\n    return index === -1 ? null : sourcesContent[index];\n}\n/**\n * Determines if the source is marked to ignore by the source map.\n */\nfunction isIgnored(map, source) {\n    const { ignoreList } = map;\n    if (ignoreList == null)\n        return false;\n    const index = sourceIndex(map, source);\n    return index === -1 ? false : ignoreList.includes(index);\n}\n/**\n * A helper that skips sorting of the input map's mappings array, which can be expensive for larger\n * maps.\n */\nfunction presortedDecodedMap(map, mapUrl) {\n    const tracer = new TraceMap(clone(map, []), mapUrl);\n    cast(tracer)._decoded = map.mappings;\n    return tracer;\n}\n/**\n * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nfunction decodedMap(map) {\n    return clone(map, decodedMappings(map));\n}\n/**\n * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nfunction encodedMap(map) {\n    return clone(map, encodedMappings(map));\n}\nfunction clone(map, mappings) {\n    return {\n        version: map.version,\n        file: map.file,\n        names: map.names,\n        sourceRoot: map.sourceRoot,\n        sources: map.sources,\n        sourcesContent: map.sourcesContent,\n        mappings,\n        ignoreList: map.ignoreList || map.x_google_ignoreList,\n    };\n}\nfunction OMapping(source, line, column, name) {\n    return { source, line, column, name };\n}\nfunction GMapping(line, column) {\n    return { line, column };\n}\nfunction traceSegmentInternal(segments, memo, line, column, bias) {\n    let index = memoizedBinarySearch(segments, column, memo, line);\n    if (found) {\n        index = (bias === LEAST_UPPER_BOUND ? upperBound : lowerBound)(segments, column, index);\n    }\n    else if (bias === LEAST_UPPER_BOUND)\n        index++;\n    if (index === -1 || index === segments.length)\n        return -1;\n    return index;\n}\nfunction sliceGeneratedPositions(segments, memo, line, column, bias) {\n    let min = traceSegmentInternal(segments, memo, line, column, GREATEST_LOWER_BOUND);\n    // We ignored the bias when tracing the segment so that we're guarnateed to find the first (in\n    // insertion order) segment that matched. Even if we did respect the bias when tracing, we would\n    // still need to call `lowerBound()` to find the first segment, which is slower than just looking\n    // for the GREATEST_LOWER_BOUND to begin with. The only difference that matters for us is when the\n    // binary search didn't match, in which case GREATEST_LOWER_BOUND just needs to increment to\n    // match LEAST_UPPER_BOUND.\n    if (!found && bias === LEAST_UPPER_BOUND)\n        min++;\n    if (min === -1 || min === segments.length)\n        return [];\n    // We may have found the segment that started at an earlier column. If this is the case, then we\n    // need to slice all generated segments that match _that_ column, because all such segments span\n    // to our desired column.\n    const matchedColumn = found ? column : segments[min][COLUMN];\n    // The binary search is not guaranteed to find the lower bound when a match wasn't found.\n    if (!found)\n        min = lowerBound(segments, matchedColumn, min);\n    const max = upperBound(segments, matchedColumn, min);\n    const result = [];\n    for (; min <= max; min++) {\n        const segment = segments[min];\n        result.push(GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]));\n    }\n    return result;\n}\nfunction generatedPosition(map, source, line, column, bias, all) {\n    var _a;\n    line--;\n    if (line < 0)\n        throw new Error(LINE_GTR_ZERO);\n    if (column < 0)\n        throw new Error(COL_GTR_EQ_ZERO);\n    const { sources, resolvedSources } = map;\n    let sourceIndex = sources.indexOf(source);\n    if (sourceIndex === -1)\n        sourceIndex = resolvedSources.indexOf(source);\n    if (sourceIndex === -1)\n        return all ? [] : GMapping(null, null);\n    const generated = ((_a = cast(map))._bySources || (_a._bySources = buildBySources(decodedMappings(map), (cast(map)._bySourceMemos = sources.map(memoizedState)))));\n    const segments = generated[sourceIndex][line];\n    if (segments == null)\n        return all ? [] : GMapping(null, null);\n    const memo = cast(map)._bySourceMemos[sourceIndex];\n    if (all)\n        return sliceGeneratedPositions(segments, memo, line, column, bias);\n    const index = traceSegmentInternal(segments, memo, line, column, bias);\n    if (index === -1)\n        return GMapping(null, null);\n    const segment = segments[index];\n    return GMapping(segment[REV_GENERATED_LINE] + 1, segment[REV_GENERATED_COLUMN]);\n}\n\n\n//# sourceMappingURL=trace-mapping.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL0BqcmlkZ2V3ZWxsL3RyYWNlLW1hcHBpbmcvZGlzdC90cmFjZS1tYXBwaW5nLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNkQ7QUFDWjs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtRUFBVTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxxQkFBcUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUNBQWlDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFdBQVc7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QixvQkFBb0IscUJBQXFCO0FBQ3pDLGdCQUFnQixjQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGlFQUFpRTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDRCQUE0QjtBQUNwRDtBQUNBO0FBQ0Esd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFlBQVk7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDREQUE0RDtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGLG1FQUFNO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxtRUFBTTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHFCQUFxQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5QkFBeUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2QkFBNkI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2QkFBNkI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUJBQXlCO0FBQ3JDLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkJBQTJCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMkJBQTJCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFaVI7QUFDalIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXJrdXNob2duZS9Eb2N1bWVudHMvQVBQUy9iYXphYXItdmlkL2JhemFhci12aWQvbm9kZV9tb2R1bGVzL0BqcmlkZ2V3ZWxsL3RyYWNlLW1hcHBpbmcvZGlzdC90cmFjZS1tYXBwaW5nLm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBlbmNvZGUsIGRlY29kZSB9IGZyb20gJ0BqcmlkZ2V3ZWxsL3NvdXJjZW1hcC1jb2RlYyc7XG5pbXBvcnQgcmVzb2x2ZVVyaSBmcm9tICdAanJpZGdld2VsbC9yZXNvbHZlLXVyaSc7XG5cbmZ1bmN0aW9uIHJlc29sdmUoaW5wdXQsIGJhc2UpIHtcbiAgICAvLyBUaGUgYmFzZSBpcyBhbHdheXMgdHJlYXRlZCBhcyBhIGRpcmVjdG9yeSwgaWYgaXQncyBub3QgZW1wdHkuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc291cmNlLW1hcC9ibG9iLzhjYjNlZTU3L2xpYi91dGlsLmpzI0wzMjdcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vY2hyb21pdW0vY2hyb21pdW0vYmxvYi9kYTRhZGJiMy90aGlyZF9wYXJ0eS9ibGluay9yZW5kZXJlci9kZXZ0b29scy9mcm9udF9lbmQvc2RrL1NvdXJjZU1hcC5qcyNMNDAwLUw0MDFcbiAgICBpZiAoYmFzZSAmJiAhYmFzZS5lbmRzV2l0aCgnLycpKVxuICAgICAgICBiYXNlICs9ICcvJztcbiAgICByZXR1cm4gcmVzb2x2ZVVyaShpbnB1dCwgYmFzZSk7XG59XG5cbi8qKlxuICogUmVtb3ZlcyBldmVyeXRoaW5nIGFmdGVyIHRoZSBsYXN0IFwiL1wiLCBidXQgbGVhdmVzIHRoZSBzbGFzaC5cbiAqL1xuZnVuY3Rpb24gc3RyaXBGaWxlbmFtZShwYXRoKSB7XG4gICAgaWYgKCFwYXRoKVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgY29uc3QgaW5kZXggPSBwYXRoLmxhc3RJbmRleE9mKCcvJyk7XG4gICAgcmV0dXJuIHBhdGguc2xpY2UoMCwgaW5kZXggKyAxKTtcbn1cblxuY29uc3QgQ09MVU1OID0gMDtcbmNvbnN0IFNPVVJDRVNfSU5ERVggPSAxO1xuY29uc3QgU09VUkNFX0xJTkUgPSAyO1xuY29uc3QgU09VUkNFX0NPTFVNTiA9IDM7XG5jb25zdCBOQU1FU19JTkRFWCA9IDQ7XG5jb25zdCBSRVZfR0VORVJBVEVEX0xJTkUgPSAxO1xuY29uc3QgUkVWX0dFTkVSQVRFRF9DT0xVTU4gPSAyO1xuXG5mdW5jdGlvbiBtYXliZVNvcnQobWFwcGluZ3MsIG93bmVkKSB7XG4gICAgY29uc3QgdW5zb3J0ZWRJbmRleCA9IG5leHRVbnNvcnRlZFNlZ21lbnRMaW5lKG1hcHBpbmdzLCAwKTtcbiAgICBpZiAodW5zb3J0ZWRJbmRleCA9PT0gbWFwcGluZ3MubGVuZ3RoKVxuICAgICAgICByZXR1cm4gbWFwcGluZ3M7XG4gICAgLy8gSWYgd2Ugb3duIHRoZSBhcnJheSAobWVhbmluZyB3ZSBwYXJzZWQgaXQgZnJvbSBKU09OKSwgdGhlbiB3ZSdyZSBmcmVlIHRvIGRpcmVjdGx5IG11dGF0ZSBpdC4gSWZcbiAgICAvLyBub3QsIHdlIGRvIG5vdCB3YW50IHRvIG1vZGlmeSB0aGUgY29uc3VtZXIncyBpbnB1dCBhcnJheS5cbiAgICBpZiAoIW93bmVkKVxuICAgICAgICBtYXBwaW5ncyA9IG1hcHBpbmdzLnNsaWNlKCk7XG4gICAgZm9yIChsZXQgaSA9IHVuc29ydGVkSW5kZXg7IGkgPCBtYXBwaW5ncy5sZW5ndGg7IGkgPSBuZXh0VW5zb3J0ZWRTZWdtZW50TGluZShtYXBwaW5ncywgaSArIDEpKSB7XG4gICAgICAgIG1hcHBpbmdzW2ldID0gc29ydFNlZ21lbnRzKG1hcHBpbmdzW2ldLCBvd25lZCk7XG4gICAgfVxuICAgIHJldHVybiBtYXBwaW5ncztcbn1cbmZ1bmN0aW9uIG5leHRVbnNvcnRlZFNlZ21lbnRMaW5lKG1hcHBpbmdzLCBzdGFydCkge1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IG1hcHBpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghaXNTb3J0ZWQobWFwcGluZ3NbaV0pKVxuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICAgIHJldHVybiBtYXBwaW5ncy5sZW5ndGg7XG59XG5mdW5jdGlvbiBpc1NvcnRlZChsaW5lKSB7XG4gICAgZm9yIChsZXQgaiA9IDE7IGogPCBsaW5lLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChsaW5lW2pdW0NPTFVNTl0gPCBsaW5lW2ogLSAxXVtDT0xVTU5dKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBzb3J0U2VnbWVudHMobGluZSwgb3duZWQpIHtcbiAgICBpZiAoIW93bmVkKVxuICAgICAgICBsaW5lID0gbGluZS5zbGljZSgpO1xuICAgIHJldHVybiBsaW5lLnNvcnQoc29ydENvbXBhcmF0b3IpO1xufVxuZnVuY3Rpb24gc29ydENvbXBhcmF0b3IoYSwgYikge1xuICAgIHJldHVybiBhW0NPTFVNTl0gLSBiW0NPTFVNTl07XG59XG5cbmxldCBmb3VuZCA9IGZhbHNlO1xuLyoqXG4gKiBBIGJpbmFyeSBzZWFyY2ggaW1wbGVtZW50YXRpb24gdGhhdCByZXR1cm5zIHRoZSBpbmRleCBpZiBhIG1hdGNoIGlzIGZvdW5kLlxuICogSWYgbm8gbWF0Y2ggaXMgZm91bmQsIHRoZW4gdGhlIGxlZnQtaW5kZXggKHRoZSBpbmRleCBhc3NvY2lhdGVkIHdpdGggdGhlIGl0ZW0gdGhhdCBjb21lcyBqdXN0XG4gKiBiZWZvcmUgdGhlIGRlc2lyZWQgaW5kZXgpIGlzIHJldHVybmVkLiBUbyBtYWludGFpbiBwcm9wZXIgc29ydCBvcmRlciwgYSBzcGxpY2Ugd291bGQgaGFwcGVuIGF0XG4gKiB0aGUgbmV4dCBpbmRleDpcbiAqXG4gKiBgYGBqc1xuICogY29uc3QgYXJyYXkgPSBbMSwgM107XG4gKiBjb25zdCBuZWVkbGUgPSAyO1xuICogY29uc3QgaW5kZXggPSBiaW5hcnlTZWFyY2goYXJyYXksIG5lZWRsZSwgKGl0ZW0sIG5lZWRsZSkgPT4gaXRlbSAtIG5lZWRsZSk7XG4gKlxuICogYXNzZXJ0LmVxdWFsKGluZGV4LCAwKTtcbiAqIGFycmF5LnNwbGljZShpbmRleCArIDEsIDAsIG5lZWRsZSk7XG4gKiBhc3NlcnQuZGVlcEVxdWFsKGFycmF5LCBbMSwgMiwgM10pO1xuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGJpbmFyeVNlYXJjaChoYXlzdGFjaywgbmVlZGxlLCBsb3csIGhpZ2gpIHtcbiAgICB3aGlsZSAobG93IDw9IGhpZ2gpIHtcbiAgICAgICAgY29uc3QgbWlkID0gbG93ICsgKChoaWdoIC0gbG93KSA+PiAxKTtcbiAgICAgICAgY29uc3QgY21wID0gaGF5c3RhY2tbbWlkXVtDT0xVTU5dIC0gbmVlZGxlO1xuICAgICAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gbWlkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbXAgPCAwKSB7XG4gICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGlnaCA9IG1pZCAtIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm91bmQgPSBmYWxzZTtcbiAgICByZXR1cm4gbG93IC0gMTtcbn1cbmZ1bmN0aW9uIHVwcGVyQm91bmQoaGF5c3RhY2ssIG5lZWRsZSwgaW5kZXgpIHtcbiAgICBmb3IgKGxldCBpID0gaW5kZXggKyAxOyBpIDwgaGF5c3RhY2subGVuZ3RoOyBpbmRleCA9IGkrKykge1xuICAgICAgICBpZiAoaGF5c3RhY2tbaV1bQ09MVU1OXSAhPT0gbmVlZGxlKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBpbmRleDtcbn1cbmZ1bmN0aW9uIGxvd2VyQm91bmQoaGF5c3RhY2ssIG5lZWRsZSwgaW5kZXgpIHtcbiAgICBmb3IgKGxldCBpID0gaW5kZXggLSAxOyBpID49IDA7IGluZGV4ID0gaS0tKSB7XG4gICAgICAgIGlmIChoYXlzdGFja1tpXVtDT0xVTU5dICE9PSBuZWVkbGUpXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGluZGV4O1xufVxuZnVuY3Rpb24gbWVtb2l6ZWRTdGF0ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBsYXN0S2V5OiAtMSxcbiAgICAgICAgbGFzdE5lZWRsZTogLTEsXG4gICAgICAgIGxhc3RJbmRleDogLTEsXG4gICAgfTtcbn1cbi8qKlxuICogVGhpcyBvdmVybHkgY29tcGxpY2F0ZWQgYmVhc3QgaXMganVzdCB0byByZWNvcmQgdGhlIGxhc3QgdGVzdGVkIGxpbmUvY29sdW1uIGFuZCB0aGUgcmVzdWx0aW5nXG4gKiBpbmRleCwgYWxsb3dpbmcgdXMgdG8gc2tpcCBhIGZldyB0ZXN0cyBpZiBtYXBwaW5ncyBhcmUgbW9ub3RvbmljYWxseSBpbmNyZWFzaW5nLlxuICovXG5mdW5jdGlvbiBtZW1vaXplZEJpbmFyeVNlYXJjaChoYXlzdGFjaywgbmVlZGxlLCBzdGF0ZSwga2V5KSB7XG4gICAgY29uc3QgeyBsYXN0S2V5LCBsYXN0TmVlZGxlLCBsYXN0SW5kZXggfSA9IHN0YXRlO1xuICAgIGxldCBsb3cgPSAwO1xuICAgIGxldCBoaWdoID0gaGF5c3RhY2subGVuZ3RoIC0gMTtcbiAgICBpZiAoa2V5ID09PSBsYXN0S2V5KSB7XG4gICAgICAgIGlmIChuZWVkbGUgPT09IGxhc3ROZWVkbGUpIHtcbiAgICAgICAgICAgIGZvdW5kID0gbGFzdEluZGV4ICE9PSAtMSAmJiBoYXlzdGFja1tsYXN0SW5kZXhdW0NPTFVNTl0gPT09IG5lZWRsZTtcbiAgICAgICAgICAgIHJldHVybiBsYXN0SW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5lZWRsZSA+PSBsYXN0TmVlZGxlKSB7XG4gICAgICAgICAgICAvLyBsYXN0SW5kZXggbWF5IGJlIC0xIGlmIHRoZSBwcmV2aW91cyBuZWVkbGUgd2FzIG5vdCBmb3VuZC5cbiAgICAgICAgICAgIGxvdyA9IGxhc3RJbmRleCA9PT0gLTEgPyAwIDogbGFzdEluZGV4O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGlnaCA9IGxhc3RJbmRleDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0ZS5sYXN0S2V5ID0ga2V5O1xuICAgIHN0YXRlLmxhc3ROZWVkbGUgPSBuZWVkbGU7XG4gICAgcmV0dXJuIChzdGF0ZS5sYXN0SW5kZXggPSBiaW5hcnlTZWFyY2goaGF5c3RhY2ssIG5lZWRsZSwgbG93LCBoaWdoKSk7XG59XG5cbi8vIFJlYnVpbGRzIHRoZSBvcmlnaW5hbCBzb3VyY2UgZmlsZXMsIHdpdGggbWFwcGluZ3MgdGhhdCBhcmUgb3JkZXJlZCBieSBzb3VyY2UgbGluZS9jb2x1bW4gaW5zdGVhZFxuLy8gb2YgZ2VuZXJhdGVkIGxpbmUvY29sdW1uLlxuZnVuY3Rpb24gYnVpbGRCeVNvdXJjZXMoZGVjb2RlZCwgbWVtb3MpIHtcbiAgICBjb25zdCBzb3VyY2VzID0gbWVtb3MubWFwKGJ1aWxkTnVsbEFycmF5KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlY29kZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbGluZSA9IGRlY29kZWRbaV07XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbGluZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY29uc3Qgc2VnID0gbGluZVtqXTtcbiAgICAgICAgICAgIGlmIChzZWcubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3Qgc291cmNlSW5kZXggPSBzZWdbU09VUkNFU19JTkRFWF07XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VMaW5lID0gc2VnW1NPVVJDRV9MSU5FXTtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZUNvbHVtbiA9IHNlZ1tTT1VSQ0VfQ09MVU1OXTtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsU291cmNlID0gc291cmNlc1tzb3VyY2VJbmRleF07XG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbExpbmUgPSAob3JpZ2luYWxTb3VyY2Vbc291cmNlTGluZV0gfHwgKG9yaWdpbmFsU291cmNlW3NvdXJjZUxpbmVdID0gW10pKTtcbiAgICAgICAgICAgIGNvbnN0IG1lbW8gPSBtZW1vc1tzb3VyY2VJbmRleF07XG4gICAgICAgICAgICAvLyBUaGUgYmluYXJ5IHNlYXJjaCBlaXRoZXIgZm91bmQgYSBtYXRjaCwgb3IgaXQgZm91bmQgdGhlIGxlZnQtaW5kZXgganVzdCBiZWZvcmUgd2hlcmUgdGhlXG4gICAgICAgICAgICAvLyBzZWdtZW50IHNob3VsZCBnby4gRWl0aGVyIHdheSwgd2Ugd2FudCB0byBpbnNlcnQgYWZ0ZXIgdGhhdC4gQW5kIHRoZXJlIG1heSBiZSBtdWx0aXBsZVxuICAgICAgICAgICAgLy8gZ2VuZXJhdGVkIHNlZ21lbnRzIGFzc29jaWF0ZWQgd2l0aCBhbiBvcmlnaW5hbCBsb2NhdGlvbiwgc28gdGhlcmUgbWF5IG5lZWQgdG8gbW92ZSBzZXZlcmFsXG4gICAgICAgICAgICAvLyBpbmRleGVzIGJlZm9yZSB3ZSBmaW5kIHdoZXJlIHdlIG5lZWQgdG8gaW5zZXJ0LlxuICAgICAgICAgICAgbGV0IGluZGV4ID0gdXBwZXJCb3VuZChvcmlnaW5hbExpbmUsIHNvdXJjZUNvbHVtbiwgbWVtb2l6ZWRCaW5hcnlTZWFyY2gob3JpZ2luYWxMaW5lLCBzb3VyY2VDb2x1bW4sIG1lbW8sIHNvdXJjZUxpbmUpKTtcbiAgICAgICAgICAgIG1lbW8ubGFzdEluZGV4ID0gKytpbmRleDtcbiAgICAgICAgICAgIGluc2VydChvcmlnaW5hbExpbmUsIGluZGV4LCBbc291cmNlQ29sdW1uLCBpLCBzZWdbQ09MVU1OXV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2VzO1xufVxuZnVuY3Rpb24gaW5zZXJ0KGFycmF5LCBpbmRleCwgdmFsdWUpIHtcbiAgICBmb3IgKGxldCBpID0gYXJyYXkubGVuZ3RoOyBpID4gaW5kZXg7IGktLSkge1xuICAgICAgICBhcnJheVtpXSA9IGFycmF5W2kgLSAxXTtcbiAgICB9XG4gICAgYXJyYXlbaW5kZXhdID0gdmFsdWU7XG59XG4vLyBOdWxsIGFycmF5cyBhbGxvdyB1cyB0byB1c2Ugb3JkZXJlZCBpbmRleCBrZXlzIHdpdGhvdXQgYWN0dWFsbHkgYWxsb2NhdGluZyBjb250aWd1b3VzIG1lbW9yeSBsaWtlXG4vLyBhIHJlYWwgYXJyYXkuIFdlIHVzZSBhIG51bGwtcHJvdG90eXBlIG9iamVjdCB0byBhdm9pZCBwcm90b3R5cGUgcG9sbHV0aW9uIGFuZCBkZW9wdGltaXphdGlvbnMuXG4vLyBOdW1lcmljIHByb3BlcnRpZXMgb24gb2JqZWN0cyBhcmUgbWFnaWNhbGx5IHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIgYnkgdGhlIGVuZ2luZSByZWdhcmRsZXNzIG9mXG4vLyB0aGUgaW5zZXJ0aW9uIG9yZGVyLiBTbywgYnkgc2V0dGluZyBhbnkgbnVtZXJpYyBrZXlzLCBldmVuIG91dCBvZiBvcmRlciwgd2UnbGwgZ2V0IGFzY2VuZGluZ1xuLy8gb3JkZXIgd2hlbiBpdGVyYXRpbmcgd2l0aCBmb3ItaW4uXG5mdW5jdGlvbiBidWlsZE51bGxBcnJheSgpIHtcbiAgICByZXR1cm4geyBfX3Byb3RvX186IG51bGwgfTtcbn1cblxuY29uc3QgQW55TWFwID0gZnVuY3Rpb24gKG1hcCwgbWFwVXJsKSB7XG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2UobWFwKTtcbiAgICBpZiAoISgnc2VjdGlvbnMnIGluIHBhcnNlZCkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmFjZU1hcChwYXJzZWQsIG1hcFVybCk7XG4gICAgfVxuICAgIGNvbnN0IG1hcHBpbmdzID0gW107XG4gICAgY29uc3Qgc291cmNlcyA9IFtdO1xuICAgIGNvbnN0IHNvdXJjZXNDb250ZW50ID0gW107XG4gICAgY29uc3QgbmFtZXMgPSBbXTtcbiAgICBjb25zdCBpZ25vcmVMaXN0ID0gW107XG4gICAgcmVjdXJzZShwYXJzZWQsIG1hcFVybCwgbWFwcGluZ3MsIHNvdXJjZXMsIHNvdXJjZXNDb250ZW50LCBuYW1lcywgaWdub3JlTGlzdCwgMCwgMCwgSW5maW5pdHksIEluZmluaXR5KTtcbiAgICBjb25zdCBqb2luZWQgPSB7XG4gICAgICAgIHZlcnNpb246IDMsXG4gICAgICAgIGZpbGU6IHBhcnNlZC5maWxlLFxuICAgICAgICBuYW1lcyxcbiAgICAgICAgc291cmNlcyxcbiAgICAgICAgc291cmNlc0NvbnRlbnQsXG4gICAgICAgIG1hcHBpbmdzLFxuICAgICAgICBpZ25vcmVMaXN0LFxuICAgIH07XG4gICAgcmV0dXJuIHByZXNvcnRlZERlY29kZWRNYXAoam9pbmVkKTtcbn07XG5mdW5jdGlvbiBwYXJzZShtYXApIHtcbiAgICByZXR1cm4gdHlwZW9mIG1hcCA9PT0gJ3N0cmluZycgPyBKU09OLnBhcnNlKG1hcCkgOiBtYXA7XG59XG5mdW5jdGlvbiByZWN1cnNlKGlucHV0LCBtYXBVcmwsIG1hcHBpbmdzLCBzb3VyY2VzLCBzb3VyY2VzQ29udGVudCwgbmFtZXMsIGlnbm9yZUxpc3QsIGxpbmVPZmZzZXQsIGNvbHVtbk9mZnNldCwgc3RvcExpbmUsIHN0b3BDb2x1bW4pIHtcbiAgICBjb25zdCB7IHNlY3Rpb25zIH0gPSBpbnB1dDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHsgbWFwLCBvZmZzZXQgfSA9IHNlY3Rpb25zW2ldO1xuICAgICAgICBsZXQgc2wgPSBzdG9wTGluZTtcbiAgICAgICAgbGV0IHNjID0gc3RvcENvbHVtbjtcbiAgICAgICAgaWYgKGkgKyAxIDwgc2VjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0T2Zmc2V0ID0gc2VjdGlvbnNbaSArIDFdLm9mZnNldDtcbiAgICAgICAgICAgIHNsID0gTWF0aC5taW4oc3RvcExpbmUsIGxpbmVPZmZzZXQgKyBuZXh0T2Zmc2V0LmxpbmUpO1xuICAgICAgICAgICAgaWYgKHNsID09PSBzdG9wTGluZSkge1xuICAgICAgICAgICAgICAgIHNjID0gTWF0aC5taW4oc3RvcENvbHVtbiwgY29sdW1uT2Zmc2V0ICsgbmV4dE9mZnNldC5jb2x1bW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2wgPCBzdG9wTGluZSkge1xuICAgICAgICAgICAgICAgIHNjID0gY29sdW1uT2Zmc2V0ICsgbmV4dE9mZnNldC5jb2x1bW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYWRkU2VjdGlvbihtYXAsIG1hcFVybCwgbWFwcGluZ3MsIHNvdXJjZXMsIHNvdXJjZXNDb250ZW50LCBuYW1lcywgaWdub3JlTGlzdCwgbGluZU9mZnNldCArIG9mZnNldC5saW5lLCBjb2x1bW5PZmZzZXQgKyBvZmZzZXQuY29sdW1uLCBzbCwgc2MpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZFNlY3Rpb24oaW5wdXQsIG1hcFVybCwgbWFwcGluZ3MsIHNvdXJjZXMsIHNvdXJjZXNDb250ZW50LCBuYW1lcywgaWdub3JlTGlzdCwgbGluZU9mZnNldCwgY29sdW1uT2Zmc2V0LCBzdG9wTGluZSwgc3RvcENvbHVtbikge1xuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlKGlucHV0KTtcbiAgICBpZiAoJ3NlY3Rpb25zJyBpbiBwYXJzZWQpXG4gICAgICAgIHJldHVybiByZWN1cnNlKC4uLmFyZ3VtZW50cyk7XG4gICAgY29uc3QgbWFwID0gbmV3IFRyYWNlTWFwKHBhcnNlZCwgbWFwVXJsKTtcbiAgICBjb25zdCBzb3VyY2VzT2Zmc2V0ID0gc291cmNlcy5sZW5ndGg7XG4gICAgY29uc3QgbmFtZXNPZmZzZXQgPSBuYW1lcy5sZW5ndGg7XG4gICAgY29uc3QgZGVjb2RlZCA9IGRlY29kZWRNYXBwaW5ncyhtYXApO1xuICAgIGNvbnN0IHsgcmVzb2x2ZWRTb3VyY2VzLCBzb3VyY2VzQ29udGVudDogY29udGVudHMsIGlnbm9yZUxpc3Q6IGlnbm9yZXMgfSA9IG1hcDtcbiAgICBhcHBlbmQoc291cmNlcywgcmVzb2x2ZWRTb3VyY2VzKTtcbiAgICBhcHBlbmQobmFtZXMsIG1hcC5uYW1lcyk7XG4gICAgaWYgKGNvbnRlbnRzKVxuICAgICAgICBhcHBlbmQoc291cmNlc0NvbnRlbnQsIGNvbnRlbnRzKTtcbiAgICBlbHNlXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzb2x2ZWRTb3VyY2VzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgc291cmNlc0NvbnRlbnQucHVzaChudWxsKTtcbiAgICBpZiAoaWdub3JlcylcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpZ25vcmVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWdub3JlTGlzdC5wdXNoKGlnbm9yZXNbaV0gKyBzb3VyY2VzT2Zmc2V0KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlY29kZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbGluZUkgPSBsaW5lT2Zmc2V0ICsgaTtcbiAgICAgICAgLy8gV2UgY2FuIG9ubHkgYWRkIHNvIG1hbnkgbGluZXMgYmVmb3JlIHdlIHN0ZXAgaW50byB0aGUgcmFuZ2UgdGhhdCB0aGUgbmV4dCBzZWN0aW9uJ3MgbWFwXG4gICAgICAgIC8vIGNvbnRyb2xzLiBXaGVuIHdlIGdldCB0byB0aGUgbGFzdCBsaW5lLCB0aGVuIHdlJ2xsIHN0YXJ0IGNoZWNraW5nIHRoZSBzZWdtZW50cyB0byBzZWUgaWZcbiAgICAgICAgLy8gdGhleSd2ZSBjcm9zc2VkIGludG8gdGhlIGNvbHVtbiByYW5nZS4gQnV0IGl0IG1heSBub3QgaGF2ZSBhbnkgY29sdW1ucyB0aGF0IG92ZXJzdGVwLCBzbyB3ZVxuICAgICAgICAvLyBzdGlsbCBuZWVkIHRvIGNoZWNrIHRoYXQgd2UgZG9uJ3Qgb3ZlcnN0ZXAgbGluZXMsIHRvby5cbiAgICAgICAgaWYgKGxpbmVJID4gc3RvcExpbmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIFRoZSBvdXQgbGluZSBtYXkgYWxyZWFkeSBleGlzdCBpbiBtYXBwaW5ncyAoaWYgd2UncmUgY29udGludWluZyB0aGUgbGluZSBzdGFydGVkIGJ5IGFcbiAgICAgICAgLy8gcHJldmlvdXMgc2VjdGlvbikuIE9yLCB3ZSBtYXkgaGF2ZSBqdW1wZWQgYWhlYWQgc2V2ZXJhbCBsaW5lcyB0byBzdGFydCB0aGlzIHNlY3Rpb24uXG4gICAgICAgIGNvbnN0IG91dCA9IGdldExpbmUobWFwcGluZ3MsIGxpbmVJKTtcbiAgICAgICAgLy8gT24gdGhlIDB0aCBsb29wLCB0aGUgc2VjdGlvbidzIGNvbHVtbiBvZmZzZXQgc2hpZnRzIHVzIGZvcndhcmQuIE9uIGFsbCBvdGhlciBsaW5lcyAoc2luY2UgdGhlXG4gICAgICAgIC8vIG1hcCBjYW4gYmUgbXVsdGlwbGUgbGluZXMpLCBpdCBkb2Vzbid0LlxuICAgICAgICBjb25zdCBjT2Zmc2V0ID0gaSA9PT0gMCA/IGNvbHVtbk9mZnNldCA6IDA7XG4gICAgICAgIGNvbnN0IGxpbmUgPSBkZWNvZGVkW2ldO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxpbmUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNlZyA9IGxpbmVbal07XG4gICAgICAgICAgICBjb25zdCBjb2x1bW4gPSBjT2Zmc2V0ICsgc2VnW0NPTFVNTl07XG4gICAgICAgICAgICAvLyBJZiB0aGlzIHNlZ21lbnQgc3RlcHMgaW50byB0aGUgY29sdW1uIHJhbmdlIHRoYXQgdGhlIG5leHQgc2VjdGlvbidzIG1hcCBjb250cm9scywgd2UgbmVlZFxuICAgICAgICAgICAgLy8gdG8gc3RvcCBlYXJseS5cbiAgICAgICAgICAgIGlmIChsaW5lSSA9PT0gc3RvcExpbmUgJiYgY29sdW1uID49IHN0b3BDb2x1bW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHNlZy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICBvdXQucHVzaChbY29sdW1uXSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VzSW5kZXggPSBzb3VyY2VzT2Zmc2V0ICsgc2VnW1NPVVJDRVNfSU5ERVhdO1xuICAgICAgICAgICAgY29uc3Qgc291cmNlTGluZSA9IHNlZ1tTT1VSQ0VfTElORV07XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VDb2x1bW4gPSBzZWdbU09VUkNFX0NPTFVNTl07XG4gICAgICAgICAgICBvdXQucHVzaChzZWcubGVuZ3RoID09PSA0XG4gICAgICAgICAgICAgICAgPyBbY29sdW1uLCBzb3VyY2VzSW5kZXgsIHNvdXJjZUxpbmUsIHNvdXJjZUNvbHVtbl1cbiAgICAgICAgICAgICAgICA6IFtjb2x1bW4sIHNvdXJjZXNJbmRleCwgc291cmNlTGluZSwgc291cmNlQ29sdW1uLCBuYW1lc09mZnNldCArIHNlZ1tOQU1FU19JTkRFWF1dKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGFwcGVuZChhcnIsIG90aGVyKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdGhlci5sZW5ndGg7IGkrKylcbiAgICAgICAgYXJyLnB1c2gob3RoZXJbaV0pO1xufVxuZnVuY3Rpb24gZ2V0TGluZShhcnIsIGluZGV4KSB7XG4gICAgZm9yIChsZXQgaSA9IGFyci5sZW5ndGg7IGkgPD0gaW5kZXg7IGkrKylcbiAgICAgICAgYXJyW2ldID0gW107XG4gICAgcmV0dXJuIGFycltpbmRleF07XG59XG5cbmNvbnN0IExJTkVfR1RSX1pFUk8gPSAnYGxpbmVgIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAgKGxpbmVzIHN0YXJ0IGF0IGxpbmUgMSknO1xuY29uc3QgQ09MX0dUUl9FUV9aRVJPID0gJ2Bjb2x1bW5gIG11c3QgYmUgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIDAgKGNvbHVtbnMgc3RhcnQgYXQgY29sdW1uIDApJztcbmNvbnN0IExFQVNUX1VQUEVSX0JPVU5EID0gLTE7XG5jb25zdCBHUkVBVEVTVF9MT1dFUl9CT1VORCA9IDE7XG5jbGFzcyBUcmFjZU1hcCB7XG4gICAgY29uc3RydWN0b3IobWFwLCBtYXBVcmwpIHtcbiAgICAgICAgY29uc3QgaXNTdHJpbmcgPSB0eXBlb2YgbWFwID09PSAnc3RyaW5nJztcbiAgICAgICAgaWYgKCFpc1N0cmluZyAmJiBtYXAuX2RlY29kZWRNZW1vKVxuICAgICAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgICAgY29uc3QgcGFyc2VkID0gKGlzU3RyaW5nID8gSlNPTi5wYXJzZShtYXApIDogbWFwKTtcbiAgICAgICAgY29uc3QgeyB2ZXJzaW9uLCBmaWxlLCBuYW1lcywgc291cmNlUm9vdCwgc291cmNlcywgc291cmNlc0NvbnRlbnQgfSA9IHBhcnNlZDtcbiAgICAgICAgdGhpcy52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy5maWxlID0gZmlsZTtcbiAgICAgICAgdGhpcy5uYW1lcyA9IG5hbWVzIHx8IFtdO1xuICAgICAgICB0aGlzLnNvdXJjZVJvb3QgPSBzb3VyY2VSb290O1xuICAgICAgICB0aGlzLnNvdXJjZXMgPSBzb3VyY2VzO1xuICAgICAgICB0aGlzLnNvdXJjZXNDb250ZW50ID0gc291cmNlc0NvbnRlbnQ7XG4gICAgICAgIHRoaXMuaWdub3JlTGlzdCA9IHBhcnNlZC5pZ25vcmVMaXN0IHx8IHBhcnNlZC54X2dvb2dsZV9pZ25vcmVMaXN0IHx8IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgZnJvbSA9IHJlc29sdmUoc291cmNlUm9vdCB8fCAnJywgc3RyaXBGaWxlbmFtZShtYXBVcmwpKTtcbiAgICAgICAgdGhpcy5yZXNvbHZlZFNvdXJjZXMgPSBzb3VyY2VzLm1hcCgocykgPT4gcmVzb2x2ZShzIHx8ICcnLCBmcm9tKSk7XG4gICAgICAgIGNvbnN0IHsgbWFwcGluZ3MgfSA9IHBhcnNlZDtcbiAgICAgICAgaWYgKHR5cGVvZiBtYXBwaW5ncyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMuX2VuY29kZWQgPSBtYXBwaW5ncztcbiAgICAgICAgICAgIHRoaXMuX2RlY29kZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9lbmNvZGVkID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5fZGVjb2RlZCA9IG1heWJlU29ydChtYXBwaW5ncywgaXNTdHJpbmcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RlY29kZWRNZW1vID0gbWVtb2l6ZWRTdGF0ZSgpO1xuICAgICAgICB0aGlzLl9ieVNvdXJjZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX2J5U291cmNlTWVtb3MgPSB1bmRlZmluZWQ7XG4gICAgfVxufVxuLyoqXG4gKiBUeXBlc2NyaXB0IGRvZXNuJ3QgYWxsb3cgZnJpZW5kIGFjY2VzcyB0byBwcml2YXRlIGZpZWxkcywgc28gdGhpcyBqdXN0IGNhc3RzIHRoZSBtYXAgaW50byBhIHR5cGVcbiAqIHdpdGggcHVibGljIGFjY2VzcyBtb2RpZmllcnMuXG4gKi9cbmZ1bmN0aW9uIGNhc3QobWFwKSB7XG4gICAgcmV0dXJuIG1hcDtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgZW5jb2RlZCAoVkxRIHN0cmluZykgZm9ybSBvZiB0aGUgU291cmNlTWFwJ3MgbWFwcGluZ3MgZmllbGQuXG4gKi9cbmZ1bmN0aW9uIGVuY29kZWRNYXBwaW5ncyhtYXApIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIF9iO1xuICAgIHJldHVybiAoKF9hID0gKF9iID0gY2FzdChtYXApKS5fZW5jb2RlZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKF9iLl9lbmNvZGVkID0gZW5jb2RlKGNhc3QobWFwKS5fZGVjb2RlZCkpKTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgZGVjb2RlZCAoYXJyYXkgb2YgbGluZXMgb2Ygc2VnbWVudHMpIGZvcm0gb2YgdGhlIFNvdXJjZU1hcCdzIG1hcHBpbmdzIGZpZWxkLlxuICovXG5mdW5jdGlvbiBkZWNvZGVkTWFwcGluZ3MobWFwKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoKF9hID0gY2FzdChtYXApKS5fZGVjb2RlZCB8fCAoX2EuX2RlY29kZWQgPSBkZWNvZGUoY2FzdChtYXApLl9lbmNvZGVkKSkpO1xufVxuLyoqXG4gKiBBIGxvdy1sZXZlbCBBUEkgdG8gZmluZCB0aGUgc2VnbWVudCBhc3NvY2lhdGVkIHdpdGggYSBnZW5lcmF0ZWQgbGluZS9jb2x1bW4gKHRoaW5rLCBmcm9tIGFcbiAqIHN0YWNrIHRyYWNlKS4gTGluZSBhbmQgY29sdW1uIGhlcmUgYXJlIDAtYmFzZWQsIHVubGlrZSBgb3JpZ2luYWxQb3NpdGlvbkZvcmAuXG4gKi9cbmZ1bmN0aW9uIHRyYWNlU2VnbWVudChtYXAsIGxpbmUsIGNvbHVtbikge1xuICAgIGNvbnN0IGRlY29kZWQgPSBkZWNvZGVkTWFwcGluZ3MobWFwKTtcbiAgICAvLyBJdCdzIGNvbW1vbiBmb3IgcGFyZW50IHNvdXJjZSBtYXBzIHRvIGhhdmUgcG9pbnRlcnMgdG8gbGluZXMgdGhhdCBoYXZlIG5vXG4gICAgLy8gbWFwcGluZyAobGlrZSBhIFwiLy8jIHNvdXJjZU1hcHBpbmdVUkw9XCIpIGF0IHRoZSBlbmQgb2YgdGhlIGNoaWxkIGZpbGUuXG4gICAgaWYgKGxpbmUgPj0gZGVjb2RlZC5sZW5ndGgpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHNlZ21lbnRzID0gZGVjb2RlZFtsaW5lXTtcbiAgICBjb25zdCBpbmRleCA9IHRyYWNlU2VnbWVudEludGVybmFsKHNlZ21lbnRzLCBjYXN0KG1hcCkuX2RlY29kZWRNZW1vLCBsaW5lLCBjb2x1bW4sIEdSRUFURVNUX0xPV0VSX0JPVU5EKTtcbiAgICByZXR1cm4gaW5kZXggPT09IC0xID8gbnVsbCA6IHNlZ21lbnRzW2luZGV4XTtcbn1cbi8qKlxuICogQSBoaWdoZXItbGV2ZWwgQVBJIHRvIGZpbmQgdGhlIHNvdXJjZS9saW5lL2NvbHVtbiBhc3NvY2lhdGVkIHdpdGggYSBnZW5lcmF0ZWQgbGluZS9jb2x1bW5cbiAqICh0aGluaywgZnJvbSBhIHN0YWNrIHRyYWNlKS4gTGluZSBpcyAxLWJhc2VkLCBidXQgY29sdW1uIGlzIDAtYmFzZWQsIGR1ZSB0byBsZWdhY3kgYmVoYXZpb3IgaW5cbiAqIGBzb3VyY2UtbWFwYCBsaWJyYXJ5LlxuICovXG5mdW5jdGlvbiBvcmlnaW5hbFBvc2l0aW9uRm9yKG1hcCwgbmVlZGxlKSB7XG4gICAgbGV0IHsgbGluZSwgY29sdW1uLCBiaWFzIH0gPSBuZWVkbGU7XG4gICAgbGluZS0tO1xuICAgIGlmIChsaW5lIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKExJTkVfR1RSX1pFUk8pO1xuICAgIGlmIChjb2x1bW4gPCAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoQ09MX0dUUl9FUV9aRVJPKTtcbiAgICBjb25zdCBkZWNvZGVkID0gZGVjb2RlZE1hcHBpbmdzKG1hcCk7XG4gICAgLy8gSXQncyBjb21tb24gZm9yIHBhcmVudCBzb3VyY2UgbWFwcyB0byBoYXZlIHBvaW50ZXJzIHRvIGxpbmVzIHRoYXQgaGF2ZSBub1xuICAgIC8vIG1hcHBpbmcgKGxpa2UgYSBcIi8vIyBzb3VyY2VNYXBwaW5nVVJMPVwiKSBhdCB0aGUgZW5kIG9mIHRoZSBjaGlsZCBmaWxlLlxuICAgIGlmIChsaW5lID49IGRlY29kZWQubGVuZ3RoKVxuICAgICAgICByZXR1cm4gT01hcHBpbmcobnVsbCwgbnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgY29uc3Qgc2VnbWVudHMgPSBkZWNvZGVkW2xpbmVdO1xuICAgIGNvbnN0IGluZGV4ID0gdHJhY2VTZWdtZW50SW50ZXJuYWwoc2VnbWVudHMsIGNhc3QobWFwKS5fZGVjb2RlZE1lbW8sIGxpbmUsIGNvbHVtbiwgYmlhcyB8fCBHUkVBVEVTVF9MT1dFUl9CT1VORCk7XG4gICAgaWYgKGluZGV4ID09PSAtMSlcbiAgICAgICAgcmV0dXJuIE9NYXBwaW5nKG51bGwsIG51bGwsIG51bGwsIG51bGwpO1xuICAgIGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1tpbmRleF07XG4gICAgaWYgKHNlZ21lbnQubGVuZ3RoID09PSAxKVxuICAgICAgICByZXR1cm4gT01hcHBpbmcobnVsbCwgbnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgY29uc3QgeyBuYW1lcywgcmVzb2x2ZWRTb3VyY2VzIH0gPSBtYXA7XG4gICAgcmV0dXJuIE9NYXBwaW5nKHJlc29sdmVkU291cmNlc1tzZWdtZW50W1NPVVJDRVNfSU5ERVhdXSwgc2VnbWVudFtTT1VSQ0VfTElORV0gKyAxLCBzZWdtZW50W1NPVVJDRV9DT0xVTU5dLCBzZWdtZW50Lmxlbmd0aCA9PT0gNSA/IG5hbWVzW3NlZ21lbnRbTkFNRVNfSU5ERVhdXSA6IG51bGwpO1xufVxuLyoqXG4gKiBGaW5kcyB0aGUgZ2VuZXJhdGVkIGxpbmUvY29sdW1uIHBvc2l0aW9uIG9mIHRoZSBwcm92aWRlZCBzb3VyY2UvbGluZS9jb2x1bW4gc291cmNlIHBvc2l0aW9uLlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZWRQb3NpdGlvbkZvcihtYXAsIG5lZWRsZSkge1xuICAgIGNvbnN0IHsgc291cmNlLCBsaW5lLCBjb2x1bW4sIGJpYXMgfSA9IG5lZWRsZTtcbiAgICByZXR1cm4gZ2VuZXJhdGVkUG9zaXRpb24obWFwLCBzb3VyY2UsIGxpbmUsIGNvbHVtbiwgYmlhcyB8fCBHUkVBVEVTVF9MT1dFUl9CT1VORCwgZmFsc2UpO1xufVxuLyoqXG4gKiBGaW5kcyBhbGwgZ2VuZXJhdGVkIGxpbmUvY29sdW1uIHBvc2l0aW9ucyBvZiB0aGUgcHJvdmlkZWQgc291cmNlL2xpbmUvY29sdW1uIHNvdXJjZSBwb3NpdGlvbi5cbiAqL1xuZnVuY3Rpb24gYWxsR2VuZXJhdGVkUG9zaXRpb25zRm9yKG1hcCwgbmVlZGxlKSB7XG4gICAgY29uc3QgeyBzb3VyY2UsIGxpbmUsIGNvbHVtbiwgYmlhcyB9ID0gbmVlZGxlO1xuICAgIC8vIFNvdXJjZU1hcENvbnN1bWVyIHVzZXMgTEVBU1RfVVBQRVJfQk9VTkQgZm9yIHNvbWUgcmVhc29uLCBzbyB3ZSBmb2xsb3cgc3VpdC5cbiAgICByZXR1cm4gZ2VuZXJhdGVkUG9zaXRpb24obWFwLCBzb3VyY2UsIGxpbmUsIGNvbHVtbiwgYmlhcyB8fCBMRUFTVF9VUFBFUl9CT1VORCwgdHJ1ZSk7XG59XG4vKipcbiAqIEl0ZXJhdGVzIGVhY2ggbWFwcGluZyBpbiBnZW5lcmF0ZWQgcG9zaXRpb24gb3JkZXIuXG4gKi9cbmZ1bmN0aW9uIGVhY2hNYXBwaW5nKG1hcCwgY2IpIHtcbiAgICBjb25zdCBkZWNvZGVkID0gZGVjb2RlZE1hcHBpbmdzKG1hcCk7XG4gICAgY29uc3QgeyBuYW1lcywgcmVzb2x2ZWRTb3VyY2VzIH0gPSBtYXA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWNvZGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGxpbmUgPSBkZWNvZGVkW2ldO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxpbmUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNlZyA9IGxpbmVbal07XG4gICAgICAgICAgICBjb25zdCBnZW5lcmF0ZWRMaW5lID0gaSArIDE7XG4gICAgICAgICAgICBjb25zdCBnZW5lcmF0ZWRDb2x1bW4gPSBzZWdbMF07XG4gICAgICAgICAgICBsZXQgc291cmNlID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBvcmlnaW5hbExpbmUgPSBudWxsO1xuICAgICAgICAgICAgbGV0IG9yaWdpbmFsQ29sdW1uID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBuYW1lID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChzZWcubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgc291cmNlID0gcmVzb2x2ZWRTb3VyY2VzW3NlZ1sxXV07XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxMaW5lID0gc2VnWzJdICsgMTtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbENvbHVtbiA9IHNlZ1szXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWcubGVuZ3RoID09PSA1KVxuICAgICAgICAgICAgICAgIG5hbWUgPSBuYW1lc1tzZWdbNF1dO1xuICAgICAgICAgICAgY2Ioe1xuICAgICAgICAgICAgICAgIGdlbmVyYXRlZExpbmUsXG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVkQ29sdW1uLFxuICAgICAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgICAgICBvcmlnaW5hbExpbmUsXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxDb2x1bW4sXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gc291cmNlSW5kZXgobWFwLCBzb3VyY2UpIHtcbiAgICBjb25zdCB7IHNvdXJjZXMsIHJlc29sdmVkU291cmNlcyB9ID0gbWFwO1xuICAgIGxldCBpbmRleCA9IHNvdXJjZXMuaW5kZXhPZihzb3VyY2UpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpXG4gICAgICAgIGluZGV4ID0gcmVzb2x2ZWRTb3VyY2VzLmluZGV4T2Yoc291cmNlKTtcbiAgICByZXR1cm4gaW5kZXg7XG59XG4vKipcbiAqIFJldHJpZXZlcyB0aGUgc291cmNlIGNvbnRlbnQgZm9yIGEgcGFydGljdWxhciBzb3VyY2UsIGlmIGl0cyBmb3VuZC4gUmV0dXJucyBudWxsIGlmIG5vdC5cbiAqL1xuZnVuY3Rpb24gc291cmNlQ29udGVudEZvcihtYXAsIHNvdXJjZSkge1xuICAgIGNvbnN0IHsgc291cmNlc0NvbnRlbnQgfSA9IG1hcDtcbiAgICBpZiAoc291cmNlc0NvbnRlbnQgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgaW5kZXggPSBzb3VyY2VJbmRleChtYXAsIHNvdXJjZSk7XG4gICAgcmV0dXJuIGluZGV4ID09PSAtMSA/IG51bGwgOiBzb3VyY2VzQ29udGVudFtpbmRleF07XG59XG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIHNvdXJjZSBpcyBtYXJrZWQgdG8gaWdub3JlIGJ5IHRoZSBzb3VyY2UgbWFwLlxuICovXG5mdW5jdGlvbiBpc0lnbm9yZWQobWFwLCBzb3VyY2UpIHtcbiAgICBjb25zdCB7IGlnbm9yZUxpc3QgfSA9IG1hcDtcbiAgICBpZiAoaWdub3JlTGlzdCA9PSBudWxsKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgaW5kZXggPSBzb3VyY2VJbmRleChtYXAsIHNvdXJjZSk7XG4gICAgcmV0dXJuIGluZGV4ID09PSAtMSA/IGZhbHNlIDogaWdub3JlTGlzdC5pbmNsdWRlcyhpbmRleCk7XG59XG4vKipcbiAqIEEgaGVscGVyIHRoYXQgc2tpcHMgc29ydGluZyBvZiB0aGUgaW5wdXQgbWFwJ3MgbWFwcGluZ3MgYXJyYXksIHdoaWNoIGNhbiBiZSBleHBlbnNpdmUgZm9yIGxhcmdlclxuICogbWFwcy5cbiAqL1xuZnVuY3Rpb24gcHJlc29ydGVkRGVjb2RlZE1hcChtYXAsIG1hcFVybCkge1xuICAgIGNvbnN0IHRyYWNlciA9IG5ldyBUcmFjZU1hcChjbG9uZShtYXAsIFtdKSwgbWFwVXJsKTtcbiAgICBjYXN0KHRyYWNlcikuX2RlY29kZWQgPSBtYXAubWFwcGluZ3M7XG4gICAgcmV0dXJuIHRyYWNlcjtcbn1cbi8qKlxuICogUmV0dXJucyBhIHNvdXJjZW1hcCBvYmplY3QgKHdpdGggZGVjb2RlZCBtYXBwaW5ncykgc3VpdGFibGUgZm9yIHBhc3NpbmcgdG8gYSBsaWJyYXJ5IHRoYXQgZXhwZWN0c1xuICogYSBzb3VyY2VtYXAsIG9yIHRvIEpTT04uc3RyaW5naWZ5LlxuICovXG5mdW5jdGlvbiBkZWNvZGVkTWFwKG1hcCkge1xuICAgIHJldHVybiBjbG9uZShtYXAsIGRlY29kZWRNYXBwaW5ncyhtYXApKTtcbn1cbi8qKlxuICogUmV0dXJucyBhIHNvdXJjZW1hcCBvYmplY3QgKHdpdGggZW5jb2RlZCBtYXBwaW5ncykgc3VpdGFibGUgZm9yIHBhc3NpbmcgdG8gYSBsaWJyYXJ5IHRoYXQgZXhwZWN0c1xuICogYSBzb3VyY2VtYXAsIG9yIHRvIEpTT04uc3RyaW5naWZ5LlxuICovXG5mdW5jdGlvbiBlbmNvZGVkTWFwKG1hcCkge1xuICAgIHJldHVybiBjbG9uZShtYXAsIGVuY29kZWRNYXBwaW5ncyhtYXApKTtcbn1cbmZ1bmN0aW9uIGNsb25lKG1hcCwgbWFwcGluZ3MpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB2ZXJzaW9uOiBtYXAudmVyc2lvbixcbiAgICAgICAgZmlsZTogbWFwLmZpbGUsXG4gICAgICAgIG5hbWVzOiBtYXAubmFtZXMsXG4gICAgICAgIHNvdXJjZVJvb3Q6IG1hcC5zb3VyY2VSb290LFxuICAgICAgICBzb3VyY2VzOiBtYXAuc291cmNlcyxcbiAgICAgICAgc291cmNlc0NvbnRlbnQ6IG1hcC5zb3VyY2VzQ29udGVudCxcbiAgICAgICAgbWFwcGluZ3MsXG4gICAgICAgIGlnbm9yZUxpc3Q6IG1hcC5pZ25vcmVMaXN0IHx8IG1hcC54X2dvb2dsZV9pZ25vcmVMaXN0LFxuICAgIH07XG59XG5mdW5jdGlvbiBPTWFwcGluZyhzb3VyY2UsIGxpbmUsIGNvbHVtbiwgbmFtZSkge1xuICAgIHJldHVybiB7IHNvdXJjZSwgbGluZSwgY29sdW1uLCBuYW1lIH07XG59XG5mdW5jdGlvbiBHTWFwcGluZyhsaW5lLCBjb2x1bW4pIHtcbiAgICByZXR1cm4geyBsaW5lLCBjb2x1bW4gfTtcbn1cbmZ1bmN0aW9uIHRyYWNlU2VnbWVudEludGVybmFsKHNlZ21lbnRzLCBtZW1vLCBsaW5lLCBjb2x1bW4sIGJpYXMpIHtcbiAgICBsZXQgaW5kZXggPSBtZW1vaXplZEJpbmFyeVNlYXJjaChzZWdtZW50cywgY29sdW1uLCBtZW1vLCBsaW5lKTtcbiAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgaW5kZXggPSAoYmlhcyA9PT0gTEVBU1RfVVBQRVJfQk9VTkQgPyB1cHBlckJvdW5kIDogbG93ZXJCb3VuZCkoc2VnbWVudHMsIGNvbHVtbiwgaW5kZXgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChiaWFzID09PSBMRUFTVF9VUFBFUl9CT1VORClcbiAgICAgICAgaW5kZXgrKztcbiAgICBpZiAoaW5kZXggPT09IC0xIHx8IGluZGV4ID09PSBzZWdtZW50cy5sZW5ndGgpXG4gICAgICAgIHJldHVybiAtMTtcbiAgICByZXR1cm4gaW5kZXg7XG59XG5mdW5jdGlvbiBzbGljZUdlbmVyYXRlZFBvc2l0aW9ucyhzZWdtZW50cywgbWVtbywgbGluZSwgY29sdW1uLCBiaWFzKSB7XG4gICAgbGV0IG1pbiA9IHRyYWNlU2VnbWVudEludGVybmFsKHNlZ21lbnRzLCBtZW1vLCBsaW5lLCBjb2x1bW4sIEdSRUFURVNUX0xPV0VSX0JPVU5EKTtcbiAgICAvLyBXZSBpZ25vcmVkIHRoZSBiaWFzIHdoZW4gdHJhY2luZyB0aGUgc2VnbWVudCBzbyB0aGF0IHdlJ3JlIGd1YXJuYXRlZWQgdG8gZmluZCB0aGUgZmlyc3QgKGluXG4gICAgLy8gaW5zZXJ0aW9uIG9yZGVyKSBzZWdtZW50IHRoYXQgbWF0Y2hlZC4gRXZlbiBpZiB3ZSBkaWQgcmVzcGVjdCB0aGUgYmlhcyB3aGVuIHRyYWNpbmcsIHdlIHdvdWxkXG4gICAgLy8gc3RpbGwgbmVlZCB0byBjYWxsIGBsb3dlckJvdW5kKClgIHRvIGZpbmQgdGhlIGZpcnN0IHNlZ21lbnQsIHdoaWNoIGlzIHNsb3dlciB0aGFuIGp1c3QgbG9va2luZ1xuICAgIC8vIGZvciB0aGUgR1JFQVRFU1RfTE9XRVJfQk9VTkQgdG8gYmVnaW4gd2l0aC4gVGhlIG9ubHkgZGlmZmVyZW5jZSB0aGF0IG1hdHRlcnMgZm9yIHVzIGlzIHdoZW4gdGhlXG4gICAgLy8gYmluYXJ5IHNlYXJjaCBkaWRuJ3QgbWF0Y2gsIGluIHdoaWNoIGNhc2UgR1JFQVRFU1RfTE9XRVJfQk9VTkQganVzdCBuZWVkcyB0byBpbmNyZW1lbnQgdG9cbiAgICAvLyBtYXRjaCBMRUFTVF9VUFBFUl9CT1VORC5cbiAgICBpZiAoIWZvdW5kICYmIGJpYXMgPT09IExFQVNUX1VQUEVSX0JPVU5EKVxuICAgICAgICBtaW4rKztcbiAgICBpZiAobWluID09PSAtMSB8fCBtaW4gPT09IHNlZ21lbnRzLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIC8vIFdlIG1heSBoYXZlIGZvdW5kIHRoZSBzZWdtZW50IHRoYXQgc3RhcnRlZCBhdCBhbiBlYXJsaWVyIGNvbHVtbi4gSWYgdGhpcyBpcyB0aGUgY2FzZSwgdGhlbiB3ZVxuICAgIC8vIG5lZWQgdG8gc2xpY2UgYWxsIGdlbmVyYXRlZCBzZWdtZW50cyB0aGF0IG1hdGNoIF90aGF0XyBjb2x1bW4sIGJlY2F1c2UgYWxsIHN1Y2ggc2VnbWVudHMgc3BhblxuICAgIC8vIHRvIG91ciBkZXNpcmVkIGNvbHVtbi5cbiAgICBjb25zdCBtYXRjaGVkQ29sdW1uID0gZm91bmQgPyBjb2x1bW4gOiBzZWdtZW50c1ttaW5dW0NPTFVNTl07XG4gICAgLy8gVGhlIGJpbmFyeSBzZWFyY2ggaXMgbm90IGd1YXJhbnRlZWQgdG8gZmluZCB0aGUgbG93ZXIgYm91bmQgd2hlbiBhIG1hdGNoIHdhc24ndCBmb3VuZC5cbiAgICBpZiAoIWZvdW5kKVxuICAgICAgICBtaW4gPSBsb3dlckJvdW5kKHNlZ21lbnRzLCBtYXRjaGVkQ29sdW1uLCBtaW4pO1xuICAgIGNvbnN0IG1heCA9IHVwcGVyQm91bmQoc2VnbWVudHMsIG1hdGNoZWRDb2x1bW4sIG1pbik7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZm9yICg7IG1pbiA8PSBtYXg7IG1pbisrKSB7XG4gICAgICAgIGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1ttaW5dO1xuICAgICAgICByZXN1bHQucHVzaChHTWFwcGluZyhzZWdtZW50W1JFVl9HRU5FUkFURURfTElORV0gKyAxLCBzZWdtZW50W1JFVl9HRU5FUkFURURfQ09MVU1OXSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVkUG9zaXRpb24obWFwLCBzb3VyY2UsIGxpbmUsIGNvbHVtbiwgYmlhcywgYWxsKSB7XG4gICAgdmFyIF9hO1xuICAgIGxpbmUtLTtcbiAgICBpZiAobGluZSA8IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihMSU5FX0dUUl9aRVJPKTtcbiAgICBpZiAoY29sdW1uIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKENPTF9HVFJfRVFfWkVSTyk7XG4gICAgY29uc3QgeyBzb3VyY2VzLCByZXNvbHZlZFNvdXJjZXMgfSA9IG1hcDtcbiAgICBsZXQgc291cmNlSW5kZXggPSBzb3VyY2VzLmluZGV4T2Yoc291cmNlKTtcbiAgICBpZiAoc291cmNlSW5kZXggPT09IC0xKVxuICAgICAgICBzb3VyY2VJbmRleCA9IHJlc29sdmVkU291cmNlcy5pbmRleE9mKHNvdXJjZSk7XG4gICAgaWYgKHNvdXJjZUluZGV4ID09PSAtMSlcbiAgICAgICAgcmV0dXJuIGFsbCA/IFtdIDogR01hcHBpbmcobnVsbCwgbnVsbCk7XG4gICAgY29uc3QgZ2VuZXJhdGVkID0gKChfYSA9IGNhc3QobWFwKSkuX2J5U291cmNlcyB8fCAoX2EuX2J5U291cmNlcyA9IGJ1aWxkQnlTb3VyY2VzKGRlY29kZWRNYXBwaW5ncyhtYXApLCAoY2FzdChtYXApLl9ieVNvdXJjZU1lbW9zID0gc291cmNlcy5tYXAobWVtb2l6ZWRTdGF0ZSkpKSkpO1xuICAgIGNvbnN0IHNlZ21lbnRzID0gZ2VuZXJhdGVkW3NvdXJjZUluZGV4XVtsaW5lXTtcbiAgICBpZiAoc2VnbWVudHMgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIGFsbCA/IFtdIDogR01hcHBpbmcobnVsbCwgbnVsbCk7XG4gICAgY29uc3QgbWVtbyA9IGNhc3QobWFwKS5fYnlTb3VyY2VNZW1vc1tzb3VyY2VJbmRleF07XG4gICAgaWYgKGFsbClcbiAgICAgICAgcmV0dXJuIHNsaWNlR2VuZXJhdGVkUG9zaXRpb25zKHNlZ21lbnRzLCBtZW1vLCBsaW5lLCBjb2x1bW4sIGJpYXMpO1xuICAgIGNvbnN0IGluZGV4ID0gdHJhY2VTZWdtZW50SW50ZXJuYWwoc2VnbWVudHMsIG1lbW8sIGxpbmUsIGNvbHVtbiwgYmlhcyk7XG4gICAgaWYgKGluZGV4ID09PSAtMSlcbiAgICAgICAgcmV0dXJuIEdNYXBwaW5nKG51bGwsIG51bGwpO1xuICAgIGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1tpbmRleF07XG4gICAgcmV0dXJuIEdNYXBwaW5nKHNlZ21lbnRbUkVWX0dFTkVSQVRFRF9MSU5FXSArIDEsIHNlZ21lbnRbUkVWX0dFTkVSQVRFRF9DT0xVTU5dKTtcbn1cblxuZXhwb3J0IHsgQW55TWFwLCBHUkVBVEVTVF9MT1dFUl9CT1VORCwgTEVBU1RfVVBQRVJfQk9VTkQsIFRyYWNlTWFwLCBhbGxHZW5lcmF0ZWRQb3NpdGlvbnNGb3IsIGRlY29kZWRNYXAsIGRlY29kZWRNYXBwaW5ncywgZWFjaE1hcHBpbmcsIGVuY29kZWRNYXAsIGVuY29kZWRNYXBwaW5ncywgZ2VuZXJhdGVkUG9zaXRpb25Gb3IsIGlzSWdub3JlZCwgb3JpZ2luYWxQb3NpdGlvbkZvciwgcHJlc29ydGVkRGVjb2RlZE1hcCwgc291cmNlQ29udGVudEZvciwgdHJhY2VTZWdtZW50IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10cmFjZS1tYXBwaW5nLm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/@jridgewell/trace-mapping/dist/trace-mapping.mjs\n");

/***/ })

};
;