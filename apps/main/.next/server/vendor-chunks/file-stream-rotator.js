"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/file-stream-rotator";
exports.ids = ["vendor-chunks/file-stream-rotator"];
exports.modules = {

/***/ "(rsc)/../../node_modules/file-stream-rotator/FileStreamRotator.js":
/*!*******************************************************************!*\
  !*** ../../node_modules/file-stream-rotator/FileStreamRotator.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\n/*!\n * FileStreamRotator\n * Copyright(c) 2012-2017 Holiday Extras.\n * Copyright(c) 2017 Roger C.\n * MIT Licensed\n */\n\n/**\n * Module dependencies.\n */\nvar fs = __webpack_require__(/*! fs */ \"fs\");\nvar path = __webpack_require__(/*! path */ \"path\");\nvar moment = __webpack_require__(/*! moment */ \"(rsc)/../../node_modules/moment/moment.js\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\n\nvar EventEmitter = __webpack_require__(/*! events */ \"events\");\n\n/**\n * FileStreamRotator:\n *\n * Returns a file stream that auto-rotates based on date.\n *\n * Options:\n *\n *   - `filename`       Filename including full path used by the stream\n *\n *   - `frequency`      How often to rotate. Options are 'daily', 'custom' and 'test'. 'test' rotates every minute.\n *                      If frequency is set to none of the above, a YYYYMMDD string will be added to the end of the filename.\n *\n *   - `verbose`        If set, it will log to STDOUT when it rotates files and name of log file. Default is TRUE.\n *\n *   - `date_format`    Format as used in moment.js http://momentjs.com/docs/#/displaying/format/. The result is used to replace\n *                      the '%DATE%' placeholder in the filename.\n *                      If using 'custom' frequency, it is used to trigger file change when the string representation changes.\n *\n *   - `size`           Max size of the file after which it will rotate. It can be combined with frequency or date format.\n *                      The size units are 'k', 'm' and 'g'. Units need to directly follow a number e.g. 1g, 100m, 20k.\n *\n *   - `max_logs`       Max number of logs to keep. If not set, it won't remove past logs. It uses its own log audit file\n *                      to keep track of the log files in a json format. It won't delete any file not contained in it.\n *                      It can be a number of files or number of days. If using days, add 'd' as the suffix.\n *\n *   - `audit_file`     Location to store the log audit file. If not set, it will be stored in the root of the application.\n * \n *   - `end_stream`     End stream (true) instead of the default behaviour of destroy (false). Set value to true if when writing to the\n *                      stream in a loop, if the application terminates or log rotates, data pending to be flushed might be lost.                    \n *\n *   - `file_options`   An object passed to the stream. This can be used to specify flags, encoding, and mode.\n *                      See https://nodejs.org/api/fs.html#fs_fs_createwritestream_path_options. Default `{ flags: 'a' }`.\n * \n *   - `utc`            Use UTC time for date in filename. Defaults to 'FALSE'\n * \n *   - `extension`      File extension to be appended to the filename. This is useful when using size restrictions as the rotation\n *                      adds a count (1,2,3,4,...) at the end of the filename when the required size is met.\n * \n *   - `watch_log`      Watch the current file being written to and recreate it in case of accidental deletion. Defaults to 'FALSE'\n *\n *   - `create_symlink` Create a tailable symlink to the current active log file. Defaults to 'FALSE'\n * \n *   - `symlink_name`   Name to use when creating the symbolic link. Defaults to 'current.log'\n * \n *   - `audit_hash_type` Use specified hashing algorithm for audit. Defaults to 'md5'. Use 'sha256' for FIPS compliance.\n *\n * To use with Express / Connect, use as below.\n *\n * var rotatingLogStream = require('FileStreamRotator').getStream({filename:\"/tmp/test.log\", frequency:\"daily\", verbose: false})\n * app.use(express.logger({stream: rotatingLogStream, format: \"default\"}));\n *\n * @param {Object} options\n * @return {Object}\n * @api public\n */\nvar FileStreamRotator = {};\n\nmodule.exports = FileStreamRotator;\n\nvar staticFrequency = ['daily', 'test', 'm', 'h', 'custom'];\nvar DATE_FORMAT = ('YYYYMMDDHHmm');\n\n\n/**\n * Returns frequency metadata for minute/hour rotation\n * @param type\n * @param num\n * @returns {*}\n * @private\n */\nvar _checkNumAndType = function (type, num) {\n    if (typeof num == 'number') {\n        switch (type) {\n            case 'm':\n                if (num < 0 || num > 60) {\n                    return false;\n                }\n                break;\n            case 'h':\n                if (num < 0 || num > 24) {\n                    return false;\n                }\n                break;\n        }\n        return {type: type, digit: num};\n    }\n}\n\n/**\n * Returns frequency metadata for defined frequency\n * @param freqType\n * @returns {*}\n * @private\n */\nvar _checkDailyAndTest = function (freqType) {\n    switch (freqType) {\n        case 'custom':\n        case 'daily':\n            return {type: freqType, digit: undefined};\n            break;\n        case 'test':\n            return {type: freqType, digit: 0};\n    }\n    return false;\n}\n\n\n/**\n * Returns frequency metadata\n * @param frequency\n * @returns {*}\n */\nFileStreamRotator.getFrequency = function (frequency) {\n    var _f = frequency.toLowerCase().match(/^(\\d+)([mh])$/)\n    if(_f){\n        return _checkNumAndType(_f[2], parseInt(_f[1]));\n    }\n\n    var dailyOrTest = _checkDailyAndTest(frequency);\n    if (dailyOrTest) {\n        return dailyOrTest;\n    }\n\n    return false;\n}\n\n/**\n * Returns a number based on the option string\n * @param size\n * @returns {Number}\n */\nFileStreamRotator.parseFileSize = function (size) {\n    if(size && typeof size == \"string\"){\n        var _s = size.toLowerCase().match(/^((?:0\\.)?\\d+)([kmg])$/);\n        if(_s){\n            switch(_s[2]){\n                case 'k':\n                    return _s[1]*1024\n                case 'm':\n                    return _s[1]*1024*1024\n                case 'g':\n                    return _s[1]*1024*1024*1024\n            }\n        }\n    }\n    return null;\n};\n\n/**\n * Returns date string for a given format / date_format\n * @param format\n * @param date_format\n * @param {boolean} utc\n * @returns {string}\n */\nFileStreamRotator.getDate = function (format, date_format, utc) {\n    date_format = date_format || DATE_FORMAT;\n    let currentMoment = utc ? moment.utc() : moment().local()\n    if (format && staticFrequency.indexOf(format.type) !== -1) {\n        switch (format.type) {\n            case 'm':\n                var minute = Math.floor(currentMoment.minutes() / format.digit) * format.digit;\n                return currentMoment.minutes(minute).format(date_format);\n                break;\n            case 'h':\n                var hour = Math.floor(currentMoment.hour() / format.digit) * format.digit;\n                return currentMoment.hour(hour).format(date_format);\n                break;\n            case 'daily':\n            case 'custom':\n            case 'test':\n                return currentMoment.format(date_format);\n        }\n    }\n    return currentMoment.format(date_format);\n}\n\n/**\n * Read audit json object from disk or return new object or null\n * @param max_logs\n * @param audit_file\n * @param log_file\n * @returns {Object} auditLogSettings\n * @property {Object} auditLogSettings.keep\n * @property {Boolean} auditLogSettings.keep.days\n * @property {Number} auditLogSettings.keep.amount\n * @property {String} auditLogSettings.auditLog\n * @property {Array} auditLogSettings.files\n * @property {String} auditLogSettings.hashType\n */\nFileStreamRotator.setAuditLog = function (max_logs, audit_file, log_file){\n    var _rtn = null;\n    if(max_logs){\n        var use_days = max_logs.toString().substr(-1);\n        var _num = max_logs.toString().match(/^(\\d+)/);\n\n        if(Number(_num[1]) > 0) {\n            var baseLog = path.dirname(log_file.replace(/%DATE%.+/,\"_filename\"));\n            try{\n                if(audit_file){\n                    var full_path = path.resolve(audit_file);\n                    _rtn = JSON.parse(fs.readFileSync(full_path, { encoding: 'utf-8' }));\n                }else{\n                    var full_path = path.resolve(baseLog + \"/\" + \".audit.json\")\n                    _rtn = JSON.parse(fs.readFileSync(full_path, { encoding: 'utf-8' }));\n                }\n            }catch(e){\n                if(e.code !== \"ENOENT\"){\n                    return null;\n                }\n                _rtn = {\n                    keep: {\n                        days: false,\n                        amount: Number(_num[1])\n                    },\n                    auditLog: audit_file || baseLog + \"/\" + \".audit.json\",\n                    files: []\n                };\n            }\n\n            _rtn.keep = {\n                days: use_days === 'd',\n                amount: Number(_num[1])\n            };\n\n        }\n    }\n    return _rtn;\n};\n\n/**\n * Write audit json object to disk\n * @param {Object} audit\n * @param {Object} audit.keep\n * @param {Boolean} audit.keep.days\n * @param {Number} audit.keep.amount\n * @param {String} audit.auditLog\n * @param {Array} audit.files\n * @param {String} audit.hashType\n * @param {Boolean} verbose \n */\nFileStreamRotator.writeAuditLog = function(audit, verbose){\n    try{\n        mkDirForFile(audit.auditLog);\n        fs.writeFileSync(audit.auditLog, JSON.stringify(audit,null,4));\n    }catch(e){\n        if (verbose) {\n            console.error(new Date(),\"[FileStreamRotator] Failed to store log audit at:\", audit.auditLog,\"Error:\", e);\n        }\n    }\n};\n\n\n/**\n * Removes old log file\n * @param file\n * @param file.hash\n * @param file.name\n * @param file.date\n * @param file.hashType\n * @param {Boolean} verbose \n */\nfunction removeFile(file, verbose){\n    if(file.hash === crypto.createHash(file.hashType).update(file.name + \"LOG_FILE\" + file.date).digest(\"hex\")){\n        try{\n            if (fs.existsSync(file.name)) {\n                fs.unlinkSync(file.name);\n            }\n        }catch(e){\n            if (verbose) {\n                console.error(new Date(), \"[FileStreamRotator] Could not remove old log file: \", file.name);\n            }\n        }\n    }\n}\n\n/**\n * Create symbolic link to current log file\n * @param {String} logfile \n * @param {String} name Name to use for symbolic link \n * @param {Boolean} verbose \n */\nfunction createCurrentSymLink(logfile, name, verbose) {\n    let symLinkName = name || \"current.log\"\n    let logPath = path.dirname(logfile)\n    let logfileName = path.basename(logfile)\n    let current = logPath + \"/\" + symLinkName\n    try {\n        let stats = fs.lstatSync(current)\n        if(stats.isSymbolicLink()){\n            fs.unlinkSync(current)\n            fs.symlinkSync(logfileName, current)\n        }\n    } catch (err) {\n        if(err && err.code == \"ENOENT\") {\n            try {\n                fs.symlinkSync(logfileName, current)\n            } catch (e) {\n                if (verbose) {\n                    console.error(new Date(), \"[FileStreamRotator] Could not create symlink file: \", current, ' -> ', logfileName);\n                }\n            }\n        }\n    }\n}\n\n/**\n * \n * @param {String} logfile \n * @param {Boolean} verbose \n * @param {function} cb \n */\nfunction createLogWatcher(logfile, verbose, cb){\n    if(!logfile) return null\n    // console.log(\"Creating log watcher\")\n    try {\n        let stats = fs.lstatSync(logfile)\n        return fs.watch(logfile, function(event,filename){\n            // console.log(Date(), event, filename)\n            if(event == \"rename\"){\n                try {\n                    let stats = fs.lstatSync(logfile)\n                    // console.log(\"STATS:\", stats)\n                }catch(err){\n                    // console.log(\"ERROR:\", err)\n                    cb(err,logfile)\n                }                    \n            }\n        })\n    }catch(err){\n        if(verbose){\n            console.log(new Date(),\"[FileStreamRotator] Could not add watcher for \" + logfile);\n        }\n    }                    \n}\n\n/**\n * Write audit json object to disk\n * @param {String} logfile\n * @param {Object} audit\n * @param {Object} audit.keep\n * @param {Boolean} audit.keep.days\n * @param {Number} audit.keep.amount\n * @param {String} audit.auditLog\n * @param {String} audit.hashType\n * @param {Array} audit.files\n * @param {EventEmitter} stream\n * @param {Boolean} verbose \n */\nFileStreamRotator.addLogToAudit = function(logfile, audit, stream, verbose){\n    if(audit && audit.files){\n        // Based on contribution by @nickbug - https://github.com/nickbug\n        var index = audit.files.findIndex(function(file) {\n            return (file.name === logfile);\n        });\n        if (index !== -1) {\n            // nothing to do as entry already exists.\n            return audit;\n        }\n        var time = Date.now();\n        audit.files.push({\n            date: time,\n            name: logfile,\n            hash: crypto.createHash(audit.hashType).update(logfile + \"LOG_FILE\" + time).digest(\"hex\")\n        });\n\n        if(audit.keep.days){\n            var oldestDate = moment().subtract(audit.keep.amount,\"days\").valueOf();\n            var recentFiles = audit.files.filter(function(file){\n                if(file.date > oldestDate){\n                    return true;\n                }\n                file.hashType = audit.hashType\n                removeFile(file, verbose);\n                stream.emit(\"logRemoved\", file)\n                return false;\n            });\n            audit.files = recentFiles;\n        }else{\n            var filesToKeep = audit.files.splice(-audit.keep.amount);\n            if(audit.files.length > 0){\n                audit.files.filter(function(file){\n                    file.hashType = audit.hashType\n                    removeFile(file, verbose);\n                    stream.emit(\"logRemoved\", file)\n                    return false;\n                })\n            }\n            audit.files = filesToKeep;\n        }\n\n        FileStreamRotator.writeAuditLog(audit, verbose);\n    }\n\n    return audit;\n}\n\n/**\n *\n * @param options\n * @param options.filename\n * @param options.frequency\n * @param options.verbose\n * @param options.date_format\n * @param options.size\n * @param options.max_logs\n * @param options.audit_file\n * @param options.file_options\n * @param options.utc\n * @param options.extension File extension to be added at the end of the filename\n * @param options.watch_log\n * @param options.create_symlink\n * @param options.symlink_name\n * @param options.audit_hash_type Hash to be used to add to the audit log (md5, sha256)\n * @returns {Object} stream\n */\nFileStreamRotator.getStream = function (options) {\n    var frequencyMetaData = null;\n    var curDate = null;\n    var self = this;\n\n    if (!options.filename) {\n        console.error(new Date(),\"[FileStreamRotator] No filename supplied. Defaulting to STDOUT\");\n        return process.stdout;\n    }\n\n    if (options.frequency) {\n        frequencyMetaData = self.getFrequency(options.frequency);\n    }\n\n    let auditLog = self.setAuditLog(options.max_logs, options.audit_file, options.filename);\n    // Thanks to Means88 for PR.\n    if (auditLog != null) {\n        auditLog.hashType = (options.audit_hash_type !== undefined ? options.audit_hash_type : 'md5');\n    }\n    self.verbose = (options.verbose !== undefined ? options.verbose : true);\n\n    var fileSize = null;\n    var fileCount = 0;\n    var curSize = 0;\n    if(options.size){\n        fileSize = FileStreamRotator.parseFileSize(options.size);\n    }\n\n    var dateFormat = (options.date_format || DATE_FORMAT);\n    if(frequencyMetaData && frequencyMetaData.type == \"daily\"){\n        if(!options.date_format){\n            dateFormat = \"YYYY-MM-DD\";\n        }\n        if(moment().format(dateFormat) != moment().endOf(\"day\").format(dateFormat) || moment().format(dateFormat) == moment().add(1,\"day\").format(dateFormat)){\n            if(self.verbose){\n                console.log(new Date(),\"[FileStreamRotator] Changing type to custom as date format changes more often than once a day or not every day\");\n            }\n            frequencyMetaData.type = \"custom\";\n        }\n    }\n\n    if (frequencyMetaData) {\n        curDate = (options.frequency ? self.getDate(frequencyMetaData,dateFormat, options.utc) : \"\");\n    }\n\n    options.create_symlink = options.create_symlink || false;\n    options.extension = options.extension || \"\"\n    var filename = options.filename;\n    var oldFile = null;\n    var logfile = filename + (curDate ? \".\" + curDate : \"\");\n    if(filename.match(/%DATE%/)){\n        logfile = filename.replace(/%DATE%/g,(curDate?curDate:self.getDate(null,dateFormat, options.utc)));\n    }\n\n    if(fileSize){\n        var lastLogFile = null;\n        var t_log = logfile;\n        var f = null;\n        if(auditLog && auditLog.files && auditLog.files instanceof Array && auditLog.files.length > 0){\n            var lastEntry = auditLog.files[auditLog.files.length - 1].name;\n            if(lastEntry.match(t_log)){\n                var lastCount = lastEntry.match(t_log + \"\\\\.(\\\\d+)\");\n                // Thanks for the PR contribution from @andrefarzat - https://github.com/andrefarzat\n                if(lastCount){                    \n                    t_log = lastEntry;\n                    fileCount = lastCount[1];\n                }\n            }\n        }\n\n        if (fileCount == 0 && t_log == logfile) {\n            t_log += options.extension\n        }\n\n        while(f = fs.existsSync(t_log)){\n            lastLogFile = t_log;\n            fileCount++;\n            t_log = logfile + \".\" + fileCount + options.extension;\n        }\n        if(lastLogFile){\n            var lastLogFileStats = fs.statSync(lastLogFile);\n            if(lastLogFileStats.size < fileSize){\n                t_log = lastLogFile;\n                fileCount--;\n                curSize = lastLogFileStats.size;\n            }\n        }\n        logfile = t_log;\n    } else {\n        logfile += options.extension\n    }\n\n    if (self.verbose) {\n        console.log(new Date(),\"[FileStreamRotator] Logging to: \", logfile);\n    }\n\n    mkDirForFile(logfile);\n\n    var file_options = options.file_options || {flags: 'a'};\n    var rotateStream = fs.createWriteStream(logfile, file_options);\n    if ((curDate && frequencyMetaData && (staticFrequency.indexOf(frequencyMetaData.type) > -1)) || fileSize > 0) {\n        if (self.verbose) {\n            console.log(new Date(),\"[FileStreamRotator] Rotating file: \", frequencyMetaData?frequencyMetaData.type:\"\", fileSize?\"size: \" + fileSize:\"\");\n        }\n        var stream = new EventEmitter();\n        stream.auditLog = auditLog;\n        stream.end = function(){\n            rotateStream.end.apply(rotateStream,arguments);\n        };\n        BubbleEvents(rotateStream,stream);\n\n        stream.on('close', function(){\n            if (logWatcher) {\n                logWatcher.close()\n            }\n        })\n\n        stream.on(\"new\",function(newLog){\n            // console.log(\"new log\", newLog)\n            stream.auditLog = self.addLogToAudit(newLog,stream.auditLog, stream, self.verbose)\n            if(options.create_symlink){\n                createCurrentSymLink(newLog, options.symlink_name, self.verbose)\n            }\n            if(options.watch_log){\n                stream.emit(\"addWatcher\", newLog)\n            }\n        });\n        \n        var logWatcher;\n        stream.on(\"addWatcher\", function(newLog){\n            if (logWatcher) {\n                logWatcher.close()\n            }\n            if(!options.watch_log){\n                return\n            }\n            // console.log(\"ADDING WATCHER\", newLog)\n            logWatcher = createLogWatcher(newLog, self.verbose, function(err,newLog){\n                stream.emit('createLog', newLog)\n            })        \n        })\n\n        stream.on(\"createLog\",function(file){\n            try {\n                let stats = fs.lstatSync(file)\n            }catch(err){\n                if(rotateStream && rotateStream.end == \"function\"){\n                    rotateStream.end();\n                }\n                rotateStream = fs.createWriteStream(file, file_options);\n                stream.emit('new',file);\n                BubbleEvents(rotateStream,stream);\n            }\n        });\n\n\n        stream.write = (function (str, encoding) {\n            var newDate = frequencyMetaData ? this.getDate(frequencyMetaData, dateFormat, options.utc) : curDate;\n            if (newDate != curDate || (fileSize && curSize > fileSize)) {\n                var newLogfile = filename + (curDate && frequencyMetaData ? \".\" + newDate : \"\");\n                if(filename.match(/%DATE%/) && curDate){\n                    newLogfile = filename.replace(/%DATE%/g,newDate);\n                }\n\n                if(fileSize && curSize > fileSize){\n                    fileCount++;\n                    newLogfile += \".\" + fileCount + options.extension;\n                }else{\n                    // reset file count\n                    fileCount = 0;\n                    newLogfile += options.extension\n                }\n                curSize = 0;\n\n                if (self.verbose) {\n                    console.log(new Date(),(__webpack_require__(/*! util */ \"util\").format)(\"[FileStreamRotator] Changing logs from %s to %s\", logfile, newLogfile));\n                }\n                curDate = newDate;\n                oldFile = logfile;\n                logfile = newLogfile;\n                // Thanks to @mattberther https://github.com/mattberther for raising it again.\n                if(options.end_stream === true){\n                    rotateStream.end();\n                }else{\n                    rotateStream.destroy();\n                }\n\n                mkDirForFile(logfile);\n\n                rotateStream = fs.createWriteStream(newLogfile, file_options);\n                stream.emit('new',newLogfile);\n                stream.emit('rotate',oldFile, newLogfile);\n                BubbleEvents(rotateStream,stream);\n            }\n            rotateStream.write(str, encoding);\n            // Handle length of double-byte characters\n            curSize += Buffer.byteLength(str, encoding);\n        }).bind(this);\n        process.nextTick(function(){\n            stream.emit('new',logfile);\n        })\n        stream.emit('new',logfile)\n        return stream;\n    } else {\n        if (self.verbose) {\n            console.log(new Date(),\"[FileStreamRotator] File won't be rotated: \", options.frequency, options.size);\n        }\n        process.nextTick(function(){\n            rotateStream.emit('new',logfile);\n        })\n        return rotateStream;\n    }\n}\n\n/**\n * Check and make parent directory\n * @param pathWithFile\n */\nvar mkDirForFile = function(pathWithFile){\n    var _path = path.dirname(pathWithFile);\n    _path.split(path.sep).reduce(\n        function(fullPath, folder) {\n            fullPath += folder + path.sep;\n            // Option to replace existsSync as deprecated. Maybe in a future release.\n            // try{\n            //     var stats = fs.statSync(fullPath);\n            //     console.log('STATS',fullPath, stats);\n            // }catch(e){\n            //     fs.mkdirSync(fullPath);\n            //     console.log(\"STATS ERROR\",e)\n            // }\n            if (!fs.existsSync(fullPath)) {\n                try{\n                    fs.mkdirSync(fullPath);\n                }catch(e){\n                    if(e.code !== 'EEXIST'){\n                        throw e;\n                    }\n                }\n            }\n            return fullPath;\n        },\n        ''\n    );\n};\n\n\n/**\n * Bubbles events to the proxy\n * @param emitter\n * @param proxy\n * @constructor\n */\nvar BubbleEvents = function BubbleEvents(emitter,proxy){\n    emitter.on('close',function(){\n        proxy.emit('close');\n    })\n    emitter.on('finish',function(){\n        proxy.emit('finish');\n    })\n    emitter.on('error',function(err){\n        proxy.emit('error',err);\n    })\n    emitter.on('open',function(fd){\n        proxy.emit('open',fd);\n    })\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL2ZpbGUtc3RyZWFtLXJvdGF0b3IvRmlsZVN0cmVhbVJvdGF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsbUJBQU8sQ0FBQyxjQUFJO0FBQ3JCLFdBQVcsbUJBQU8sQ0FBQyxrQkFBTTtBQUN6QixhQUFhLG1CQUFPLENBQUMseURBQVE7QUFDN0IsYUFBYSxtQkFBTyxDQUFDLHNCQUFROztBQUU3QixtQkFBbUIsbUJBQU8sQ0FBQyxzQkFBUTs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0R0FBNEcsWUFBWTtBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSw0REFBNEQ7QUFDL0gsMkJBQTJCLDZDQUE2QztBQUN4RTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFNBQVM7QUFDdkIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLE9BQU87QUFDckIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLG1CQUFtQjtBQUN0RixpQkFBaUI7QUFDakI7QUFDQSxtRUFBbUUsbUJBQW1CO0FBQ3RGO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU87QUFDbEIsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkMsZ0RBQXNCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCIsInNvdXJjZXMiOlsiL1VzZXJzL21hcmt1c2hvZ25lL0RvY3VtZW50cy9BUFBTL2JhemFhci12aWQvYmF6YWFyLXZpZC9ub2RlX21vZHVsZXMvZmlsZS1zdHJlYW0tcm90YXRvci9GaWxlU3RyZWFtUm90YXRvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbi8qIVxuICogRmlsZVN0cmVhbVJvdGF0b3JcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTcgSG9saWRheSBFeHRyYXMuXG4gKiBDb3B5cmlnaHQoYykgMjAxNyBSb2dlciBDLlxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG52YXIgZnMgPSByZXF1aXJlKCdmcycpO1xudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG52YXIgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50Jyk7XG52YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKTtcblxuLyoqXG4gKiBGaWxlU3RyZWFtUm90YXRvcjpcbiAqXG4gKiBSZXR1cm5zIGEgZmlsZSBzdHJlYW0gdGhhdCBhdXRvLXJvdGF0ZXMgYmFzZWQgb24gZGF0ZS5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAgLSBgZmlsZW5hbWVgICAgICAgIEZpbGVuYW1lIGluY2x1ZGluZyBmdWxsIHBhdGggdXNlZCBieSB0aGUgc3RyZWFtXG4gKlxuICogICAtIGBmcmVxdWVuY3lgICAgICAgSG93IG9mdGVuIHRvIHJvdGF0ZS4gT3B0aW9ucyBhcmUgJ2RhaWx5JywgJ2N1c3RvbScgYW5kICd0ZXN0Jy4gJ3Rlc3QnIHJvdGF0ZXMgZXZlcnkgbWludXRlLlxuICogICAgICAgICAgICAgICAgICAgICAgSWYgZnJlcXVlbmN5IGlzIHNldCB0byBub25lIG9mIHRoZSBhYm92ZSwgYSBZWVlZTU1ERCBzdHJpbmcgd2lsbCBiZSBhZGRlZCB0byB0aGUgZW5kIG9mIHRoZSBmaWxlbmFtZS5cbiAqXG4gKiAgIC0gYHZlcmJvc2VgICAgICAgICBJZiBzZXQsIGl0IHdpbGwgbG9nIHRvIFNURE9VVCB3aGVuIGl0IHJvdGF0ZXMgZmlsZXMgYW5kIG5hbWUgb2YgbG9nIGZpbGUuIERlZmF1bHQgaXMgVFJVRS5cbiAqXG4gKiAgIC0gYGRhdGVfZm9ybWF0YCAgICBGb3JtYXQgYXMgdXNlZCBpbiBtb21lbnQuanMgaHR0cDovL21vbWVudGpzLmNvbS9kb2NzLyMvZGlzcGxheWluZy9mb3JtYXQvLiBUaGUgcmVzdWx0IGlzIHVzZWQgdG8gcmVwbGFjZVxuICogICAgICAgICAgICAgICAgICAgICAgdGhlICclREFURSUnIHBsYWNlaG9sZGVyIGluIHRoZSBmaWxlbmFtZS5cbiAqICAgICAgICAgICAgICAgICAgICAgIElmIHVzaW5nICdjdXN0b20nIGZyZXF1ZW5jeSwgaXQgaXMgdXNlZCB0byB0cmlnZ2VyIGZpbGUgY2hhbmdlIHdoZW4gdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBjaGFuZ2VzLlxuICpcbiAqICAgLSBgc2l6ZWAgICAgICAgICAgIE1heCBzaXplIG9mIHRoZSBmaWxlIGFmdGVyIHdoaWNoIGl0IHdpbGwgcm90YXRlLiBJdCBjYW4gYmUgY29tYmluZWQgd2l0aCBmcmVxdWVuY3kgb3IgZGF0ZSBmb3JtYXQuXG4gKiAgICAgICAgICAgICAgICAgICAgICBUaGUgc2l6ZSB1bml0cyBhcmUgJ2snLCAnbScgYW5kICdnJy4gVW5pdHMgbmVlZCB0byBkaXJlY3RseSBmb2xsb3cgYSBudW1iZXIgZS5nLiAxZywgMTAwbSwgMjBrLlxuICpcbiAqICAgLSBgbWF4X2xvZ3NgICAgICAgIE1heCBudW1iZXIgb2YgbG9ncyB0byBrZWVwLiBJZiBub3Qgc2V0LCBpdCB3b24ndCByZW1vdmUgcGFzdCBsb2dzLiBJdCB1c2VzIGl0cyBvd24gbG9nIGF1ZGl0IGZpbGVcbiAqICAgICAgICAgICAgICAgICAgICAgIHRvIGtlZXAgdHJhY2sgb2YgdGhlIGxvZyBmaWxlcyBpbiBhIGpzb24gZm9ybWF0LiBJdCB3b24ndCBkZWxldGUgYW55IGZpbGUgbm90IGNvbnRhaW5lZCBpbiBpdC5cbiAqICAgICAgICAgICAgICAgICAgICAgIEl0IGNhbiBiZSBhIG51bWJlciBvZiBmaWxlcyBvciBudW1iZXIgb2YgZGF5cy4gSWYgdXNpbmcgZGF5cywgYWRkICdkJyBhcyB0aGUgc3VmZml4LlxuICpcbiAqICAgLSBgYXVkaXRfZmlsZWAgICAgIExvY2F0aW9uIHRvIHN0b3JlIHRoZSBsb2cgYXVkaXQgZmlsZS4gSWYgbm90IHNldCwgaXQgd2lsbCBiZSBzdG9yZWQgaW4gdGhlIHJvb3Qgb2YgdGhlIGFwcGxpY2F0aW9uLlxuICogXG4gKiAgIC0gYGVuZF9zdHJlYW1gICAgICBFbmQgc3RyZWFtICh0cnVlKSBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IGJlaGF2aW91ciBvZiBkZXN0cm95IChmYWxzZSkuIFNldCB2YWx1ZSB0byB0cnVlIGlmIHdoZW4gd3JpdGluZyB0byB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbSBpbiBhIGxvb3AsIGlmIHRoZSBhcHBsaWNhdGlvbiB0ZXJtaW5hdGVzIG9yIGxvZyByb3RhdGVzLCBkYXRhIHBlbmRpbmcgdG8gYmUgZmx1c2hlZCBtaWdodCBiZSBsb3N0LiAgICAgICAgICAgICAgICAgICAgXG4gKlxuICogICAtIGBmaWxlX29wdGlvbnNgICAgQW4gb2JqZWN0IHBhc3NlZCB0byB0aGUgc3RyZWFtLiBUaGlzIGNhbiBiZSB1c2VkIHRvIHNwZWNpZnkgZmxhZ3MsIGVuY29kaW5nLCBhbmQgbW9kZS5cbiAqICAgICAgICAgICAgICAgICAgICAgIFNlZSBodHRwczovL25vZGVqcy5vcmcvYXBpL2ZzLmh0bWwjZnNfZnNfY3JlYXRld3JpdGVzdHJlYW1fcGF0aF9vcHRpb25zLiBEZWZhdWx0IGB7IGZsYWdzOiAnYScgfWAuXG4gKiBcbiAqICAgLSBgdXRjYCAgICAgICAgICAgIFVzZSBVVEMgdGltZSBmb3IgZGF0ZSBpbiBmaWxlbmFtZS4gRGVmYXVsdHMgdG8gJ0ZBTFNFJ1xuICogXG4gKiAgIC0gYGV4dGVuc2lvbmAgICAgICBGaWxlIGV4dGVuc2lvbiB0byBiZSBhcHBlbmRlZCB0byB0aGUgZmlsZW5hbWUuIFRoaXMgaXMgdXNlZnVsIHdoZW4gdXNpbmcgc2l6ZSByZXN0cmljdGlvbnMgYXMgdGhlIHJvdGF0aW9uXG4gKiAgICAgICAgICAgICAgICAgICAgICBhZGRzIGEgY291bnQgKDEsMiwzLDQsLi4uKSBhdCB0aGUgZW5kIG9mIHRoZSBmaWxlbmFtZSB3aGVuIHRoZSByZXF1aXJlZCBzaXplIGlzIG1ldC5cbiAqIFxuICogICAtIGB3YXRjaF9sb2dgICAgICAgV2F0Y2ggdGhlIGN1cnJlbnQgZmlsZSBiZWluZyB3cml0dGVuIHRvIGFuZCByZWNyZWF0ZSBpdCBpbiBjYXNlIG9mIGFjY2lkZW50YWwgZGVsZXRpb24uIERlZmF1bHRzIHRvICdGQUxTRSdcbiAqXG4gKiAgIC0gYGNyZWF0ZV9zeW1saW5rYCBDcmVhdGUgYSB0YWlsYWJsZSBzeW1saW5rIHRvIHRoZSBjdXJyZW50IGFjdGl2ZSBsb2cgZmlsZS4gRGVmYXVsdHMgdG8gJ0ZBTFNFJ1xuICogXG4gKiAgIC0gYHN5bWxpbmtfbmFtZWAgICBOYW1lIHRvIHVzZSB3aGVuIGNyZWF0aW5nIHRoZSBzeW1ib2xpYyBsaW5rLiBEZWZhdWx0cyB0byAnY3VycmVudC5sb2cnXG4gKiBcbiAqICAgLSBgYXVkaXRfaGFzaF90eXBlYCBVc2Ugc3BlY2lmaWVkIGhhc2hpbmcgYWxnb3JpdGhtIGZvciBhdWRpdC4gRGVmYXVsdHMgdG8gJ21kNScuIFVzZSAnc2hhMjU2JyBmb3IgRklQUyBjb21wbGlhbmNlLlxuICpcbiAqIFRvIHVzZSB3aXRoIEV4cHJlc3MgLyBDb25uZWN0LCB1c2UgYXMgYmVsb3cuXG4gKlxuICogdmFyIHJvdGF0aW5nTG9nU3RyZWFtID0gcmVxdWlyZSgnRmlsZVN0cmVhbVJvdGF0b3InKS5nZXRTdHJlYW0oe2ZpbGVuYW1lOlwiL3RtcC90ZXN0LmxvZ1wiLCBmcmVxdWVuY3k6XCJkYWlseVwiLCB2ZXJib3NlOiBmYWxzZX0pXG4gKiBhcHAudXNlKGV4cHJlc3MubG9nZ2VyKHtzdHJlYW06IHJvdGF0aW5nTG9nU3RyZWFtLCBmb3JtYXQ6IFwiZGVmYXVsdFwifSkpO1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG52YXIgRmlsZVN0cmVhbVJvdGF0b3IgPSB7fTtcblxubW9kdWxlLmV4cG9ydHMgPSBGaWxlU3RyZWFtUm90YXRvcjtcblxudmFyIHN0YXRpY0ZyZXF1ZW5jeSA9IFsnZGFpbHknLCAndGVzdCcsICdtJywgJ2gnLCAnY3VzdG9tJ107XG52YXIgREFURV9GT1JNQVQgPSAoJ1lZWVlNTURESEhtbScpO1xuXG5cbi8qKlxuICogUmV0dXJucyBmcmVxdWVuY3kgbWV0YWRhdGEgZm9yIG1pbnV0ZS9ob3VyIHJvdGF0aW9uXG4gKiBAcGFyYW0gdHlwZVxuICogQHBhcmFtIG51bVxuICogQHJldHVybnMgeyp9XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgX2NoZWNrTnVtQW5kVHlwZSA9IGZ1bmN0aW9uICh0eXBlLCBudW0pIHtcbiAgICBpZiAodHlwZW9mIG51bSA9PSAnbnVtYmVyJykge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ20nOlxuICAgICAgICAgICAgICAgIGlmIChudW0gPCAwIHx8IG51bSA+IDYwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgICAgICAgICBpZiAobnVtIDwgMCB8fCBudW0gPiAyNCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7dHlwZTogdHlwZSwgZGlnaXQ6IG51bX07XG4gICAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgZnJlcXVlbmN5IG1ldGFkYXRhIGZvciBkZWZpbmVkIGZyZXF1ZW5jeVxuICogQHBhcmFtIGZyZXFUeXBlXG4gKiBAcmV0dXJucyB7Kn1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBfY2hlY2tEYWlseUFuZFRlc3QgPSBmdW5jdGlvbiAoZnJlcVR5cGUpIHtcbiAgICBzd2l0Y2ggKGZyZXFUeXBlKSB7XG4gICAgICAgIGNhc2UgJ2N1c3RvbSc6XG4gICAgICAgIGNhc2UgJ2RhaWx5JzpcbiAgICAgICAgICAgIHJldHVybiB7dHlwZTogZnJlcVR5cGUsIGRpZ2l0OiB1bmRlZmluZWR9O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3Rlc3QnOlxuICAgICAgICAgICAgcmV0dXJuIHt0eXBlOiBmcmVxVHlwZSwgZGlnaXQ6IDB9O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cblxuLyoqXG4gKiBSZXR1cm5zIGZyZXF1ZW5jeSBtZXRhZGF0YVxuICogQHBhcmFtIGZyZXF1ZW5jeVxuICogQHJldHVybnMgeyp9XG4gKi9cbkZpbGVTdHJlYW1Sb3RhdG9yLmdldEZyZXF1ZW5jeSA9IGZ1bmN0aW9uIChmcmVxdWVuY3kpIHtcbiAgICB2YXIgX2YgPSBmcmVxdWVuY3kudG9Mb3dlckNhc2UoKS5tYXRjaCgvXihcXGQrKShbbWhdKSQvKVxuICAgIGlmKF9mKXtcbiAgICAgICAgcmV0dXJuIF9jaGVja051bUFuZFR5cGUoX2ZbMl0sIHBhcnNlSW50KF9mWzFdKSk7XG4gICAgfVxuXG4gICAgdmFyIGRhaWx5T3JUZXN0ID0gX2NoZWNrRGFpbHlBbmRUZXN0KGZyZXF1ZW5jeSk7XG4gICAgaWYgKGRhaWx5T3JUZXN0KSB7XG4gICAgICAgIHJldHVybiBkYWlseU9yVGVzdDtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIG51bWJlciBiYXNlZCBvbiB0aGUgb3B0aW9uIHN0cmluZ1xuICogQHBhcmFtIHNpemVcbiAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gKi9cbkZpbGVTdHJlYW1Sb3RhdG9yLnBhcnNlRmlsZVNpemUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICAgIGlmKHNpemUgJiYgdHlwZW9mIHNpemUgPT0gXCJzdHJpbmdcIil7XG4gICAgICAgIHZhciBfcyA9IHNpemUudG9Mb3dlckNhc2UoKS5tYXRjaCgvXigoPzowXFwuKT9cXGQrKShba21nXSkkLyk7XG4gICAgICAgIGlmKF9zKXtcbiAgICAgICAgICAgIHN3aXRjaChfc1syXSl7XG4gICAgICAgICAgICAgICAgY2FzZSAnayc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfc1sxXSoxMDI0XG4gICAgICAgICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfc1sxXSoxMDI0KjEwMjRcbiAgICAgICAgICAgICAgICBjYXNlICdnJzpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9zWzFdKjEwMjQqMTAyNCoxMDI0XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG4vKipcbiAqIFJldHVybnMgZGF0ZSBzdHJpbmcgZm9yIGEgZ2l2ZW4gZm9ybWF0IC8gZGF0ZV9mb3JtYXRcbiAqIEBwYXJhbSBmb3JtYXRcbiAqIEBwYXJhbSBkYXRlX2Zvcm1hdFxuICogQHBhcmFtIHtib29sZWFufSB1dGNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbkZpbGVTdHJlYW1Sb3RhdG9yLmdldERhdGUgPSBmdW5jdGlvbiAoZm9ybWF0LCBkYXRlX2Zvcm1hdCwgdXRjKSB7XG4gICAgZGF0ZV9mb3JtYXQgPSBkYXRlX2Zvcm1hdCB8fCBEQVRFX0ZPUk1BVDtcbiAgICBsZXQgY3VycmVudE1vbWVudCA9IHV0YyA/IG1vbWVudC51dGMoKSA6IG1vbWVudCgpLmxvY2FsKClcbiAgICBpZiAoZm9ybWF0ICYmIHN0YXRpY0ZyZXF1ZW5jeS5pbmRleE9mKGZvcm1hdC50eXBlKSAhPT0gLTEpIHtcbiAgICAgICAgc3dpdGNoIChmb3JtYXQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICAgICAgdmFyIG1pbnV0ZSA9IE1hdGguZmxvb3IoY3VycmVudE1vbWVudC5taW51dGVzKCkgLyBmb3JtYXQuZGlnaXQpICogZm9ybWF0LmRpZ2l0O1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50TW9tZW50Lm1pbnV0ZXMobWludXRlKS5mb3JtYXQoZGF0ZV9mb3JtYXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaCc6XG4gICAgICAgICAgICAgICAgdmFyIGhvdXIgPSBNYXRoLmZsb29yKGN1cnJlbnRNb21lbnQuaG91cigpIC8gZm9ybWF0LmRpZ2l0KSAqIGZvcm1hdC5kaWdpdDtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudE1vbWVudC5ob3VyKGhvdXIpLmZvcm1hdChkYXRlX2Zvcm1hdCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkYWlseSc6XG4gICAgICAgICAgICBjYXNlICdjdXN0b20nOlxuICAgICAgICAgICAgY2FzZSAndGVzdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRNb21lbnQuZm9ybWF0KGRhdGVfZm9ybWF0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3VycmVudE1vbWVudC5mb3JtYXQoZGF0ZV9mb3JtYXQpO1xufVxuXG4vKipcbiAqIFJlYWQgYXVkaXQganNvbiBvYmplY3QgZnJvbSBkaXNrIG9yIHJldHVybiBuZXcgb2JqZWN0IG9yIG51bGxcbiAqIEBwYXJhbSBtYXhfbG9nc1xuICogQHBhcmFtIGF1ZGl0X2ZpbGVcbiAqIEBwYXJhbSBsb2dfZmlsZVxuICogQHJldHVybnMge09iamVjdH0gYXVkaXRMb2dTZXR0aW5nc1xuICogQHByb3BlcnR5IHtPYmplY3R9IGF1ZGl0TG9nU2V0dGluZ3Mua2VlcFxuICogQHByb3BlcnR5IHtCb29sZWFufSBhdWRpdExvZ1NldHRpbmdzLmtlZXAuZGF5c1xuICogQHByb3BlcnR5IHtOdW1iZXJ9IGF1ZGl0TG9nU2V0dGluZ3Mua2VlcC5hbW91bnRcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBhdWRpdExvZ1NldHRpbmdzLmF1ZGl0TG9nXG4gKiBAcHJvcGVydHkge0FycmF5fSBhdWRpdExvZ1NldHRpbmdzLmZpbGVzXG4gKiBAcHJvcGVydHkge1N0cmluZ30gYXVkaXRMb2dTZXR0aW5ncy5oYXNoVHlwZVxuICovXG5GaWxlU3RyZWFtUm90YXRvci5zZXRBdWRpdExvZyA9IGZ1bmN0aW9uIChtYXhfbG9ncywgYXVkaXRfZmlsZSwgbG9nX2ZpbGUpe1xuICAgIHZhciBfcnRuID0gbnVsbDtcbiAgICBpZihtYXhfbG9ncyl7XG4gICAgICAgIHZhciB1c2VfZGF5cyA9IG1heF9sb2dzLnRvU3RyaW5nKCkuc3Vic3RyKC0xKTtcbiAgICAgICAgdmFyIF9udW0gPSBtYXhfbG9ncy50b1N0cmluZygpLm1hdGNoKC9eKFxcZCspLyk7XG5cbiAgICAgICAgaWYoTnVtYmVyKF9udW1bMV0pID4gMCkge1xuICAgICAgICAgICAgdmFyIGJhc2VMb2cgPSBwYXRoLmRpcm5hbWUobG9nX2ZpbGUucmVwbGFjZSgvJURBVEUlLisvLFwiX2ZpbGVuYW1lXCIpKTtcbiAgICAgICAgICAgIHRyeXtcbiAgICAgICAgICAgICAgICBpZihhdWRpdF9maWxlKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZ1bGxfcGF0aCA9IHBhdGgucmVzb2x2ZShhdWRpdF9maWxlKTtcbiAgICAgICAgICAgICAgICAgICAgX3J0biA9IEpTT04ucGFyc2UoZnMucmVhZEZpbGVTeW5jKGZ1bGxfcGF0aCwgeyBlbmNvZGluZzogJ3V0Zi04JyB9KSk7XG4gICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmdWxsX3BhdGggPSBwYXRoLnJlc29sdmUoYmFzZUxvZyArIFwiL1wiICsgXCIuYXVkaXQuanNvblwiKVxuICAgICAgICAgICAgICAgICAgICBfcnRuID0gSlNPTi5wYXJzZShmcy5yZWFkRmlsZVN5bmMoZnVsbF9wYXRoLCB7IGVuY29kaW5nOiAndXRmLTgnIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9Y2F0Y2goZSl7XG4gICAgICAgICAgICAgICAgaWYoZS5jb2RlICE9PSBcIkVOT0VOVFwiKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9ydG4gPSB7XG4gICAgICAgICAgICAgICAgICAgIGtlZXA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRheXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYW1vdW50OiBOdW1iZXIoX251bVsxXSlcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgYXVkaXRMb2c6IGF1ZGl0X2ZpbGUgfHwgYmFzZUxvZyArIFwiL1wiICsgXCIuYXVkaXQuanNvblwiLFxuICAgICAgICAgICAgICAgICAgICBmaWxlczogW11cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBfcnRuLmtlZXAgPSB7XG4gICAgICAgICAgICAgICAgZGF5czogdXNlX2RheXMgPT09ICdkJyxcbiAgICAgICAgICAgICAgICBhbW91bnQ6IE51bWJlcihfbnVtWzFdKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBfcnRuO1xufTtcblxuLyoqXG4gKiBXcml0ZSBhdWRpdCBqc29uIG9iamVjdCB0byBkaXNrXG4gKiBAcGFyYW0ge09iamVjdH0gYXVkaXRcbiAqIEBwYXJhbSB7T2JqZWN0fSBhdWRpdC5rZWVwXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGF1ZGl0LmtlZXAuZGF5c1xuICogQHBhcmFtIHtOdW1iZXJ9IGF1ZGl0LmtlZXAuYW1vdW50XG4gKiBAcGFyYW0ge1N0cmluZ30gYXVkaXQuYXVkaXRMb2dcbiAqIEBwYXJhbSB7QXJyYXl9IGF1ZGl0LmZpbGVzXG4gKiBAcGFyYW0ge1N0cmluZ30gYXVkaXQuaGFzaFR5cGVcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdmVyYm9zZSBcbiAqL1xuRmlsZVN0cmVhbVJvdGF0b3Iud3JpdGVBdWRpdExvZyA9IGZ1bmN0aW9uKGF1ZGl0LCB2ZXJib3NlKXtcbiAgICB0cnl7XG4gICAgICAgIG1rRGlyRm9yRmlsZShhdWRpdC5hdWRpdExvZyk7XG4gICAgICAgIGZzLndyaXRlRmlsZVN5bmMoYXVkaXQuYXVkaXRMb2csIEpTT04uc3RyaW5naWZ5KGF1ZGl0LG51bGwsNCkpO1xuICAgIH1jYXRjaChlKXtcbiAgICAgICAgaWYgKHZlcmJvc2UpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IobmV3IERhdGUoKSxcIltGaWxlU3RyZWFtUm90YXRvcl0gRmFpbGVkIHRvIHN0b3JlIGxvZyBhdWRpdCBhdDpcIiwgYXVkaXQuYXVkaXRMb2csXCJFcnJvcjpcIiwgZSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5cbi8qKlxuICogUmVtb3ZlcyBvbGQgbG9nIGZpbGVcbiAqIEBwYXJhbSBmaWxlXG4gKiBAcGFyYW0gZmlsZS5oYXNoXG4gKiBAcGFyYW0gZmlsZS5uYW1lXG4gKiBAcGFyYW0gZmlsZS5kYXRlXG4gKiBAcGFyYW0gZmlsZS5oYXNoVHlwZVxuICogQHBhcmFtIHtCb29sZWFufSB2ZXJib3NlIFxuICovXG5mdW5jdGlvbiByZW1vdmVGaWxlKGZpbGUsIHZlcmJvc2Upe1xuICAgIGlmKGZpbGUuaGFzaCA9PT0gY3J5cHRvLmNyZWF0ZUhhc2goZmlsZS5oYXNoVHlwZSkudXBkYXRlKGZpbGUubmFtZSArIFwiTE9HX0ZJTEVcIiArIGZpbGUuZGF0ZSkuZGlnZXN0KFwiaGV4XCIpKXtcbiAgICAgICAgdHJ5e1xuICAgICAgICAgICAgaWYgKGZzLmV4aXN0c1N5bmMoZmlsZS5uYW1lKSkge1xuICAgICAgICAgICAgICAgIGZzLnVubGlua1N5bmMoZmlsZS5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfWNhdGNoKGUpe1xuICAgICAgICAgICAgaWYgKHZlcmJvc2UpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKG5ldyBEYXRlKCksIFwiW0ZpbGVTdHJlYW1Sb3RhdG9yXSBDb3VsZCBub3QgcmVtb3ZlIG9sZCBsb2cgZmlsZTogXCIsIGZpbGUubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIHN5bWJvbGljIGxpbmsgdG8gY3VycmVudCBsb2cgZmlsZVxuICogQHBhcmFtIHtTdHJpbmd9IGxvZ2ZpbGUgXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBOYW1lIHRvIHVzZSBmb3Igc3ltYm9saWMgbGluayBcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdmVyYm9zZSBcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ3VycmVudFN5bUxpbmsobG9nZmlsZSwgbmFtZSwgdmVyYm9zZSkge1xuICAgIGxldCBzeW1MaW5rTmFtZSA9IG5hbWUgfHwgXCJjdXJyZW50LmxvZ1wiXG4gICAgbGV0IGxvZ1BhdGggPSBwYXRoLmRpcm5hbWUobG9nZmlsZSlcbiAgICBsZXQgbG9nZmlsZU5hbWUgPSBwYXRoLmJhc2VuYW1lKGxvZ2ZpbGUpXG4gICAgbGV0IGN1cnJlbnQgPSBsb2dQYXRoICsgXCIvXCIgKyBzeW1MaW5rTmFtZVxuICAgIHRyeSB7XG4gICAgICAgIGxldCBzdGF0cyA9IGZzLmxzdGF0U3luYyhjdXJyZW50KVxuICAgICAgICBpZihzdGF0cy5pc1N5bWJvbGljTGluaygpKXtcbiAgICAgICAgICAgIGZzLnVubGlua1N5bmMoY3VycmVudClcbiAgICAgICAgICAgIGZzLnN5bWxpbmtTeW5jKGxvZ2ZpbGVOYW1lLCBjdXJyZW50KVxuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGlmKGVyciAmJiBlcnIuY29kZSA9PSBcIkVOT0VOVFwiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZzLnN5bWxpbmtTeW5jKGxvZ2ZpbGVOYW1lLCBjdXJyZW50KVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmICh2ZXJib3NlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IobmV3IERhdGUoKSwgXCJbRmlsZVN0cmVhbVJvdGF0b3JdIENvdWxkIG5vdCBjcmVhdGUgc3ltbGluayBmaWxlOiBcIiwgY3VycmVudCwgJyAtPiAnLCBsb2dmaWxlTmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIFxuICogQHBhcmFtIHtTdHJpbmd9IGxvZ2ZpbGUgXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHZlcmJvc2UgXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYiBcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTG9nV2F0Y2hlcihsb2dmaWxlLCB2ZXJib3NlLCBjYil7XG4gICAgaWYoIWxvZ2ZpbGUpIHJldHVybiBudWxsXG4gICAgLy8gY29uc29sZS5sb2coXCJDcmVhdGluZyBsb2cgd2F0Y2hlclwiKVxuICAgIHRyeSB7XG4gICAgICAgIGxldCBzdGF0cyA9IGZzLmxzdGF0U3luYyhsb2dmaWxlKVxuICAgICAgICByZXR1cm4gZnMud2F0Y2gobG9nZmlsZSwgZnVuY3Rpb24oZXZlbnQsZmlsZW5hbWUpe1xuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coRGF0ZSgpLCBldmVudCwgZmlsZW5hbWUpXG4gICAgICAgICAgICBpZihldmVudCA9PSBcInJlbmFtZVwiKXtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgc3RhdHMgPSBmcy5sc3RhdFN5bmMobG9nZmlsZSlcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJTVEFUUzpcIiwgc3RhdHMpXG4gICAgICAgICAgICAgICAgfWNhdGNoKGVycil7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiRVJST1I6XCIsIGVycilcbiAgICAgICAgICAgICAgICAgICAgY2IoZXJyLGxvZ2ZpbGUpXG4gICAgICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfWNhdGNoKGVycil7XG4gICAgICAgIGlmKHZlcmJvc2Upe1xuICAgICAgICAgICAgY29uc29sZS5sb2cobmV3IERhdGUoKSxcIltGaWxlU3RyZWFtUm90YXRvcl0gQ291bGQgbm90IGFkZCB3YXRjaGVyIGZvciBcIiArIGxvZ2ZpbGUpO1xuICAgICAgICB9XG4gICAgfSAgICAgICAgICAgICAgICAgICAgXG59XG5cbi8qKlxuICogV3JpdGUgYXVkaXQganNvbiBvYmplY3QgdG8gZGlza1xuICogQHBhcmFtIHtTdHJpbmd9IGxvZ2ZpbGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBhdWRpdFxuICogQHBhcmFtIHtPYmplY3R9IGF1ZGl0LmtlZXBcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYXVkaXQua2VlcC5kYXlzXG4gKiBAcGFyYW0ge051bWJlcn0gYXVkaXQua2VlcC5hbW91bnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdWRpdC5hdWRpdExvZ1xuICogQHBhcmFtIHtTdHJpbmd9IGF1ZGl0Lmhhc2hUeXBlXG4gKiBAcGFyYW0ge0FycmF5fSBhdWRpdC5maWxlc1xuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IHN0cmVhbVxuICogQHBhcmFtIHtCb29sZWFufSB2ZXJib3NlIFxuICovXG5GaWxlU3RyZWFtUm90YXRvci5hZGRMb2dUb0F1ZGl0ID0gZnVuY3Rpb24obG9nZmlsZSwgYXVkaXQsIHN0cmVhbSwgdmVyYm9zZSl7XG4gICAgaWYoYXVkaXQgJiYgYXVkaXQuZmlsZXMpe1xuICAgICAgICAvLyBCYXNlZCBvbiBjb250cmlidXRpb24gYnkgQG5pY2tidWcgLSBodHRwczovL2dpdGh1Yi5jb20vbmlja2J1Z1xuICAgICAgICB2YXIgaW5kZXggPSBhdWRpdC5maWxlcy5maW5kSW5kZXgoZnVuY3Rpb24oZmlsZSkge1xuICAgICAgICAgICAgcmV0dXJuIChmaWxlLm5hbWUgPT09IGxvZ2ZpbGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgLy8gbm90aGluZyB0byBkbyBhcyBlbnRyeSBhbHJlYWR5IGV4aXN0cy5cbiAgICAgICAgICAgIHJldHVybiBhdWRpdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIGF1ZGl0LmZpbGVzLnB1c2goe1xuICAgICAgICAgICAgZGF0ZTogdGltZSxcbiAgICAgICAgICAgIG5hbWU6IGxvZ2ZpbGUsXG4gICAgICAgICAgICBoYXNoOiBjcnlwdG8uY3JlYXRlSGFzaChhdWRpdC5oYXNoVHlwZSkudXBkYXRlKGxvZ2ZpbGUgKyBcIkxPR19GSUxFXCIgKyB0aW1lKS5kaWdlc3QoXCJoZXhcIilcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYoYXVkaXQua2VlcC5kYXlzKXtcbiAgICAgICAgICAgIHZhciBvbGRlc3REYXRlID0gbW9tZW50KCkuc3VidHJhY3QoYXVkaXQua2VlcC5hbW91bnQsXCJkYXlzXCIpLnZhbHVlT2YoKTtcbiAgICAgICAgICAgIHZhciByZWNlbnRGaWxlcyA9IGF1ZGl0LmZpbGVzLmZpbHRlcihmdW5jdGlvbihmaWxlKXtcbiAgICAgICAgICAgICAgICBpZihmaWxlLmRhdGUgPiBvbGRlc3REYXRlKXtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbGUuaGFzaFR5cGUgPSBhdWRpdC5oYXNoVHlwZVxuICAgICAgICAgICAgICAgIHJlbW92ZUZpbGUoZmlsZSwgdmVyYm9zZSk7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmVtaXQoXCJsb2dSZW1vdmVkXCIsIGZpbGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhdWRpdC5maWxlcyA9IHJlY2VudEZpbGVzO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHZhciBmaWxlc1RvS2VlcCA9IGF1ZGl0LmZpbGVzLnNwbGljZSgtYXVkaXQua2VlcC5hbW91bnQpO1xuICAgICAgICAgICAgaWYoYXVkaXQuZmlsZXMubGVuZ3RoID4gMCl7XG4gICAgICAgICAgICAgICAgYXVkaXQuZmlsZXMuZmlsdGVyKGZ1bmN0aW9uKGZpbGUpe1xuICAgICAgICAgICAgICAgICAgICBmaWxlLmhhc2hUeXBlID0gYXVkaXQuaGFzaFR5cGVcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlRmlsZShmaWxlLCB2ZXJib3NlKTtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLmVtaXQoXCJsb2dSZW1vdmVkXCIsIGZpbGUpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXVkaXQuZmlsZXMgPSBmaWxlc1RvS2VlcDtcbiAgICAgICAgfVxuXG4gICAgICAgIEZpbGVTdHJlYW1Sb3RhdG9yLndyaXRlQXVkaXRMb2coYXVkaXQsIHZlcmJvc2UpO1xuICAgIH1cblxuICAgIHJldHVybiBhdWRpdDtcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEBwYXJhbSBvcHRpb25zLmZpbGVuYW1lXG4gKiBAcGFyYW0gb3B0aW9ucy5mcmVxdWVuY3lcbiAqIEBwYXJhbSBvcHRpb25zLnZlcmJvc2VcbiAqIEBwYXJhbSBvcHRpb25zLmRhdGVfZm9ybWF0XG4gKiBAcGFyYW0gb3B0aW9ucy5zaXplXG4gKiBAcGFyYW0gb3B0aW9ucy5tYXhfbG9nc1xuICogQHBhcmFtIG9wdGlvbnMuYXVkaXRfZmlsZVxuICogQHBhcmFtIG9wdGlvbnMuZmlsZV9vcHRpb25zXG4gKiBAcGFyYW0gb3B0aW9ucy51dGNcbiAqIEBwYXJhbSBvcHRpb25zLmV4dGVuc2lvbiBGaWxlIGV4dGVuc2lvbiB0byBiZSBhZGRlZCBhdCB0aGUgZW5kIG9mIHRoZSBmaWxlbmFtZVxuICogQHBhcmFtIG9wdGlvbnMud2F0Y2hfbG9nXG4gKiBAcGFyYW0gb3B0aW9ucy5jcmVhdGVfc3ltbGlua1xuICogQHBhcmFtIG9wdGlvbnMuc3ltbGlua19uYW1lXG4gKiBAcGFyYW0gb3B0aW9ucy5hdWRpdF9oYXNoX3R5cGUgSGFzaCB0byBiZSB1c2VkIHRvIGFkZCB0byB0aGUgYXVkaXQgbG9nIChtZDUsIHNoYTI1NilcbiAqIEByZXR1cm5zIHtPYmplY3R9IHN0cmVhbVxuICovXG5GaWxlU3RyZWFtUm90YXRvci5nZXRTdHJlYW0gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHZhciBmcmVxdWVuY3lNZXRhRGF0YSA9IG51bGw7XG4gICAgdmFyIGN1ckRhdGUgPSBudWxsO1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmICghb3B0aW9ucy5maWxlbmFtZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKG5ldyBEYXRlKCksXCJbRmlsZVN0cmVhbVJvdGF0b3JdIE5vIGZpbGVuYW1lIHN1cHBsaWVkLiBEZWZhdWx0aW5nIHRvIFNURE9VVFwiKTtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3Muc3Rkb3V0O1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmZyZXF1ZW5jeSkge1xuICAgICAgICBmcmVxdWVuY3lNZXRhRGF0YSA9IHNlbGYuZ2V0RnJlcXVlbmN5KG9wdGlvbnMuZnJlcXVlbmN5KTtcbiAgICB9XG5cbiAgICBsZXQgYXVkaXRMb2cgPSBzZWxmLnNldEF1ZGl0TG9nKG9wdGlvbnMubWF4X2xvZ3MsIG9wdGlvbnMuYXVkaXRfZmlsZSwgb3B0aW9ucy5maWxlbmFtZSk7XG4gICAgLy8gVGhhbmtzIHRvIE1lYW5zODggZm9yIFBSLlxuICAgIGlmIChhdWRpdExvZyAhPSBudWxsKSB7XG4gICAgICAgIGF1ZGl0TG9nLmhhc2hUeXBlID0gKG9wdGlvbnMuYXVkaXRfaGFzaF90eXBlICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmF1ZGl0X2hhc2hfdHlwZSA6ICdtZDUnKTtcbiAgICB9XG4gICAgc2VsZi52ZXJib3NlID0gKG9wdGlvbnMudmVyYm9zZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy52ZXJib3NlIDogdHJ1ZSk7XG5cbiAgICB2YXIgZmlsZVNpemUgPSBudWxsO1xuICAgIHZhciBmaWxlQ291bnQgPSAwO1xuICAgIHZhciBjdXJTaXplID0gMDtcbiAgICBpZihvcHRpb25zLnNpemUpe1xuICAgICAgICBmaWxlU2l6ZSA9IEZpbGVTdHJlYW1Sb3RhdG9yLnBhcnNlRmlsZVNpemUob3B0aW9ucy5zaXplKTtcbiAgICB9XG5cbiAgICB2YXIgZGF0ZUZvcm1hdCA9IChvcHRpb25zLmRhdGVfZm9ybWF0IHx8IERBVEVfRk9STUFUKTtcbiAgICBpZihmcmVxdWVuY3lNZXRhRGF0YSAmJiBmcmVxdWVuY3lNZXRhRGF0YS50eXBlID09IFwiZGFpbHlcIil7XG4gICAgICAgIGlmKCFvcHRpb25zLmRhdGVfZm9ybWF0KXtcbiAgICAgICAgICAgIGRhdGVGb3JtYXQgPSBcIllZWVktTU0tRERcIjtcbiAgICAgICAgfVxuICAgICAgICBpZihtb21lbnQoKS5mb3JtYXQoZGF0ZUZvcm1hdCkgIT0gbW9tZW50KCkuZW5kT2YoXCJkYXlcIikuZm9ybWF0KGRhdGVGb3JtYXQpIHx8IG1vbWVudCgpLmZvcm1hdChkYXRlRm9ybWF0KSA9PSBtb21lbnQoKS5hZGQoMSxcImRheVwiKS5mb3JtYXQoZGF0ZUZvcm1hdCkpe1xuICAgICAgICAgICAgaWYoc2VsZi52ZXJib3NlKXtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhuZXcgRGF0ZSgpLFwiW0ZpbGVTdHJlYW1Sb3RhdG9yXSBDaGFuZ2luZyB0eXBlIHRvIGN1c3RvbSBhcyBkYXRlIGZvcm1hdCBjaGFuZ2VzIG1vcmUgb2Z0ZW4gdGhhbiBvbmNlIGEgZGF5IG9yIG5vdCBldmVyeSBkYXlcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmcmVxdWVuY3lNZXRhRGF0YS50eXBlID0gXCJjdXN0b21cIjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmVxdWVuY3lNZXRhRGF0YSkge1xuICAgICAgICBjdXJEYXRlID0gKG9wdGlvbnMuZnJlcXVlbmN5ID8gc2VsZi5nZXREYXRlKGZyZXF1ZW5jeU1ldGFEYXRhLGRhdGVGb3JtYXQsIG9wdGlvbnMudXRjKSA6IFwiXCIpO1xuICAgIH1cblxuICAgIG9wdGlvbnMuY3JlYXRlX3N5bWxpbmsgPSBvcHRpb25zLmNyZWF0ZV9zeW1saW5rIHx8IGZhbHNlO1xuICAgIG9wdGlvbnMuZXh0ZW5zaW9uID0gb3B0aW9ucy5leHRlbnNpb24gfHwgXCJcIlxuICAgIHZhciBmaWxlbmFtZSA9IG9wdGlvbnMuZmlsZW5hbWU7XG4gICAgdmFyIG9sZEZpbGUgPSBudWxsO1xuICAgIHZhciBsb2dmaWxlID0gZmlsZW5hbWUgKyAoY3VyRGF0ZSA/IFwiLlwiICsgY3VyRGF0ZSA6IFwiXCIpO1xuICAgIGlmKGZpbGVuYW1lLm1hdGNoKC8lREFURSUvKSl7XG4gICAgICAgIGxvZ2ZpbGUgPSBmaWxlbmFtZS5yZXBsYWNlKC8lREFURSUvZywoY3VyRGF0ZT9jdXJEYXRlOnNlbGYuZ2V0RGF0ZShudWxsLGRhdGVGb3JtYXQsIG9wdGlvbnMudXRjKSkpO1xuICAgIH1cblxuICAgIGlmKGZpbGVTaXplKXtcbiAgICAgICAgdmFyIGxhc3RMb2dGaWxlID0gbnVsbDtcbiAgICAgICAgdmFyIHRfbG9nID0gbG9nZmlsZTtcbiAgICAgICAgdmFyIGYgPSBudWxsO1xuICAgICAgICBpZihhdWRpdExvZyAmJiBhdWRpdExvZy5maWxlcyAmJiBhdWRpdExvZy5maWxlcyBpbnN0YW5jZW9mIEFycmF5ICYmIGF1ZGl0TG9nLmZpbGVzLmxlbmd0aCA+IDApe1xuICAgICAgICAgICAgdmFyIGxhc3RFbnRyeSA9IGF1ZGl0TG9nLmZpbGVzW2F1ZGl0TG9nLmZpbGVzLmxlbmd0aCAtIDFdLm5hbWU7XG4gICAgICAgICAgICBpZihsYXN0RW50cnkubWF0Y2godF9sb2cpKXtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdENvdW50ID0gbGFzdEVudHJ5Lm1hdGNoKHRfbG9nICsgXCJcXFxcLihcXFxcZCspXCIpO1xuICAgICAgICAgICAgICAgIC8vIFRoYW5rcyBmb3IgdGhlIFBSIGNvbnRyaWJ1dGlvbiBmcm9tIEBhbmRyZWZhcnphdCAtIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmRyZWZhcnphdFxuICAgICAgICAgICAgICAgIGlmKGxhc3RDb3VudCl7ICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdF9sb2cgPSBsYXN0RW50cnk7XG4gICAgICAgICAgICAgICAgICAgIGZpbGVDb3VudCA9IGxhc3RDb3VudFsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmlsZUNvdW50ID09IDAgJiYgdF9sb2cgPT0gbG9nZmlsZSkge1xuICAgICAgICAgICAgdF9sb2cgKz0gb3B0aW9ucy5leHRlbnNpb25cbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlKGYgPSBmcy5leGlzdHNTeW5jKHRfbG9nKSl7XG4gICAgICAgICAgICBsYXN0TG9nRmlsZSA9IHRfbG9nO1xuICAgICAgICAgICAgZmlsZUNvdW50Kys7XG4gICAgICAgICAgICB0X2xvZyA9IGxvZ2ZpbGUgKyBcIi5cIiArIGZpbGVDb3VudCArIG9wdGlvbnMuZXh0ZW5zaW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmKGxhc3RMb2dGaWxlKXtcbiAgICAgICAgICAgIHZhciBsYXN0TG9nRmlsZVN0YXRzID0gZnMuc3RhdFN5bmMobGFzdExvZ0ZpbGUpO1xuICAgICAgICAgICAgaWYobGFzdExvZ0ZpbGVTdGF0cy5zaXplIDwgZmlsZVNpemUpe1xuICAgICAgICAgICAgICAgIHRfbG9nID0gbGFzdExvZ0ZpbGU7XG4gICAgICAgICAgICAgICAgZmlsZUNvdW50LS07XG4gICAgICAgICAgICAgICAgY3VyU2l6ZSA9IGxhc3RMb2dGaWxlU3RhdHMuc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsb2dmaWxlID0gdF9sb2c7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbG9nZmlsZSArPSBvcHRpb25zLmV4dGVuc2lvblxuICAgIH1cblxuICAgIGlmIChzZWxmLnZlcmJvc2UpIHtcbiAgICAgICAgY29uc29sZS5sb2cobmV3IERhdGUoKSxcIltGaWxlU3RyZWFtUm90YXRvcl0gTG9nZ2luZyB0bzogXCIsIGxvZ2ZpbGUpO1xuICAgIH1cblxuICAgIG1rRGlyRm9yRmlsZShsb2dmaWxlKTtcblxuICAgIHZhciBmaWxlX29wdGlvbnMgPSBvcHRpb25zLmZpbGVfb3B0aW9ucyB8fCB7ZmxhZ3M6ICdhJ307XG4gICAgdmFyIHJvdGF0ZVN0cmVhbSA9IGZzLmNyZWF0ZVdyaXRlU3RyZWFtKGxvZ2ZpbGUsIGZpbGVfb3B0aW9ucyk7XG4gICAgaWYgKChjdXJEYXRlICYmIGZyZXF1ZW5jeU1ldGFEYXRhICYmIChzdGF0aWNGcmVxdWVuY3kuaW5kZXhPZihmcmVxdWVuY3lNZXRhRGF0YS50eXBlKSA+IC0xKSkgfHwgZmlsZVNpemUgPiAwKSB7XG4gICAgICAgIGlmIChzZWxmLnZlcmJvc2UpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG5ldyBEYXRlKCksXCJbRmlsZVN0cmVhbVJvdGF0b3JdIFJvdGF0aW5nIGZpbGU6IFwiLCBmcmVxdWVuY3lNZXRhRGF0YT9mcmVxdWVuY3lNZXRhRGF0YS50eXBlOlwiXCIsIGZpbGVTaXplP1wic2l6ZTogXCIgKyBmaWxlU2l6ZTpcIlwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RyZWFtID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBzdHJlYW0uYXVkaXRMb2cgPSBhdWRpdExvZztcbiAgICAgICAgc3RyZWFtLmVuZCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByb3RhdGVTdHJlYW0uZW5kLmFwcGx5KHJvdGF0ZVN0cmVhbSxhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgICBCdWJibGVFdmVudHMocm90YXRlU3RyZWFtLHN0cmVhbSk7XG5cbiAgICAgICAgc3RyZWFtLm9uKCdjbG9zZScsIGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBpZiAobG9nV2F0Y2hlcikge1xuICAgICAgICAgICAgICAgIGxvZ1dhdGNoZXIuY2xvc2UoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIHN0cmVhbS5vbihcIm5ld1wiLGZ1bmN0aW9uKG5ld0xvZyl7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIm5ldyBsb2dcIiwgbmV3TG9nKVxuICAgICAgICAgICAgc3RyZWFtLmF1ZGl0TG9nID0gc2VsZi5hZGRMb2dUb0F1ZGl0KG5ld0xvZyxzdHJlYW0uYXVkaXRMb2csIHN0cmVhbSwgc2VsZi52ZXJib3NlKVxuICAgICAgICAgICAgaWYob3B0aW9ucy5jcmVhdGVfc3ltbGluayl7XG4gICAgICAgICAgICAgICAgY3JlYXRlQ3VycmVudFN5bUxpbmsobmV3TG9nLCBvcHRpb25zLnN5bWxpbmtfbmFtZSwgc2VsZi52ZXJib3NlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYob3B0aW9ucy53YXRjaF9sb2cpe1xuICAgICAgICAgICAgICAgIHN0cmVhbS5lbWl0KFwiYWRkV2F0Y2hlclwiLCBuZXdMb2cpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgdmFyIGxvZ1dhdGNoZXI7XG4gICAgICAgIHN0cmVhbS5vbihcImFkZFdhdGNoZXJcIiwgZnVuY3Rpb24obmV3TG9nKXtcbiAgICAgICAgICAgIGlmIChsb2dXYXRjaGVyKSB7XG4gICAgICAgICAgICAgICAgbG9nV2F0Y2hlci5jbG9zZSgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZighb3B0aW9ucy53YXRjaF9sb2cpe1xuICAgICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coXCJBRERJTkcgV0FUQ0hFUlwiLCBuZXdMb2cpXG4gICAgICAgICAgICBsb2dXYXRjaGVyID0gY3JlYXRlTG9nV2F0Y2hlcihuZXdMb2csIHNlbGYudmVyYm9zZSwgZnVuY3Rpb24oZXJyLG5ld0xvZyl7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ2NyZWF0ZUxvZycsIG5ld0xvZylcbiAgICAgICAgICAgIH0pICAgICAgICBcbiAgICAgICAgfSlcblxuICAgICAgICBzdHJlYW0ub24oXCJjcmVhdGVMb2dcIixmdW5jdGlvbihmaWxlKXtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXRzID0gZnMubHN0YXRTeW5jKGZpbGUpXG4gICAgICAgICAgICB9Y2F0Y2goZXJyKXtcbiAgICAgICAgICAgICAgICBpZihyb3RhdGVTdHJlYW0gJiYgcm90YXRlU3RyZWFtLmVuZCA9PSBcImZ1bmN0aW9uXCIpe1xuICAgICAgICAgICAgICAgICAgICByb3RhdGVTdHJlYW0uZW5kKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJvdGF0ZVN0cmVhbSA9IGZzLmNyZWF0ZVdyaXRlU3RyZWFtKGZpbGUsIGZpbGVfb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ25ldycsZmlsZSk7XG4gICAgICAgICAgICAgICAgQnViYmxlRXZlbnRzKHJvdGF0ZVN0cmVhbSxzdHJlYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuXG4gICAgICAgIHN0cmVhbS53cml0ZSA9IChmdW5jdGlvbiAoc3RyLCBlbmNvZGluZykge1xuICAgICAgICAgICAgdmFyIG5ld0RhdGUgPSBmcmVxdWVuY3lNZXRhRGF0YSA/IHRoaXMuZ2V0RGF0ZShmcmVxdWVuY3lNZXRhRGF0YSwgZGF0ZUZvcm1hdCwgb3B0aW9ucy51dGMpIDogY3VyRGF0ZTtcbiAgICAgICAgICAgIGlmIChuZXdEYXRlICE9IGN1ckRhdGUgfHwgKGZpbGVTaXplICYmIGN1clNpemUgPiBmaWxlU2l6ZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3TG9nZmlsZSA9IGZpbGVuYW1lICsgKGN1ckRhdGUgJiYgZnJlcXVlbmN5TWV0YURhdGEgPyBcIi5cIiArIG5ld0RhdGUgOiBcIlwiKTtcbiAgICAgICAgICAgICAgICBpZihmaWxlbmFtZS5tYXRjaCgvJURBVEUlLykgJiYgY3VyRGF0ZSl7XG4gICAgICAgICAgICAgICAgICAgIG5ld0xvZ2ZpbGUgPSBmaWxlbmFtZS5yZXBsYWNlKC8lREFURSUvZyxuZXdEYXRlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZihmaWxlU2l6ZSAmJiBjdXJTaXplID4gZmlsZVNpemUpe1xuICAgICAgICAgICAgICAgICAgICBmaWxlQ291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgbmV3TG9nZmlsZSArPSBcIi5cIiArIGZpbGVDb3VudCArIG9wdGlvbnMuZXh0ZW5zaW9uO1xuICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICAvLyByZXNldCBmaWxlIGNvdW50XG4gICAgICAgICAgICAgICAgICAgIGZpbGVDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIG5ld0xvZ2ZpbGUgKz0gb3B0aW9ucy5leHRlbnNpb25cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VyU2l6ZSA9IDA7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi52ZXJib3NlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKG5ldyBEYXRlKCkscmVxdWlyZSgndXRpbCcpLmZvcm1hdChcIltGaWxlU3RyZWFtUm90YXRvcl0gQ2hhbmdpbmcgbG9ncyBmcm9tICVzIHRvICVzXCIsIGxvZ2ZpbGUsIG5ld0xvZ2ZpbGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VyRGF0ZSA9IG5ld0RhdGU7XG4gICAgICAgICAgICAgICAgb2xkRmlsZSA9IGxvZ2ZpbGU7XG4gICAgICAgICAgICAgICAgbG9nZmlsZSA9IG5ld0xvZ2ZpbGU7XG4gICAgICAgICAgICAgICAgLy8gVGhhbmtzIHRvIEBtYXR0YmVydGhlciBodHRwczovL2dpdGh1Yi5jb20vbWF0dGJlcnRoZXIgZm9yIHJhaXNpbmcgaXQgYWdhaW4uXG4gICAgICAgICAgICAgICAgaWYob3B0aW9ucy5lbmRfc3RyZWFtID09PSB0cnVlKXtcbiAgICAgICAgICAgICAgICAgICAgcm90YXRlU3RyZWFtLmVuZCgpO1xuICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICByb3RhdGVTdHJlYW0uZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG1rRGlyRm9yRmlsZShsb2dmaWxlKTtcblxuICAgICAgICAgICAgICAgIHJvdGF0ZVN0cmVhbSA9IGZzLmNyZWF0ZVdyaXRlU3RyZWFtKG5ld0xvZ2ZpbGUsIGZpbGVfb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ25ldycsbmV3TG9nZmlsZSk7XG4gICAgICAgICAgICAgICAgc3RyZWFtLmVtaXQoJ3JvdGF0ZScsb2xkRmlsZSwgbmV3TG9nZmlsZSk7XG4gICAgICAgICAgICAgICAgQnViYmxlRXZlbnRzKHJvdGF0ZVN0cmVhbSxzdHJlYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm90YXRlU3RyZWFtLndyaXRlKHN0ciwgZW5jb2RpbmcpO1xuICAgICAgICAgICAgLy8gSGFuZGxlIGxlbmd0aCBvZiBkb3VibGUtYnl0ZSBjaGFyYWN0ZXJzXG4gICAgICAgICAgICBjdXJTaXplICs9IEJ1ZmZlci5ieXRlTGVuZ3RoKHN0ciwgZW5jb2RpbmcpO1xuICAgICAgICB9KS5iaW5kKHRoaXMpO1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBzdHJlYW0uZW1pdCgnbmV3Jyxsb2dmaWxlKTtcbiAgICAgICAgfSlcbiAgICAgICAgc3RyZWFtLmVtaXQoJ25ldycsbG9nZmlsZSlcbiAgICAgICAgcmV0dXJuIHN0cmVhbTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc2VsZi52ZXJib3NlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhuZXcgRGF0ZSgpLFwiW0ZpbGVTdHJlYW1Sb3RhdG9yXSBGaWxlIHdvbid0IGJlIHJvdGF0ZWQ6IFwiLCBvcHRpb25zLmZyZXF1ZW5jeSwgb3B0aW9ucy5zaXplKTtcbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICByb3RhdGVTdHJlYW0uZW1pdCgnbmV3Jyxsb2dmaWxlKTtcbiAgICAgICAgfSlcbiAgICAgICAgcmV0dXJuIHJvdGF0ZVN0cmVhbTtcbiAgICB9XG59XG5cbi8qKlxuICogQ2hlY2sgYW5kIG1ha2UgcGFyZW50IGRpcmVjdG9yeVxuICogQHBhcmFtIHBhdGhXaXRoRmlsZVxuICovXG52YXIgbWtEaXJGb3JGaWxlID0gZnVuY3Rpb24ocGF0aFdpdGhGaWxlKXtcbiAgICB2YXIgX3BhdGggPSBwYXRoLmRpcm5hbWUocGF0aFdpdGhGaWxlKTtcbiAgICBfcGF0aC5zcGxpdChwYXRoLnNlcCkucmVkdWNlKFxuICAgICAgICBmdW5jdGlvbihmdWxsUGF0aCwgZm9sZGVyKSB7XG4gICAgICAgICAgICBmdWxsUGF0aCArPSBmb2xkZXIgKyBwYXRoLnNlcDtcbiAgICAgICAgICAgIC8vIE9wdGlvbiB0byByZXBsYWNlIGV4aXN0c1N5bmMgYXMgZGVwcmVjYXRlZC4gTWF5YmUgaW4gYSBmdXR1cmUgcmVsZWFzZS5cbiAgICAgICAgICAgIC8vIHRyeXtcbiAgICAgICAgICAgIC8vICAgICB2YXIgc3RhdHMgPSBmcy5zdGF0U3luYyhmdWxsUGF0aCk7XG4gICAgICAgICAgICAvLyAgICAgY29uc29sZS5sb2coJ1NUQVRTJyxmdWxsUGF0aCwgc3RhdHMpO1xuICAgICAgICAgICAgLy8gfWNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gICAgIGZzLm1rZGlyU3luYyhmdWxsUGF0aCk7XG4gICAgICAgICAgICAvLyAgICAgY29uc29sZS5sb2coXCJTVEFUUyBFUlJPUlwiLGUpXG4gICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICBpZiAoIWZzLmV4aXN0c1N5bmMoZnVsbFBhdGgpKSB7XG4gICAgICAgICAgICAgICAgdHJ5e1xuICAgICAgICAgICAgICAgICAgICBmcy5ta2RpclN5bmMoZnVsbFBhdGgpO1xuICAgICAgICAgICAgICAgIH1jYXRjaChlKXtcbiAgICAgICAgICAgICAgICAgICAgaWYoZS5jb2RlICE9PSAnRUVYSVNUJyl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZ1bGxQYXRoO1xuICAgICAgICB9LFxuICAgICAgICAnJ1xuICAgICk7XG59O1xuXG5cbi8qKlxuICogQnViYmxlcyBldmVudHMgdG8gdGhlIHByb3h5XG4gKiBAcGFyYW0gZW1pdHRlclxuICogQHBhcmFtIHByb3h5XG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEJ1YmJsZUV2ZW50cyA9IGZ1bmN0aW9uIEJ1YmJsZUV2ZW50cyhlbWl0dGVyLHByb3h5KXtcbiAgICBlbWl0dGVyLm9uKCdjbG9zZScsZnVuY3Rpb24oKXtcbiAgICAgICAgcHJveHkuZW1pdCgnY2xvc2UnKTtcbiAgICB9KVxuICAgIGVtaXR0ZXIub24oJ2ZpbmlzaCcsZnVuY3Rpb24oKXtcbiAgICAgICAgcHJveHkuZW1pdCgnZmluaXNoJyk7XG4gICAgfSlcbiAgICBlbWl0dGVyLm9uKCdlcnJvcicsZnVuY3Rpb24oZXJyKXtcbiAgICAgICAgcHJveHkuZW1pdCgnZXJyb3InLGVycik7XG4gICAgfSlcbiAgICBlbWl0dGVyLm9uKCdvcGVuJyxmdW5jdGlvbihmZCl7XG4gICAgICAgIHByb3h5LmVtaXQoJ29wZW4nLGZkKTtcbiAgICB9KVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/file-stream-rotator/FileStreamRotator.js\n");

/***/ })

};
;