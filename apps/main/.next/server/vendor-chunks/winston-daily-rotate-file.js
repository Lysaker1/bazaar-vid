/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/winston-daily-rotate-file";
exports.ids = ["vendor-chunks/winston-daily-rotate-file"];
exports.modules = {

/***/ "(rsc)/../../node_modules/winston-daily-rotate-file/daily-rotate-file.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/winston-daily-rotate-file/daily-rotate-file.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const fs = __webpack_require__(/*! fs */ \"fs\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst util = __webpack_require__(/*! util */ \"util\");\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\nconst hash = __webpack_require__(/*! object-hash */ \"(rsc)/../../node_modules/object-hash/index.js\");\nconst MESSAGE = (__webpack_require__(/*! triple-beam */ \"(rsc)/../../node_modules/triple-beam/index.js\").MESSAGE);\nconst PassThrough = (__webpack_require__(/*! stream */ \"stream\").PassThrough);\nconst Transport = __webpack_require__(/*! winston-transport */ \"(rsc)/../../node_modules/winston-transport/index.js\");\n\nconst loggerDefaults = {\n    json: false,\n    colorize: false,\n    eol: os.EOL,\n    logstash: null,\n    prettyPrint: false,\n    label: null,\n    stringify: false,\n    depth: null,\n    showLevel: true,\n    timestamp: () => {\n        return new Date().toISOString();\n    }\n};\n\nconst DailyRotateFile = function(options) {\n    options = options || {};\n    Transport.call(this, options);\n\n    function throwIf(target /* , illegal... */) {\n        Array.prototype.slice.call(arguments, 1).forEach((name) => {\n            if (options[name]) {\n                throw new Error(\"Cannot set \" + name + \" and \" + target + \" together\");\n            }\n        });\n    }\n\n    function getMaxSize(size) {\n        if (size && typeof size === \"string\") {\n            if (size.toLowerCase().match(/^((?:0\\.)?\\d+)([kmg])$/)) {\n                return size;\n            }\n        } else if (size && Number.isInteger(size)) {\n            const sizeK = Math.round(size / 1024);\n            return sizeK === 0 ? \"1k\" : sizeK + \"k\";\n        }\n\n        return null;\n    }\n\n    function isValidFileName(filename) {\n        // eslint-disable-next-line no-control-regex\n        return !/[\"<>|:*?\\\\/\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f]/g.test(\n            filename\n        );\n    }\n\n    function isValidDirName(dirname) {\n        // eslint-disable-next-line no-control-regex\n        return !/[\"<>|\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f]/g.test(\n            dirname\n        );\n    }\n\n    this.options = Object.assign({}, loggerDefaults, options);\n\n    if (options.stream) {\n        throwIf(\"stream\", \"filename\", \"maxsize\");\n        this.logStream = new PassThrough();\n        this.logStream.pipe(options.stream);\n    } else {\n        this.filename = options.filename\n            ? path.basename(options.filename)\n            : \"winston.log\";\n        this.dirname = options.dirname || path.dirname(options.filename);\n\n        if (!isValidFileName(this.filename) || !isValidDirName(this.dirname)) {\n            throw new Error(\"Your path or filename contain an invalid character.\");\n        }\n\n        this.logStream = (__webpack_require__(/*! file-stream-rotator */ \"(rsc)/../../node_modules/file-stream-rotator/FileStreamRotator.js\").getStream)({\n            filename: path.join(this.dirname, this.filename),\n            frequency: options.frequency ? options.frequency : \"custom\",\n            date_format: options.datePattern ? options.datePattern : \"YYYY-MM-DD\",\n            verbose: false,\n            size: getMaxSize(options.maxSize),\n            max_logs: options.maxFiles,\n            end_stream: true,\n            audit_file: options.auditFile\n                ? options.auditFile\n                : path.join(this.dirname, \".\" + hash(options) + \"-audit.json\"),\n            file_options: options.options ? options.options : { flags: \"a\" },\n            utc: options.utc ? options.utc : false,\n            extension: options.extension ? options.extension : \"\",\n            create_symlink: options.createSymlink ? options.createSymlink : false,\n            symlink_name: options.symlinkName ? options.symlinkName : \"current.log\",\n            watch_log: options.watchLog ? options.watchLog : false,\n            audit_hash_type: options.auditHashType ? options.auditHashType : \"sha256\"\n        });\n\n        this.logStream.on(\"new\", (newFile) => {\n            this.emit(\"new\", newFile);\n        });\n\n        this.logStream.on(\"rotate\", (oldFile, newFile) => {\n            this.emit(\"rotate\", oldFile, newFile);\n        });\n\n        this.logStream.on(\"logRemoved\", (params) => {\n            if (options.zippedArchive) {\n                const gzName = params.name + \".gz\";\n                try {\n                    fs.unlinkSync(gzName);\n                } catch (err) {\n                    // ENOENT is okay, means file doesn't exist, other errors prevent deletion, so report it\n                    if (err.code !== \"ENOENT\") {\n                        err.message = `Error occurred while removing ${gzName}: ${err.message}`;\n                        this.emit(\"error\", err);\n                        return;\n                    }\n                }\n                this.emit(\"logRemoved\", gzName);\n                return;\n            }\n            this.emit(\"logRemoved\", params.name);\n        });\n\n        if (options.zippedArchive) {\n            this.logStream.on(\"rotate\", (oldFile) => {\n                try {\n                    if (!fs.existsSync(oldFile)) {\n                        return;\n                    }\n                } catch (err) {\n                    err.message = `Error occurred while checking existence of ${oldFile}: ${err.message}`;\n                    this.emit(\"error\", err);\n                    return;\n                }\n                try {\n                    if (fs.existsSync(`${oldFile}.gz`)) {\n                        return;\n                    }\n                } catch (err) {\n                    err.message = `Error occurred while checking existence of ${oldFile}.gz: ${err.message}`;\n                    this.emit(\"error\", err);\n                    return;\n                }\n\n                const gzip = zlib.createGzip();\n                const inp = fs.createReadStream(oldFile);\n                inp.on(\"error\", (err) => {\n                    err.message = `Error occurred while reading ${oldFile}: ${err.message}`;\n                    this.emit(\"error\", err);\n                });\n                const out = fs.createWriteStream(oldFile + \".gz\");\n                out.on(\"error\", (err) => {\n                    err.message = `Error occurred while writing ${oldFile}.gz: ${err.message}`;\n                    this.emit(\"error\", err);\n                });\n                inp\n                    .pipe(gzip)\n                    .pipe(out)\n                    .on(\"finish\", () => {\n                        try {\n                            fs.unlinkSync(oldFile);\n                        } catch (err) {\n                            if (err.code !== \"ENOENT\") {\n                                err.message = `Error occurred while removing ${oldFile}: ${err.message}`;\n                                this.emit(\"error\", err);\n                                return;\n                            }\n                        }\n                        this.emit(\"archive\", oldFile + \".gz\");\n                    });\n            });\n        }\n\n        if (options.watchLog) {\n            this.logStream.on(\"addWatcher\", (newFile) => {\n                this.emit(\"addWatcher\", newFile);\n            });\n        }\n    }\n};\n\nmodule.exports = DailyRotateFile;\n\nutil.inherits(DailyRotateFile, Transport);\n\nDailyRotateFile.prototype.name = \"dailyRotateFile\";\n\nconst noop = function() {};\nDailyRotateFile.prototype.log = function (info, callback) {\n    callback = callback || noop;\n\n    this.logStream.write(info[MESSAGE] + this.options.eol);\n    this.emit(\"logged\", info);\n    callback(null, true);\n};\n\nDailyRotateFile.prototype.close = function () {\n    if (this.logStream) {\n        this.logStream.end(() => {\n            this.emit(\"finish\");\n        });\n    }\n};\n\nDailyRotateFile.prototype.query = function (options, callback) {\n    if (typeof options === \"function\") {\n        callback = options;\n        options = {};\n    }\n\n    if (!this.options.json) {\n        throw new Error(\n            \"query() may not be used without the json option being set to true\"\n        );\n    }\n\n    if (!this.filename) {\n        throw new Error(\"query() may not be used when initializing with a stream\");\n    }\n\n    let results = [];\n    options = options || {};\n\n    // limit\n    options.rows = options.rows || options.limit || 10;\n\n    // starting row offset\n    options.start = options.start || 0;\n\n    // now\n    options.until = options.until || new Date();\n    if (typeof options.until !== \"object\") {\n        options.until = new Date(options.until);\n    }\n\n    // now - 24\n    options.from = options.from || options.until - 24 * 60 * 60 * 1000;\n    if (typeof options.from !== \"object\") {\n        options.from = new Date(options.from);\n    }\n\n    // 'asc' or 'desc'\n    options.order = options.order || \"desc\";\n\n    const logFiles = (() => {\n        const fileRegex = new RegExp(this.filename.replace(\"%DATE%\", \".*\"), \"i\");\n        return fs.readdirSync(this.dirname).filter((file) => path.basename(file).match(fileRegex));\n    })();\n\n    if (logFiles.length === 0 && callback) {\n        callback(null, results);\n    }\n\n    const processLogFile = (file) => {\n        if (!file) {\n            return;\n        }\n\n        const logFile = path.join(this.dirname, file);\n        let buff = \"\";\n\n        let stream;\n\n        if (file.endsWith(\".gz\")) {\n            stream = new PassThrough();\n            const inp = fs.createReadStream(logFile);\n            inp.on(\"error\",  (err) => {\n                err.message = `Error occurred while reading ${logFile}: ${err.message}`;\n                stream.emit(\"error\", err);\n            });\n            inp.pipe(zlib.createGunzip()).pipe(stream);\n        } else {\n            stream = fs.createReadStream(logFile, {\n                encoding: \"utf8\",\n            });\n        }\n\n        stream.on(\"error\",  (err) => {\n            if (stream.readable) {\n                stream.destroy();\n            }\n\n            if (!callback) {\n                return;\n            }\n\n            return err.code === \"ENOENT\" ? callback(null, results) : callback(err);\n        });\n\n        stream.on(\"data\", (data) => {\n            data = (buff + data).split(/\\n+/);\n            const l = data.length - 1;\n\n            for (let i = 0; i < l; i++) {\n                add(data[i]);\n            }\n\n            buff = data[l];\n        });\n\n        stream.on(\"end\",  () => {\n            if (buff) {\n                add(buff, true);\n            }\n\n            if (logFiles.length) {\n                processLogFile(logFiles.shift());\n            } else if (callback) {\n                results.sort( (a, b) => {\n                    const d1 = new Date(a.timestamp).getTime();\n                    const d2 = new Date(b.timestamp).getTime();\n\n                    return d1 > d2 ? 1 : d1 < d2 ? -1 : 0;\n                });\n\n                if (options.order === \"desc\") {\n                    results = results.reverse();\n                }\n\n                const start = options.start || 0;\n                const limit = options.limit || results.length;\n\n                results = results.slice(start, start + limit);\n\n                if (options.fields) {\n                    results = results.map( (log) => {\n                        const obj = {};\n                        options.fields.forEach( (key) => {\n                            obj[key] = log[key];\n                        });\n                        return obj;\n                    });\n                }\n\n                callback(null, results);\n            }\n        });\n\n        function add(buff, attempt) {\n            try {\n                const log = JSON.parse(buff);\n                if (!log || typeof log !== \"object\") {\n                    return;\n                }\n\n                const time = new Date(log.timestamp);\n                if (\n                    (options.from && time < options.from) ||\n                    (options.until && time > options.until) ||\n                    (options.level && options.level !== log.level)\n                ) {\n                    return;\n                }\n\n                results.push(log);\n            } catch (e) {\n                if (!attempt) {\n                    stream.emit(\"error\", e);\n                }\n            }\n        }\n    };\n    processLogFile(logFiles.shift());\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3dpbnN0b24tZGFpbHktcm90YXRlLWZpbGUvZGFpbHktcm90YXRlLWZpbGUuanMiLCJtYXBwaW5ncyI6IkFBQUEsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsYUFBYSxtQkFBTyxDQUFDLGtFQUFhO0FBQ2xDLGdCQUFnQixpR0FBOEI7QUFDOUMsb0JBQW9CLHlEQUE2QjtBQUNqRCxrQkFBa0IsbUJBQU8sQ0FBQyw4RUFBbUI7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHlCQUF5QiwrSEFBd0M7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsWUFBWTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLHVFQUF1RSxPQUFPLElBQUksWUFBWTtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsZ0ZBQWdGLFFBQVEsSUFBSSxZQUFZO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixnRkFBZ0YsUUFBUSxPQUFPLFlBQVk7QUFDM0c7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxRQUFRLElBQUksWUFBWTtBQUMxRjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esa0VBQWtFLFFBQVEsT0FBTyxZQUFZO0FBQzdGO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLCtFQUErRSxRQUFRLElBQUksWUFBWTtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxRQUFRLElBQUksWUFBWTtBQUN0RjtBQUNBLGFBQWE7QUFDYjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EscUJBQXFCO0FBQ3JCOztBQUVBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXJrdXNob2duZS9Eb2N1bWVudHMvQVBQUy9iYXphYXItdmlkL2JhemFhci12aWQvbm9kZV9tb2R1bGVzL3dpbnN0b24tZGFpbHktcm90YXRlLWZpbGUvZGFpbHktcm90YXRlLWZpbGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgZnMgPSByZXF1aXJlKFwiZnNcIik7XG5jb25zdCBvcyA9IHJlcXVpcmUoXCJvc1wiKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcbmNvbnN0IHV0aWwgPSByZXF1aXJlKFwidXRpbFwiKTtcbmNvbnN0IHpsaWIgPSByZXF1aXJlKFwiemxpYlwiKTtcbmNvbnN0IGhhc2ggPSByZXF1aXJlKFwib2JqZWN0LWhhc2hcIik7XG5jb25zdCBNRVNTQUdFID0gcmVxdWlyZShcInRyaXBsZS1iZWFtXCIpLk1FU1NBR0U7XG5jb25zdCBQYXNzVGhyb3VnaCA9IHJlcXVpcmUoXCJzdHJlYW1cIikuUGFzc1Rocm91Z2g7XG5jb25zdCBUcmFuc3BvcnQgPSByZXF1aXJlKFwid2luc3Rvbi10cmFuc3BvcnRcIik7XG5cbmNvbnN0IGxvZ2dlckRlZmF1bHRzID0ge1xuICAgIGpzb246IGZhbHNlLFxuICAgIGNvbG9yaXplOiBmYWxzZSxcbiAgICBlb2w6IG9zLkVPTCxcbiAgICBsb2dzdGFzaDogbnVsbCxcbiAgICBwcmV0dHlQcmludDogZmFsc2UsXG4gICAgbGFiZWw6IG51bGwsXG4gICAgc3RyaW5naWZ5OiBmYWxzZSxcbiAgICBkZXB0aDogbnVsbCxcbiAgICBzaG93TGV2ZWw6IHRydWUsXG4gICAgdGltZXN0YW1wOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgfVxufTtcblxuY29uc3QgRGFpbHlSb3RhdGVGaWxlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIFRyYW5zcG9ydC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgZnVuY3Rpb24gdGhyb3dJZih0YXJnZXQgLyogLCBpbGxlZ2FsLi4uICovKSB7XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSkuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IFwiICsgbmFtZSArIFwiIGFuZCBcIiArIHRhcmdldCArIFwiIHRvZ2V0aGVyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRNYXhTaXplKHNpemUpIHtcbiAgICAgICAgaWYgKHNpemUgJiYgdHlwZW9mIHNpemUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmIChzaXplLnRvTG93ZXJDYXNlKCkubWF0Y2goL14oKD86MFxcLik/XFxkKykoW2ttZ10pJC8pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoc2l6ZSAmJiBOdW1iZXIuaXNJbnRlZ2VyKHNpemUpKSB7XG4gICAgICAgICAgICBjb25zdCBzaXplSyA9IE1hdGgucm91bmQoc2l6ZSAvIDEwMjQpO1xuICAgICAgICAgICAgcmV0dXJuIHNpemVLID09PSAwID8gXCIxa1wiIDogc2l6ZUsgKyBcImtcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVmFsaWRGaWxlTmFtZShmaWxlbmFtZSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxuICAgICAgICByZXR1cm4gIS9bXCI8Pnw6Kj9cXFxcL1xceDAwXFx4MDFcXHgwMlxceDAzXFx4MDRcXHgwNVxceDA2XFx4MDdcXHgwOFxceDA5XFx4MGFcXHgwYlxceDBjXFx4MGRcXHgwZVxceDBmXFx4MTBcXHgxMVxceDEyXFx4MTNcXHgxNFxceDE1XFx4MTZcXHgxN1xceDE4XFx4MTlcXHgxYVxceDFiXFx4MWNcXHgxZFxceDFlXFx4MWZdL2cudGVzdChcbiAgICAgICAgICAgIGZpbGVuYW1lXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNWYWxpZERpck5hbWUoZGlybmFtZSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxuICAgICAgICByZXR1cm4gIS9bXCI8PnxcXHgwMFxceDAxXFx4MDJcXHgwM1xceDA0XFx4MDVcXHgwNlxceDA3XFx4MDhcXHgwOVxceDBhXFx4MGJcXHgwY1xceDBkXFx4MGVcXHgwZlxceDEwXFx4MTFcXHgxMlxceDEzXFx4MTRcXHgxNVxceDE2XFx4MTdcXHgxOFxceDE5XFx4MWFcXHgxYlxceDFjXFx4MWRcXHgxZVxceDFmXS9nLnRlc3QoXG4gICAgICAgICAgICBkaXJuYW1lXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgbG9nZ2VyRGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgaWYgKG9wdGlvbnMuc3RyZWFtKSB7XG4gICAgICAgIHRocm93SWYoXCJzdHJlYW1cIiwgXCJmaWxlbmFtZVwiLCBcIm1heHNpemVcIik7XG4gICAgICAgIHRoaXMubG9nU3RyZWFtID0gbmV3IFBhc3NUaHJvdWdoKCk7XG4gICAgICAgIHRoaXMubG9nU3RyZWFtLnBpcGUob3B0aW9ucy5zdHJlYW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZmlsZW5hbWUgPSBvcHRpb25zLmZpbGVuYW1lXG4gICAgICAgICAgICA/IHBhdGguYmFzZW5hbWUob3B0aW9ucy5maWxlbmFtZSlcbiAgICAgICAgICAgIDogXCJ3aW5zdG9uLmxvZ1wiO1xuICAgICAgICB0aGlzLmRpcm5hbWUgPSBvcHRpb25zLmRpcm5hbWUgfHwgcGF0aC5kaXJuYW1lKG9wdGlvbnMuZmlsZW5hbWUpO1xuXG4gICAgICAgIGlmICghaXNWYWxpZEZpbGVOYW1lKHRoaXMuZmlsZW5hbWUpIHx8ICFpc1ZhbGlkRGlyTmFtZSh0aGlzLmRpcm5hbWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3VyIHBhdGggb3IgZmlsZW5hbWUgY29udGFpbiBhbiBpbnZhbGlkIGNoYXJhY3Rlci5cIik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxvZ1N0cmVhbSA9IHJlcXVpcmUoXCJmaWxlLXN0cmVhbS1yb3RhdG9yXCIpLmdldFN0cmVhbSh7XG4gICAgICAgICAgICBmaWxlbmFtZTogcGF0aC5qb2luKHRoaXMuZGlybmFtZSwgdGhpcy5maWxlbmFtZSksXG4gICAgICAgICAgICBmcmVxdWVuY3k6IG9wdGlvbnMuZnJlcXVlbmN5ID8gb3B0aW9ucy5mcmVxdWVuY3kgOiBcImN1c3RvbVwiLFxuICAgICAgICAgICAgZGF0ZV9mb3JtYXQ6IG9wdGlvbnMuZGF0ZVBhdHRlcm4gPyBvcHRpb25zLmRhdGVQYXR0ZXJuIDogXCJZWVlZLU1NLUREXCIsXG4gICAgICAgICAgICB2ZXJib3NlOiBmYWxzZSxcbiAgICAgICAgICAgIHNpemU6IGdldE1heFNpemUob3B0aW9ucy5tYXhTaXplKSxcbiAgICAgICAgICAgIG1heF9sb2dzOiBvcHRpb25zLm1heEZpbGVzLFxuICAgICAgICAgICAgZW5kX3N0cmVhbTogdHJ1ZSxcbiAgICAgICAgICAgIGF1ZGl0X2ZpbGU6IG9wdGlvbnMuYXVkaXRGaWxlXG4gICAgICAgICAgICAgICAgPyBvcHRpb25zLmF1ZGl0RmlsZVxuICAgICAgICAgICAgICAgIDogcGF0aC5qb2luKHRoaXMuZGlybmFtZSwgXCIuXCIgKyBoYXNoKG9wdGlvbnMpICsgXCItYXVkaXQuanNvblwiKSxcbiAgICAgICAgICAgIGZpbGVfb3B0aW9uczogb3B0aW9ucy5vcHRpb25zID8gb3B0aW9ucy5vcHRpb25zIDogeyBmbGFnczogXCJhXCIgfSxcbiAgICAgICAgICAgIHV0Yzogb3B0aW9ucy51dGMgPyBvcHRpb25zLnV0YyA6IGZhbHNlLFxuICAgICAgICAgICAgZXh0ZW5zaW9uOiBvcHRpb25zLmV4dGVuc2lvbiA/IG9wdGlvbnMuZXh0ZW5zaW9uIDogXCJcIixcbiAgICAgICAgICAgIGNyZWF0ZV9zeW1saW5rOiBvcHRpb25zLmNyZWF0ZVN5bWxpbmsgPyBvcHRpb25zLmNyZWF0ZVN5bWxpbmsgOiBmYWxzZSxcbiAgICAgICAgICAgIHN5bWxpbmtfbmFtZTogb3B0aW9ucy5zeW1saW5rTmFtZSA/IG9wdGlvbnMuc3ltbGlua05hbWUgOiBcImN1cnJlbnQubG9nXCIsXG4gICAgICAgICAgICB3YXRjaF9sb2c6IG9wdGlvbnMud2F0Y2hMb2cgPyBvcHRpb25zLndhdGNoTG9nIDogZmFsc2UsXG4gICAgICAgICAgICBhdWRpdF9oYXNoX3R5cGU6IG9wdGlvbnMuYXVkaXRIYXNoVHlwZSA/IG9wdGlvbnMuYXVkaXRIYXNoVHlwZSA6IFwic2hhMjU2XCJcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5sb2dTdHJlYW0ub24oXCJuZXdcIiwgKG5ld0ZpbGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcIm5ld1wiLCBuZXdGaWxlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5sb2dTdHJlYW0ub24oXCJyb3RhdGVcIiwgKG9sZEZpbGUsIG5ld0ZpbGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcInJvdGF0ZVwiLCBvbGRGaWxlLCBuZXdGaWxlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5sb2dTdHJlYW0ub24oXCJsb2dSZW1vdmVkXCIsIChwYXJhbXMpID0+IHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnppcHBlZEFyY2hpdmUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBnek5hbWUgPSBwYXJhbXMubmFtZSArIFwiLmd6XCI7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZnMudW5saW5rU3luYyhnek5hbWUpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAvLyBFTk9FTlQgaXMgb2theSwgbWVhbnMgZmlsZSBkb2Vzbid0IGV4aXN0LCBvdGhlciBlcnJvcnMgcHJldmVudCBkZWxldGlvbiwgc28gcmVwb3J0IGl0XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIuY29kZSAhPT0gXCJFTk9FTlRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSBgRXJyb3Igb2NjdXJyZWQgd2hpbGUgcmVtb3ZpbmcgJHtnek5hbWV9OiAke2Vyci5tZXNzYWdlfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImxvZ1JlbW92ZWRcIiwgZ3pOYW1lKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJsb2dSZW1vdmVkXCIsIHBhcmFtcy5uYW1lKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuemlwcGVkQXJjaGl2ZSkge1xuICAgICAgICAgICAgdGhpcy5sb2dTdHJlYW0ub24oXCJyb3RhdGVcIiwgKG9sZEZpbGUpID0+IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWZzLmV4aXN0c1N5bmMob2xkRmlsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSA9IGBFcnJvciBvY2N1cnJlZCB3aGlsZSBjaGVja2luZyBleGlzdGVuY2Ugb2YgJHtvbGRGaWxlfTogJHtlcnIubWVzc2FnZX1gO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmcy5leGlzdHNTeW5jKGAke29sZEZpbGV9Lmd6YCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSA9IGBFcnJvciBvY2N1cnJlZCB3aGlsZSBjaGVja2luZyBleGlzdGVuY2Ugb2YgJHtvbGRGaWxlfS5nejogJHtlcnIubWVzc2FnZX1gO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgZ3ppcCA9IHpsaWIuY3JlYXRlR3ppcCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlucCA9IGZzLmNyZWF0ZVJlYWRTdHJlYW0ob2xkRmlsZSk7XG4gICAgICAgICAgICAgICAgaW5wLm9uKFwiZXJyb3JcIiwgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSA9IGBFcnJvciBvY2N1cnJlZCB3aGlsZSByZWFkaW5nICR7b2xkRmlsZX06ICR7ZXJyLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBvdXQgPSBmcy5jcmVhdGVXcml0ZVN0cmVhbShvbGRGaWxlICsgXCIuZ3pcIik7XG4gICAgICAgICAgICAgICAgb3V0Lm9uKFwiZXJyb3JcIiwgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlcnIubWVzc2FnZSA9IGBFcnJvciBvY2N1cnJlZCB3aGlsZSB3cml0aW5nICR7b2xkRmlsZX0uZ3o6ICR7ZXJyLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpbnBcbiAgICAgICAgICAgICAgICAgICAgLnBpcGUoZ3ppcClcbiAgICAgICAgICAgICAgICAgICAgLnBpcGUob3V0KVxuICAgICAgICAgICAgICAgICAgICAub24oXCJmaW5pc2hcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcy51bmxpbmtTeW5jKG9sZEZpbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVyci5jb2RlICE9PSBcIkVOT0VOVFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlID0gYEVycm9yIG9jY3VycmVkIHdoaWxlIHJlbW92aW5nICR7b2xkRmlsZX06ICR7ZXJyLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImFyY2hpdmVcIiwgb2xkRmlsZSArIFwiLmd6XCIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9wdGlvbnMud2F0Y2hMb2cpIHtcbiAgICAgICAgICAgIHRoaXMubG9nU3RyZWFtLm9uKFwiYWRkV2F0Y2hlclwiLCAobmV3RmlsZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImFkZFdhdGNoZXJcIiwgbmV3RmlsZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRGFpbHlSb3RhdGVGaWxlO1xuXG51dGlsLmluaGVyaXRzKERhaWx5Um90YXRlRmlsZSwgVHJhbnNwb3J0KTtcblxuRGFpbHlSb3RhdGVGaWxlLnByb3RvdHlwZS5uYW1lID0gXCJkYWlseVJvdGF0ZUZpbGVcIjtcblxuY29uc3Qgbm9vcCA9IGZ1bmN0aW9uKCkge307XG5EYWlseVJvdGF0ZUZpbGUucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uIChpbmZvLCBjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcDtcblxuICAgIHRoaXMubG9nU3RyZWFtLndyaXRlKGluZm9bTUVTU0FHRV0gKyB0aGlzLm9wdGlvbnMuZW9sKTtcbiAgICB0aGlzLmVtaXQoXCJsb2dnZWRcIiwgaW5mbyk7XG4gICAgY2FsbGJhY2sobnVsbCwgdHJ1ZSk7XG59O1xuXG5EYWlseVJvdGF0ZUZpbGUucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmxvZ1N0cmVhbSkge1xuICAgICAgICB0aGlzLmxvZ1N0cmVhbS5lbmQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZmluaXNoXCIpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG5EYWlseVJvdGF0ZUZpbGUucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24gKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBvcHRpb25zO1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuanNvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcInF1ZXJ5KCkgbWF5IG5vdCBiZSB1c2VkIHdpdGhvdXQgdGhlIGpzb24gb3B0aW9uIGJlaW5nIHNldCB0byB0cnVlXCJcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZmlsZW5hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicXVlcnkoKSBtYXkgbm90IGJlIHVzZWQgd2hlbiBpbml0aWFsaXppbmcgd2l0aCBhIHN0cmVhbVwiKTtcbiAgICB9XG5cbiAgICBsZXQgcmVzdWx0cyA9IFtdO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgLy8gbGltaXRcbiAgICBvcHRpb25zLnJvd3MgPSBvcHRpb25zLnJvd3MgfHwgb3B0aW9ucy5saW1pdCB8fCAxMDtcblxuICAgIC8vIHN0YXJ0aW5nIHJvdyBvZmZzZXRcbiAgICBvcHRpb25zLnN0YXJ0ID0gb3B0aW9ucy5zdGFydCB8fCAwO1xuXG4gICAgLy8gbm93XG4gICAgb3B0aW9ucy51bnRpbCA9IG9wdGlvbnMudW50aWwgfHwgbmV3IERhdGUoKTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudW50aWwgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgb3B0aW9ucy51bnRpbCA9IG5ldyBEYXRlKG9wdGlvbnMudW50aWwpO1xuICAgIH1cblxuICAgIC8vIG5vdyAtIDI0XG4gICAgb3B0aW9ucy5mcm9tID0gb3B0aW9ucy5mcm9tIHx8IG9wdGlvbnMudW50aWwgLSAyNCAqIDYwICogNjAgKiAxMDAwO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mcm9tICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIG9wdGlvbnMuZnJvbSA9IG5ldyBEYXRlKG9wdGlvbnMuZnJvbSk7XG4gICAgfVxuXG4gICAgLy8gJ2FzYycgb3IgJ2Rlc2MnXG4gICAgb3B0aW9ucy5vcmRlciA9IG9wdGlvbnMub3JkZXIgfHwgXCJkZXNjXCI7XG5cbiAgICBjb25zdCBsb2dGaWxlcyA9ICgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpbGVSZWdleCA9IG5ldyBSZWdFeHAodGhpcy5maWxlbmFtZS5yZXBsYWNlKFwiJURBVEUlXCIsIFwiLipcIiksIFwiaVwiKTtcbiAgICAgICAgcmV0dXJuIGZzLnJlYWRkaXJTeW5jKHRoaXMuZGlybmFtZSkuZmlsdGVyKChmaWxlKSA9PiBwYXRoLmJhc2VuYW1lKGZpbGUpLm1hdGNoKGZpbGVSZWdleCkpO1xuICAgIH0pKCk7XG5cbiAgICBpZiAobG9nRmlsZXMubGVuZ3RoID09PSAwICYmIGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdHMpO1xuICAgIH1cblxuICAgIGNvbnN0IHByb2Nlc3NMb2dGaWxlID0gKGZpbGUpID0+IHtcbiAgICAgICAgaWYgKCFmaWxlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBsb2dGaWxlID0gcGF0aC5qb2luKHRoaXMuZGlybmFtZSwgZmlsZSk7XG4gICAgICAgIGxldCBidWZmID0gXCJcIjtcblxuICAgICAgICBsZXQgc3RyZWFtO1xuXG4gICAgICAgIGlmIChmaWxlLmVuZHNXaXRoKFwiLmd6XCIpKSB7XG4gICAgICAgICAgICBzdHJlYW0gPSBuZXcgUGFzc1Rocm91Z2goKTtcbiAgICAgICAgICAgIGNvbnN0IGlucCA9IGZzLmNyZWF0ZVJlYWRTdHJlYW0obG9nRmlsZSk7XG4gICAgICAgICAgICBpbnAub24oXCJlcnJvclwiLCAgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlID0gYEVycm9yIG9jY3VycmVkIHdoaWxlIHJlYWRpbmcgJHtsb2dGaWxlfTogJHtlcnIubWVzc2FnZX1gO1xuICAgICAgICAgICAgICAgIHN0cmVhbS5lbWl0KFwiZXJyb3JcIiwgZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaW5wLnBpcGUoemxpYi5jcmVhdGVHdW56aXAoKSkucGlwZShzdHJlYW0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RyZWFtID0gZnMuY3JlYXRlUmVhZFN0cmVhbShsb2dGaWxlLCB7XG4gICAgICAgICAgICAgICAgZW5jb2Rpbmc6IFwidXRmOFwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBzdHJlYW0ub24oXCJlcnJvclwiLCAgKGVycikgPT4ge1xuICAgICAgICAgICAgaWYgKHN0cmVhbS5yZWFkYWJsZSkge1xuICAgICAgICAgICAgICAgIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBlcnIuY29kZSA9PT0gXCJFTk9FTlRcIiA/IGNhbGxiYWNrKG51bGwsIHJlc3VsdHMpIDogY2FsbGJhY2soZXJyKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc3RyZWFtLm9uKFwiZGF0YVwiLCAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgZGF0YSA9IChidWZmICsgZGF0YSkuc3BsaXQoL1xcbisvKTtcbiAgICAgICAgICAgIGNvbnN0IGwgPSBkYXRhLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYWRkKGRhdGFbaV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBidWZmID0gZGF0YVtsXTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc3RyZWFtLm9uKFwiZW5kXCIsICAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoYnVmZikge1xuICAgICAgICAgICAgICAgIGFkZChidWZmLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGxvZ0ZpbGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHByb2Nlc3NMb2dGaWxlKGxvZ0ZpbGVzLnNoaWZ0KCkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMuc29ydCggKGEsIGIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZDEgPSBuZXcgRGF0ZShhLnRpbWVzdGFtcCkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkMiA9IG5ldyBEYXRlKGIudGltZXN0YW1wKS5nZXRUaW1lKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQxID4gZDIgPyAxIDogZDEgPCBkMiA/IC0xIDogMDtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm9yZGVyID09PSBcImRlc2NcIikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5yZXZlcnNlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBvcHRpb25zLnN0YXJ0IHx8IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgbGltaXQgPSBvcHRpb25zLmxpbWl0IHx8IHJlc3VsdHMubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuc2xpY2Uoc3RhcnQsIHN0YXJ0ICsgbGltaXQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZmllbGRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLm1hcCggKGxvZykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmZpZWxkcy5mb3JFYWNoKCAoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqW2tleV0gPSBsb2dba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGZ1bmN0aW9uIGFkZChidWZmLCBhdHRlbXB0KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvZyA9IEpTT04ucGFyc2UoYnVmZik7XG4gICAgICAgICAgICAgICAgaWYgKCFsb2cgfHwgdHlwZW9mIGxvZyAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgdGltZSA9IG5ldyBEYXRlKGxvZy50aW1lc3RhbXApO1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgKG9wdGlvbnMuZnJvbSAmJiB0aW1lIDwgb3B0aW9ucy5mcm9tKSB8fFxuICAgICAgICAgICAgICAgICAgICAob3B0aW9ucy51bnRpbCAmJiB0aW1lID4gb3B0aW9ucy51bnRpbCkgfHxcbiAgICAgICAgICAgICAgICAgICAgKG9wdGlvbnMubGV2ZWwgJiYgb3B0aW9ucy5sZXZlbCAhPT0gbG9nLmxldmVsKVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGxvZyk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFhdHRlbXB0KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5lbWl0KFwiZXJyb3JcIiwgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBwcm9jZXNzTG9nRmlsZShsb2dGaWxlcy5zaGlmdCgpKTtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/winston-daily-rotate-file/daily-rotate-file.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/winston-daily-rotate-file/index.js":
/*!*************************************************************!*\
  !*** ../../node_modules/winston-daily-rotate-file/index.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const winston = __webpack_require__(/*! winston */ \"(rsc)/../../node_modules/winston/lib/winston.js\");\nconst DailyRotateFile = __webpack_require__(/*! ./daily-rotate-file */ \"(rsc)/../../node_modules/winston-daily-rotate-file/daily-rotate-file.js\");\n\nwinston.transports.DailyRotateFile = DailyRotateFile;\nmodule.exports = DailyRotateFile;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzL3dpbnN0b24tZGFpbHktcm90YXRlLWZpbGUvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsZ0JBQWdCLG1CQUFPLENBQUMsZ0VBQVM7QUFDakMsd0JBQXdCLG1CQUFPLENBQUMsb0dBQXFCOztBQUVyRDtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWFya3VzaG9nbmUvRG9jdW1lbnRzL0FQUFMvYmF6YWFyLXZpZC9iYXphYXItdmlkL25vZGVfbW9kdWxlcy93aW5zdG9uLWRhaWx5LXJvdGF0ZS1maWxlL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHdpbnN0b24gPSByZXF1aXJlKFwid2luc3RvblwiKTtcbmNvbnN0IERhaWx5Um90YXRlRmlsZSA9IHJlcXVpcmUoXCIuL2RhaWx5LXJvdGF0ZS1maWxlXCIpO1xuXG53aW5zdG9uLnRyYW5zcG9ydHMuRGFpbHlSb3RhdGVGaWxlID0gRGFpbHlSb3RhdGVGaWxlO1xubW9kdWxlLmV4cG9ydHMgPSBEYWlseVJvdGF0ZUZpbGU7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/winston-daily-rotate-file/index.js\n");

/***/ })

};
;